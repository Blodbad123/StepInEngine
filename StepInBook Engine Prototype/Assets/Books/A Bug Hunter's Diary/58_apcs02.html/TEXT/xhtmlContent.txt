<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>C.2 RELRO</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="C.2 RELRO"><div class="titlepage"><div><div><h1 class="title"><a id="c.2_relro"/>C.2 RELRO</h1></div></div></div><p>RELRO is a generic exploit mitigation technique to harden the data sections of an ELF<sup>[<a href="apcs03.html#ftn.APP-C-FN-10" class="footnoteref">109</a>]</sup> binary or process. ELF is a common file format for executables and libraries that is used by a variety of UNIX-like systems, including Linux, Solaris, and BSD. RELRO has two different modes:<a id="IDX-APP-C-0111" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Partial RELRO</strong></span></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Compiler command line: <code class="literal">gcc -Wl,-z,relro</code>.</p></li><li class="listitem"><p>The ELF sections are reordered so that the ELF internal data sections (<code class="literal">.got</code>, <code class="literal">.dtors</code>, etc.) precede the program’s data sections (<code class="literal">.data</code> and <code class="literal">.bss</code>).</p></li><li class="listitem"><p>Non-PLT GOT is read-only.</p></li><li class="listitem"><p>PLT-dependent GOT is still writeable.</p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Full RELRO</strong></span></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Compiler command line: <code class="literal">gcc -Wl,-z,relro,-z,now</code>.</p></li><li class="listitem"><p>Supports all the features of Partial RELRO.</p></li><li class="listitem"><p>Bonus: The entire GOT is (re)mapped as read-only.</p></li></ul></div></dd></dl></div><p>Both Partial and Full RELRO reorder the ELF internal data sections to protect them from being overwritten in the event of a buffer overflow in the program’s data sections (<code class="literal">.data</code> and <code class="literal">.bss</code>), but only Full RELRO mitigates the popular technique of modifying a GOT entry to get control over the program execution flow (see Section A.4).</p><p>To demonstrate the RELRO mitigation technique, I made up two simple test cases. I used Debian Linux 6.0 as a platform.<a id="IDX-APP-C-0112" class="indexterm"/></p><div class="sect2" title="Test Case 1: Partial RELRO"><div class="titlepage"><div><div><h2 class="title"><a id="test_case_1_colon_partial_relro"/>Test Case 1: Partial RELRO</h2></div></div></div><p>The test program in <a class="xref" href="apcs02.html#example_code_used_to_demonstrate" title="Example C-1. Example code used to demonstrate RELRO (testcase.c)">Example C-1</a> takes a memory address (see line 6) and tries to write the value <code class="literal">0x41414141</code> at that address (see line 8).</p><div class="example"><a id="example_code_used_to_demonstrate"/><p class="title">Example C-1. Example code used to demonstrate RELRO (<span class="emphasis"><em>testcase.c</em></span>)</p><div class="example-contents"><pre class="programlisting">01    #include &lt;stdio.h&gt;
02
03    int
04    main (int argc, char *argv[])
05    {
06      size_t *p = (size_t *)strtol (argv[1], NULL, 16);
07
08      p[0] = 0x41414141;
09      printf ("RELRO: %p\n", p);
10
11      return 0;
12    }</pre></div></div><p>I compiled the program with Partial RELRO support:</p><a id="I_programlisting_d1e12463"/><pre class="programlisting">linux$ <strong class="userinput"><code>gcc -g -Wl,-z,relro -o testcase testcase.c</code></strong></pre><p>I then checked the resulting binary with my <code class="literal">checksec.sh</code> script:<sup>[<a href="apcs03.html#ftn.APP-C-FN-11" class="footnoteref">110</a>]</sup></p><a id="I_programlisting_d1e12473"/><pre class="programlisting">linux$ <strong class="userinput"><code>./checksec.sh --file testcase</code></strong>
RELRO           STACK CANARY      NX            PIE                     FILE
Partial RELRO   No canary found   NX enabled    No PIE                  testcase</pre><p>Next I used <code class="literal">objdump</code> to gather the GOT address of the <code class="literal">printf()</code> library function used in line 9 of <a class="xref" href="apcs02.html#example_code_used_to_demonstrate" title="Example C-1. Example code used to demonstrate RELRO (testcase.c)">Example C-1</a> and then tried to overwrite that GOT entry:<a id="IDX-APP-C-0113" class="indexterm"/></p><a id="I_programlisting_d1e12491"/><pre class="programlisting">linux$ <strong class="userinput"><code>objdump -R ./testcase | grep printf</code></strong>
0804a00c R_386_JUMP_SLOT   printf</pre><p>I started the test program in gdb in order to see exactly what was happening:</p><a id="I_programlisting_d1e12498"/><pre class="programlisting">linux$ <strong class="userinput"><code>gdb -q ./testcase</code></strong>

(gdb) <strong class="userinput"><code>run 0804a00c</code></strong>
Starting program: /home/tk/BHD/testcase 0804a00c

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()

(gdb) <strong class="userinput"><code>info registers eip</code></strong>
eip            0x41414141     0x41414141</pre><p>Result: If only Partial RELRO is used to protect an ELF binary, it is still possible to modify arbitrary GOT entries to gain control of the execution flow of a process.</p></div><div class="sect2" title="Test Case 2: Full RELRO"><div class="titlepage"><div><div><h2 class="title"><a id="test_case_2_colon_full_relro"/>Test Case 2: Full RELRO</h2></div></div></div><p>This time, I compiled the test program with Full RELRO support:</p><a id="I_programlisting_d1e12517"/><pre class="programlisting">linux$ <strong class="userinput"><code>gcc -g -Wl,-z,relro,-z,now -o testcase testcase.c</code></strong>

linux$ <strong class="userinput"><code>./checksec.sh --file testcase</code></strong>
RELRO           STACK CANARY      NX            PIE                     FILE
Full RELRO      No canary found   NX enabled    No PIE                  testcase</pre><p>I then tried to overwrite the GOT address of <code class="literal">printf()</code> again:</p><a id="I_programlisting_d1e12530"/><pre class="programlisting">linux$ <strong class="userinput"><code>objdump -R ./testcase | grep printf</code></strong>
08049ff8 R_386_JUMP_SLOT   printf

linux$ <strong class="userinput"><code>gdb -q ./testcase</code></strong>

(gdb) <strong class="userinput"><code>run 08049ff8</code></strong>
Starting program: /home/tk/BHD/testcase 08049ff8

Program received signal SIGSEGV, Segmentation fault.
0x08048445 in main (argc=2, argv=0xbffff814) at testcase.c:8
8          p[0] = 0x41414141;</pre><p>This time, the execution flow was interrupted by a <code class="literal">SIGSEGV</code> signal at source code line 8. Let’s see why:</p><a id="I_programlisting_d1e12546"/><pre class="programlisting">(gdb) <strong class="userinput"><code>set disassembly-flavor intel</code></strong>

(gdb) <strong class="userinput"><code>x/1i $eip</code></strong>
0x8048445 &lt;main+49&gt;:    mov    DWORD PTR [eax],0x41414141

(gdb) <strong class="userinput"><code>info registers eax</code></strong>
eax            0x8049ff8        134520824</pre><p>As expected, the program tried to write the value <code class="literal">0x41414141</code> at the given memory address <code class="literal">0x8049ff8</code>.</p><a id="I_programlisting_d1e12565"/><pre class="programlisting">(gdb) <strong class="userinput"><code>shell cat /proc/$(pidof testcase)/maps</code></strong>
08048000-08049000 r-xp 00000000 08:01 497907     /home/tk/testcase
<strong class="userinput"><code>08049000-0804a000 r--p 00000000 08:01 497907     /home/tk/testcase</code></strong>
0804a000-0804b000 rw-p 00001000 08:01 497907     /home/tk/testcase
b7e8a000-b7e8b000 rw-p 00000000 00:00 0
b7e8b000-b7fcb000 r-xp 00000000 08:01 181222     /lib/i686/cmov/libc-2.11.2.so
b7fcb000-b7fcd000 r--p 0013f000 08:01 181222     /lib/i686/cmov/libc-2.11.2.so
b7fcd000-b7fce000 rw-p 00141000 08:01 181222     /lib/i686/cmov/libc-2.11.2.so
b7fce000-b7fd1000 rw-p 00000000 00:00 0
b7fe0000-b7fe2000 rw-p 00000000 00:00 0
b7fe2000-b7fe3000 r-xp 00000000 00:00 0          [vdso]
b7fe3000-b7ffe000 r-xp 00000000 08:01 171385     /lib/ld-2.11.2.so
b7ffe000-b7fff000 r--p 0001a000 08:01 171385     /lib/ld-2.11.2.so
b7fff000-b8000000 rw-p 0001b000 08:01 171385     /lib/ld-2.11.2.so
bffeb000-c0000000 rw-p 00000000 00:00 0          [stack]</pre><p>The memory map of the process shows that the memory range <code class="literal">08049000-0804a000</code>, which includes the GOT, was successfully set to read-only (<code class="literal">r--p</code>).</p><p>Result: If Full RELRO is enabled, the attempt to overwrite a GOT address leads to an error because the GOT section is mapped read-only.</p></div><div class="sect2" title="Conclusion"><div class="titlepage"><div><div><h2 class="title"><a id="conclusion"/>Conclusion</h2></div></div></div><p>In case of a buffer overflow in the program’s data sections (<code class="literal">.data</code> and <code class="literal">.bss</code>), both Partial and Full RELRO protect the ELF internal data sections from being overwritten.</p><p>With Full RELRO, it’s possible to successfully prevent the modification of GOT entries.</p><p>There is also a generic way to implement a similar mitigation technique for ELF objects, which works on platforms that don’t support RELRO.<sup>[<a href="apcs03.html#ftn.APP-C-FN-12" class="footnoteref">111</a>]</sup></p></div></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>C.2 RELRO</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="C.2 RELRO"><div class="titlepage"><div><div><h1 class="title"><a id="c.2_relro"/>C.2 RELRO</h1></div></div></div><p>RELRO is a generic exploit mitigation technique to harden the data sections of an ELF<sup>[<a href="apcs03.html#ftn.APP-C-FN-10" class="footnoteref">109</a>]</sup> binary or process. ELF is a common file format for executables and libraries that is used by a variety of UNIX-like systems, including Linux, Solaris, and BSD. RELRO has two different modes:<a id="IDX-APP-C-0111" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Partial RELRO</strong></span></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Compiler command line: <code class="literal">gcc -Wl,-z,relro</code>.</p></li><li class="listitem"><p>The ELF sections are reordered so that the ELF internal data sections (<code class="literal">.got</code>, <code class="literal">.dtors</code>, etc.) precede the program’s data sections (<code class="literal">.data</code> and <code class="literal">.bss</code>).</p></li><li class="listitem"><p>Non-PLT GOT is read-only.</p></li><li class="listitem"><p>PLT-dependent GOT is still writeable.</p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Full RELRO</strong></span></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Compiler command line: <code class="literal">gcc -Wl,-z,relro,-z,now</code>.</p></li><li class="listitem"><p>Supports all the features of Partial RELRO.</p></li><li class="listitem"><p>Bonus: The entire GOT is (re)mapped as read-only.</p></li></ul></div></dd></dl></div><p>Both Partial and Full RELRO reorder the ELF internal data sections to protect them from being overwritten in the event of a buffer overflow in the program’s data sections (<code class="literal">.data</code> and <code class="literal">.bss</code>), but only Full RELRO mitigates the popular technique of modifying a GOT entry to get control over the program execution flow (see Section A.4).</p><p>To demonstrate the RELRO mitigation technique, I made up two simple test cases. I used Debian Linux 6.0 as a platform.<a id="IDX-APP-C-0112" class="indexterm"/></p><div class="sect2" title="Test Case 1: Partial RELRO"><div class="titlepage"><div><div><h2 class="title"><a id="test_case_1_colon_partial_relro"/>Test Case 1: Partial RELRO</h2></div></div></div><p>The test program in <a class="xref" href="apcs02.html#example_code_used_to_demonstrate" title="Example C-1. Example code used to demonstrate RELRO (testcase.c)">Example C-1</a> takes a memory address (see line 6) and tries to write the value <code class="literal">0x41414141</code> at that address (see line 8).</p><div class="example"><a id="example_code_used_to_demonstrate"/><p class="title">Example C-1. Example code used to demonstrate RELRO (<span class="emphasis"><em>testcase.c</em></span>)</p><div class="example-contents"><pre class="programlisting">01    #include &lt;stdio.h&gt;
02
03    int
04    main (int argc, char *argv[])
05    {
06      size_t *p = (size_t *)strtol (argv[1], NULL, 16);
07
08      p[0] = 0x41414141;
09      printf ("RELRO: %p\n", p);
10
11      return 0;
12    }</pre></div></div><p>I compiled the program with Partial RELRO support:</p><a id="I_programlisting_d1e12463"/><pre class="programlisting">linux$ <strong class="userinput"><code>gcc -g -Wl,-z,relro -o testcase testcase.c</code></strong></pre><p>I then checked the resulting binary with my <code class="literal">checksec.sh</code> script:<sup>[<a href="apcs03.html#ftn.APP-C-FN-11" class="footnoteref">110</a>]</sup></p><a id="I_programlisting_d1e12473"/><pre class="programlisting">linux$ <strong class="userinput"><code>./checksec.sh --file testcase</code></strong>
RELRO           STACK CANARY      NX            PIE                     FILE
Partial RELRO   No canary found   NX enabled    No PIE                  testcase</pre><p>Next I used <code class="literal">objdump</code> to gather the GOT address of the <code class="literal">printf()</code> library function used in line 9 of <a class="xref" href="apcs02.html#example_code_used_to_demonstrate" title="Example C-1. Example code used to demonstrate RELRO (testcase.c)">Example C-1</a> and then tried to overwrite that GOT entry:<a id="IDX-APP-C-0113" class="indexterm"/></p><a id="I_programlisting_d1e12491"/><pre class="programlisting">linux$ <strong class="userinput"><code>objdump -R ./testcase | grep printf</code></strong>
0804a00c R_386_JUMP_SLOT   printf</pre><p>I started the test program in gdb in order to see exactly what was happening:</p><a id="I_programlisting_d1e12498"/><pre class="programlisting">linux$ <strong class="userinput"><code>gdb -q ./testcase</code></strong>

(gdb) <strong class="userinput"><code>run 0804a00c</code></strong>
Starting program: /home/tk/BHD/testcase 0804a00c

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()

(gdb) <strong class="userinput"><code>info registers eip</code></strong>
eip            0x41414141     0x41414141</pre><p>Result: If only Partial RELRO is used to protect an ELF binary, it is still possible to modify arbitrary GOT entries to gain control of the execution flow of a process.</p></div><div class="sect2" title="Test Case 2: Full RELRO"><div class="titlepage"><div><div><h2 class="title"><a id="test_case_2_colon_full_relro"/>Test Case 2: Full RELRO</h2></div></div></div><p>This time, I compiled the test program with Full RELRO support:</p><a id="I_programlisting_d1e12517"/><pre class="programlisting">linux$ <strong class="userinput"><code>gcc -g -Wl,-z,relro,-z,now -o testcase testcase.c</code></strong>

linux$ <strong class="userinput"><code>./checksec.sh --file testcase</code></strong>
RELRO           STACK CANARY      NX            PIE                     FILE
Full RELRO      No canary found   NX enabled    No PIE                  testcase</pre><p>I then tried to overwrite the GOT address of <code class="literal">printf()</code> again:</p><a id="I_programlisting_d1e12530"/><pre class="programlisting">linux$ <strong class="userinput"><code>objdump -R ./testcase | grep printf</code></strong>
08049ff8 R_386_JUMP_SLOT   printf

linux$ <strong class="userinput"><code>gdb -q ./testcase</code></strong>

(gdb) <strong class="userinput"><code>run 08049ff8</code></strong>
Starting program: /home/tk/BHD/testcase 08049ff8

Program received signal SIGSEGV, Segmentation fault.
0x08048445 in main (argc=2, argv=0xbffff814) at testcase.c:8
8          p[0] = 0x41414141;</pre><p>This time, the execution flow was interrupted by a <code class="literal">SIGSEGV</code> signal at source code line 8. Let’s see why:</p><a id="I_programlisting_d1e12546"/><pre class="programlisting">(gdb) <strong class="userinput"><code>set disassembly-flavor intel</code></strong>

(gdb) <strong class="userinput"><code>x/1i $eip</code></strong>
0x8048445 &lt;main+49&gt;:    mov    DWORD PTR [eax],0x41414141

(gdb) <strong class="userinput"><code>info registers eax</code></strong>
eax            0x8049ff8        134520824</pre><p>As expected, the program tried to write the value <code class="literal">0x41414141</code> at the given memory address <code class="literal">0x8049ff8</code>.</p><a id="I_programlisting_d1e12565"/><pre class="programlisting">(gdb) <strong class="userinput"><code>shell cat /proc/$(pidof testcase)/maps</code></strong>
08048000-08049000 r-xp 00000000 08:01 497907     /home/tk/testcase
<strong class="userinput"><code>08049000-0804a000 r--p 00000000 08:01 497907     /home/tk/testcase</code></strong>
0804a000-0804b000 rw-p 00001000 08:01 497907     /home/tk/testcase
b7e8a000-b7e8b000 rw-p 00000000 00:00 0
b7e8b000-b7fcb000 r-xp 00000000 08:01 181222     /lib/i686/cmov/libc-2.11.2.so
b7fcb000-b7fcd000 r--p 0013f000 08:01 181222     /lib/i686/cmov/libc-2.11.2.so
b7fcd000-b7fce000 rw-p 00141000 08:01 181222     /lib/i686/cmov/libc-2.11.2.so
b7fce000-b7fd1000 rw-p 00000000 00:00 0
b7fe0000-b7fe2000 rw-p 00000000 00:00 0
b7fe2000-b7fe3000 r-xp 00000000 00:00 0          [vdso]
b7fe3000-b7ffe000 r-xp 00000000 08:01 171385     /lib/ld-2.11.2.so
b7ffe000-b7fff000 r--p 0001a000 08:01 171385     /lib/ld-2.11.2.so
b7fff000-b8000000 rw-p 0001b000 08:01 171385     /lib/ld-2.11.2.so
bffeb000-c0000000 rw-p 00000000 00:00 0          [stack]</pre><p>The memory map of the process shows that the memory range <code class="literal">08049000-0804a000</code>, which includes the GOT, was successfully set to read-only (<code class="literal">r--p</code>).</p><p>Result: If Full RELRO is enabled, the attempt to overwrite a GOT address leads to an error because the GOT section is mapped read-only.</p></div><div class="sect2" title="Conclusion"><div class="titlepage"><div><div><h2 class="title"><a id="conclusion"/>Conclusion</h2></div></div></div><p>In case of a buffer overflow in the program’s data sections (<code class="literal">.data</code> and <code class="literal">.bss</code>), both Partial and Full RELRO protect the ELF internal data sections from being overwritten.</p><p>With Full RELRO, it’s possible to successfully prevent the modification of GOT entries.</p><p>There is also a generic way to implement a similar mitigation technique for ELF objects, which works on platforms that don’t support RELRO.<sup>[<a href="apcs03.html#ftn.APP-C-FN-12" class="footnoteref">111</a>]</sup></p></div></div></body></html>
