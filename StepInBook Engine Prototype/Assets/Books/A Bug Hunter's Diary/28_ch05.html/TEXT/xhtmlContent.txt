<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 5. Browse and You’re Owned</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="chapter" title="Chapter 5. Browse and You’re Owned"><div class="titlepage"><div><div><h1 class="title"><a id="browse_and_youare_owned"/>Chapter 5. Browse and You’re Owned</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Sunday, April 6, 2008</em></span><a id="IDX-CHP-5-0001" class="indexterm"/></p><p><span class="emphasis"><em>Dear Diary</em></span>,</p></div><p>Vulnerabilities in browsers and browser add-ons are all the rage these days, so I decided to have a look at some ActiveX controls. The first one on my list was Cisco’s online meeting and web-conferencing software called WebEx, which is widely used in business. After spending some time reverse engineering the WebEx ActiveX control for Microsoft’s Internet Explorer, I found an obvious bug that I could have found in a few seconds if I had fuzzed the control instead of reading the assembly. Fail. <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e5037"/><img src="httpatomoreillycomsourcenostarchimages939227.png" alt=""/></span><a id="IDX-CHP-5-0002" class="indexterm"/><a id="IDX-CHP-5-0003" class="indexterm"/><a id="IDX-CHP-5-0004" class="indexterm"/></p><div class="sect1" title="5.1 Vulnerability Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_discovery-id3"/>5.1 Vulnerability Discovery</h1></div></div></div><p>I used the following process to search for a vulnerability:</p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>I used Windows XP SP3 32-bit and Internet Explorer 6 as the platform for all the following steps</em></span>.<a id="IDX-CHP-5-0005" class="indexterm"/></p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: List the registered WebEx objects and exported methods.</p></li><li class="listitem"><p>Step 2: Test the exported methods in the browser.</p></li><li class="listitem"><p>Step 3: Find the object methods in the binary.</p></li><li class="listitem"><p>Step 4: Find the user-controlled input values.</p></li><li class="listitem"><p>Step 5: Reverse engineer the object methods.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>A download link for the vulnerable version of WebEx Meeting Manager can be found at <a class="ulink" href="http://www.trapkit.de/books/bhd/">http://www.trapkit.de/books/bhd/</a>.</p></div><div class="sect2" title="Step 1: List the Registered WebEx Objects and Exported Methods"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_list_the_registered_webex_o"/>Step 1: List the Registered WebEx Objects and Exported Methods</h2></div></div></div><p>After downloading and installing the WebEx Meeting Manager software, I fired up COMRaider<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-1" class="footnoteref">45</a>]</sup> to generate a list of the exported interfaces the control provides to the caller. I clicked the <span class="strong"><strong>Start</strong></span> button in COMRaider and selected <span class="strong"><strong>Scan a directory for registered COM servers</strong></span> to test the WebEx components installed in <span class="emphasis"><em>C:\Program Files\Webex\</em></span>.<a id="IDX-CHP-5-0006" class="indexterm"/></p><p>As <a class="xref" href="ch05.html#registered_webex_objects_in_comraider" title="Figure 5-1. Registered WebEx objects in COMRaider">Figure 5-1</a> illustrates, two objects are registered in the WebEx install directory, and the object with GUID <code class="literal">{32E26FD9-F435-4A20-A561-35D4B987CFDC}</code> and ProgID <code class="literal">WebexUCFObject.WebexUCFObject.1</code> implements <code class="literal">IObjectSafety</code>. Internet Explorer will trust this object since it’s marked as <span class="emphasis"><em>safe for initialization</em></span> and <span class="emphasis"><em>safe for scripting</em></span>. That makes the object a promising target for “browse and you’re owned” attacks, since it’s possible to call its methods from within a web page.<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-2" class="footnoteref">46</a>]</sup></p><div class="figure"><a id="registered_webex_objects_in_comraider"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5128"/><img src="httpatomoreillycomsourcenostarchimages939281.png.jpg" alt="Registered WebEx objects in COMRaider"/></div></div><p class="title">Figure 5-1. Registered WebEx objects in COMRaider</p></div><p>Microsoft also provides a handy C# class called <code class="literal">ClassId.cs</code><sup>[<a href="ch05s05.html#ftn.CHP-5-FN-3" class="footnoteref">47</a>]</sup> that lists various properties of ActiveX controls. To use that class, I added the following lines to the source file and compiled it with the command-line version of Visual Studio’s C# compiler (<code class="literal">csc</code>):</p><a id="I_programlisting5_d1e5142"/><pre class="programlisting">[..]
namespace ClassId
{
    class ClassId
    {
        static void Main(string[] args)
        {
            SWI.ClassId_q.ClassId clsid = new SWI.ClassId_q.ClassId();

            if (args.Length == 0 || (args[0].Equals("/?") == true ||
                args[0].ToLower().StartsWith("-h") == true) ||
                args.Length &lt; 1)
            {
                Console.WriteLine("Usage: ClassID.exe &lt;CLSID&gt;\n");
                return;
            }

            clsid.set_clsid(args[0]);
            System.Console.WriteLine(clsid.ToString());
        }
    }
}</pre><p>To compile and use the tool, I ran the following commands in a command-prompt window:</p><a id="I_programlisting5_d1e5146"/><pre class="programlisting">C:\Documents and Settings\tk\Desktop&gt;<strong class="userinput"><code>csc /warn:0 /nologo ClassId.cs</code></strong>
C:\Documents and Settings\tk\Desktop&gt;
<strong class="userinput"><code>ClassId.exe {32E26FD9-F435-4A20-A561-35D4B987CFDC}</code></strong>
Clsid: {32E26FD9-F435-4A20-A561-35D4B987CFDC}
Progid: WebexUCFObject.WebexUCFObject.1
Binary Path: C:\Program Files\WebEx\WebEx\824\atucfobj.dll
<strong class="userinput"><code>Implements IObjectSafety: True</code></strong>
<strong class="userinput"><code>Safe For Initialization (IObjectSafety): True</code></strong>
<strong class="userinput"><code>Safe For Scripting (IObjectSafety): True</code></strong>
Safe For Initialization (Registry): False
Safe For Scripting (Registry): False
KillBitted: False</pre><p>The output of the tool shows that the object was indeed marked as <span class="emphasis"><em>safe for initialization</em></span> and <span class="emphasis"><em>safe for scripting</em></span> using <code class="literal">IObjectSafety</code>.</p><p>I then clicked the <span class="strong"><strong>Select</strong></span> button in COMRaider to see a list of the public methods exported by the object with GUID <code class="literal">{32E26FD9-F435-4A20-A561-35D4B987CFDC}</code>. As illustrated in <a class="xref" href="ch05.html#public_methods_exported_by_the_object_wi" title="Figure 5-2. Public methods exported by the object with GUID {32E26FD9-F435-4A20-A561-35D4B987CFDC}.">Figure 5-2</a>, a method called <code class="literal">NewObject()</code> is exported by the object and takes a string value as input.</p><div class="figure"><a id="public_methods_exported_by_the_object_wi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5193"/><img src="httpatomoreillycomsourcenostarchimages939283.png.jpg" alt="Public methods exported by the object with GUID {32E26FD9-F435-4A20-A561-35D4B987CFDC}."/></div></div><p class="title">Figure 5-2. Public methods exported by the object with GUID <code class="literal">{32E26FD9-F435-4A20-A561-35D4B987CFDC}</code>.</p></div></div><div class="sect2" title="Step 2: Test the Exported Methods in the Browser"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_test_the_exported_methods_i"/>Step 2: Test the Exported Methods in the Browser</h2></div></div></div><p>After I generated lists of the available objects and exported methods, I wrote a little HTML file that calls the <code class="literal">NewObject()</code> method with the help of VBScript:<a id="IDX-CHP-5-0007" class="indexterm"/></p><div class="example"><a id="html_file_to_call_the"/><p class="title">Example 5-1. HTML file to call the <code class="literal">NewObject()</code> method (<span class="emphasis"><em>webex_poc1.html</em></span>)</p><div class="example-contents"><pre class="programlisting">01    &lt;html&gt;
02     &lt;title&gt;WebEx PoC 1&lt;/title&gt;
03     &lt;body&gt;
04      &lt;object classid="clsid:32E26FD9-F435-4A20-A561-
35D4B987CFDC" id="obj"&gt;&lt;/object&gt;
05      &lt;script language='vbscript'&gt;
06        arg = String(12, "A")
07        obj.NewObject arg
08      &lt;/script&gt;
09     &lt;/body&gt;
10    &lt;/html&gt;</pre></div></div><p>In line 4 of <a class="xref" href="ch05.html#html_file_to_call_the" title="Example 5-1. HTML file to call the NewObject() method (webex_poc1.html)">Example 5-1</a>, the object with GUID or ClassID <code class="literal">{32E26FD9-F435-4A20-A561-35D4B987CFDC}</code> is instantiated. In line 7 the <code class="literal">NewObject()</code> method is called with a string value of 12 As as a parameter.</p><p>To test the HTML file, I implemented a little web server in Python that would serve the <span class="emphasis"><em>webex_poc1.html</em></span> file to the browser (see <a class="xref" href="ch05.html#simple_web_server_implemented" title="Example 5-2. Simple web server implemented in Python that serves the webex_poc1.html file to the browser (wwwserv.py)">Example 5-2</a>):<a id="IDX-CHP-5-0008" class="indexterm"/></p><div class="example"><a id="simple_web_server_implemented"/><p class="title">Example 5-2. Simple web server implemented in Python that serves the <span class="emphasis"><em>webex_poc1.html</em></span> file to the browser (<span class="emphasis"><em>wwwserv.py</em></span>)</p><div class="example-contents"><pre class="programlisting">01    import string,cgi
02    from os import curdir, sep
03    from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
04
05    class WWWHandler(BaseHTTPRequestHandler):
06
07       def do_GET(self):
08           try:
09               f = open(curdir + sep + "webex_poc1.html")
10
11               self.send_response(200)
12               self.send_header('Content-type', 'text/html')
13               self.end_headers()
14               self.wfile.write(f.read())
15               f.close()
16
17               return
18
19           except IOError:
20               self.send_error(404,'File Not Found: %s' % self.path)
21
22    def main():
23       try:
24           server = HTTPServer(('', 80), WWWHandler)
25           print 'server started'
26           server.serve_forever()
27       except KeyboardInterrupt:
28           print 'shutting down server'
29           server.socket.close()
30
31    if __name__ == '__main__':
32       main()</pre></div></div><p>While the ActiveX control of WebEx is marked as safe for scripting (see <a class="xref" href="ch05.html#registered_webex_objects_in_comraider" title="Figure 5-1. Registered WebEx objects in COMRaider">Figure 5-1</a>), it has been designed so that it can be run only from the <a class="ulink" href="http://webex.com">webex.com</a> domain. In practice, this requirement can be bypassed with the help of a <span class="emphasis"><em>Cross-Site Scripting (XSS)</em></span><sup>[<a href="ch05s05.html#ftn.CHP-5-FN-4" class="footnoteref">48</a>]</sup> vulnerability in the WebEx domain. Since XSS vulnerabilities are quite common in modern web applications, it shouldn’t be hard to identify such a vulnerability in the <a class="ulink" href="http://webex.com">webex.com</a> domain. To test the control without the need of an XSS vulnerability, I just added the following entry to my Windows <code class="literal">hosts</code> file (see <span class="emphasis"><em>C:\WINDOWS\system32\drivers\etc\hosts\</em></span>):<a id="IDX-CHP-5-0009" class="indexterm"/><a id="IDX-CHP-5-0010" class="indexterm"/></p><a id="I_programlisting5_d1e5278"/><pre class="programlisting">127.0.0.1       localhost, <strong class="userinput"><code>www.webex.com</code></strong></pre><p>After that, I started my little Python web server and pointed Internet Explorer to <a class="ulink" href="http://www.webex.com/">http://www.webex.com/</a> (see <a class="xref" href="ch05.html#testing_webex_underscore_poc1.html_with" title="Figure 5-3. Testing webex_poc1.html with my little Python web server">Figure 5-3</a>).</p><div class="figure"><a id="testing_webex_underscore_poc1.html_with"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5294"/><img src="httpatomoreillycomsourcenostarchimages939285.png.jpg" alt="Testing webex_poc1.html with my little Python web server"/></div></div><p class="title">Figure 5-3. Testing <span class="emphasis"><em>webex_poc1.html</em></span> with my little Python web server</p></div></div><div class="sect2" title="Step 3: Find the Object Methods in the Binary"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_find_the_object_methods_in"/>Step 3: Find the Object Methods in the Binary</h2></div></div></div><p>So far I had collected the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There is a WebEx object with ClassID <code class="literal">{32E26FD9-F435-4A20-A561-35D4B987CFDC}</code>.</p></li><li class="listitem"><p>This object implements <code class="literal">IObjectSafety</code> and is therefore a promising target, since its methods can be called from within the browser.</p></li><li class="listitem"><p>The object exports a method called <code class="literal">NewObject()</code> that takes a user-controlled string value as input.</p></li></ul></div><p>To reverse engineer the exported <code class="literal">NewObject()</code> method, I had to find it in the binary <code class="literal">atucfobj.dll</code>. To achieve this, I used a technique similar to the one Cody Pierce describes in one of his great MindshaRE articles.<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-5" class="footnoteref">49</a>]</sup> The general idea is to extract the addresses of the invoked methods from the arguments of <code class="literal">OLEAUT32!DispCallFunc</code> while debugging the browser.<a id="IDX-CHP-5-0011" class="indexterm"/></p><p>If a method of an ActiveX control gets invoked, the <code class="literal">DispCallFunc()</code><sup>[<a href="ch05s05.html#ftn.CHP-5-FN-6" class="footnoteref">50</a>]</sup> function usually performs the actual call. This function is exported by <code class="literal">OLEAUT32.dll</code>. The address of the invoked method can be determined with the help of the first two parameters (called <code class="literal">pvInstance</code> and <code class="literal">oVft</code>) of <code class="literal">DispCallFunc()</code>.<a id="IDX-CHP-5-0012" class="indexterm"/></p><p>To find the address of the <code class="literal">NewObject()</code> method, I started Internet Explorer from within WinDbg<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-7" class="footnoteref">51</a>]</sup> (also see Section B.2 for a description of the debugger commands) and set the following breakpoint at <code class="literal">OLEAUT32!DispCallFunc</code> (see also <a class="xref" href="ch05.html#defining_a_breakpoint_at_oleaut32_exclam" title="Figure 5-4. Defining a breakpoint at OLEAUT32!DispCallFunc in Internet Explorer">Figure 5-4</a>):<a id="IDX-CHP-5-0013" class="indexterm"/><a id="IDX-CHP-5-0014" class="indexterm"/></p><a id="I_programlisting5_d1e5381"/><pre class="programlisting">0:000&gt; <strong class="userinput"><code>bp OLEAUT32!DispCallFunc "u poi(poi(poi(esp+4))+(poi(esp+8))) L1;gc"</code></strong></pre><p>The debugger command <code class="literal">bp OLEAUT32!DispCallFunc</code> defines a breakpoint at the beginning of <code class="literal">DispCallFunc()</code>. If the breakpoint is triggered, the first two parameters of the function are evaluated. The first function parameter is referenced using the command <code class="literal">poi(poi(esp+4))</code>, and the second parameter is referenced by <code class="literal">poi(esp+8)</code>. These values are added together, and their sum represents the address of the invoked method. Subsequently, the first line (<code class="literal">L1</code>) of the method’s disassembly is printed to the screen (<code class="literal">u poi(result of the computation)</code>), and the execution of the control is resumed (<code class="literal">gc</code>).</p><p>I then started Internet Explorer with the <code class="literal">g</code> (Go) command of WinDbg and navigated to <a class="ulink" href="http://www.webex.com/">http://www.webex.com/</a> again. As expected, the breakpoint triggered in WinDbg showed the memory address of the called <code class="literal">NewObject()</code> method in <code class="literal">atucfobj.dll</code>.</p><p>As illustrated in <a class="xref" href="ch05.html#windbg_showing_the_memory_address_of_the" title="Figure 5-5. WinDbg showing the memory address of the NewObject() method">Figure 5-5</a>, the memory address of the <code class="literal">NewObject()</code> method was <code class="literal">0x01d5767f</code> in this example. The <code class="literal">atucfobj.dll</code> itself was loaded at address <code class="literal">0x01d50000</code> (see <code class="literal">ModLoad: 01d50000 01d69000 C:\Program Files\WebEx\WebEx\824\atucfobj.dll</code> in <a class="xref" href="ch05.html#windbg_showing_the_memory_address_of_the" title="Figure 5-5. WinDbg showing the memory address of the NewObject() method">Figure 5-5</a>). So the offset of <code class="literal">NewObject()</code> in <code class="literal">atucfobj.dll</code> was <code class="literal">0x01d5767f - 0x01d50000 = 0x767F</code>.</p><div class="figure"><a id="defining_a_breakpoint_at_oleaut32_exclam"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5459"/><img src="httpatomoreillycomsourcenostarchimages939287.png.jpg" alt="Defining a breakpoint at OLEAUT32!DispCallFunc in Internet Explorer"/></div></div><p class="title">Figure 5-4. Defining a breakpoint at <code class="literal">OLEAUT32!DispCallFunc</code> in Internet Explorer</p></div><div class="figure"><a id="windbg_showing_the_memory_address_of_the"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5471"/><img src="httpatomoreillycomsourcenostarchimages939289.png.jpg" alt="WinDbg showing the memory address of the NewObject() method"/></div></div><p class="title">Figure 5-5. WinDbg showing the memory address of the <code class="literal">NewObject()</code> method</p></div></div><div class="sect2" title="Step 4: Find the User-Controlled Input Values"><div class="titlepage"><div><div><h2 class="title"><a id="step_4_colon_find_the_user-controlled_in"/>Step 4: Find the User-Controlled Input Values</h2></div></div></div><p>Next, I disassembled the binary <span class="emphasis"><em>C:\Program Files\WebEx\WebEx\824\atucfobj.dll</em></span> with IDA Pro.<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-8" class="footnoteref">52</a>]</sup> In IDA, the imagebase of <code class="literal">atucfobj.dll</code> was <code class="literal">0x10000000</code>. So <code class="literal">NewObject()</code> was located at address <code class="literal">0x1000767f</code> (imagebase + offset of <code class="literal">NewObject()</code>: <code class="literal">0x10000000 + 0x767F</code>) in the disassembly (see <a class="xref" href="ch05.html#disassembly_of_the_newobject_open_parent" title="Figure 5-6. Disassembly of the NewObject() method in IDA Pro">Figure 5-6</a>).<a id="IDX-CHP-5-0015" class="indexterm"/><a id="IDX-CHP-5-0016" class="indexterm"/></p><div class="figure"><a id="disassembly_of_the_newobject_open_parent"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5519"/><img src="httpatomoreillycomsourcenostarchimages939291.png.jpg" alt="Disassembly of the NewObject() method in IDA Pro"/></div></div><p class="title">Figure 5-6. Disassembly of the <code class="literal">NewObject()</code> method in IDA Pro</p></div><p>Before I started reading the assembly, I had to ensure what function argument holds the user-controlled string value provided through the VBScript in <a class="xref" href="ch05.html#html_file_to_call_the" title="Example 5-1. HTML file to call the NewObject() method (webex_poc1.html)">Example 5-1</a>. Since the argument is a string, I guessed that my value was being held in the second parameter, <code class="literal">lpWideCharStr</code>, shown in IDA. I wanted to be sure, however, so I defined a new breakpoint at the <code class="literal">NewObject()</code> method and had a look at the arguments in the debugger (see Section B.2 for a description of the following debugger commands).</p><p>As illustrated in <a class="xref" href="ch05.html#user-controlled_argument_of_newobject_op" title="Figure 5-7. User-controlled argument of NewObject() after defining a new breakpoint">Figure 5-7</a>, I defined the new breakpoint at the address of <code class="literal">NewObject()</code> (<code class="literal">0:009&gt; bp 01d5767f</code>), continued the execution of Internet Explorer (<code class="literal">0:009&gt; g</code>), and again navigated to the <a class="ulink" href="http://www.webex.com/">http://www.webex.com/</a> domain. When the breakpoint was triggered, I inspected the value of the second function argument of <code class="literal">NewObject()</code> (<code class="literal">0:000&gt; dd poi(esp+8)</code> and <code class="literal">0:000&gt; du poi(esp+8)</code>). As the debugger output shows, the user-controlled data (a wide-character string consisting of 12 As) was indeed passed to the function through the second argument.</p><p>Finally, I had all information I needed to start auditing the method for security bugs.</p><div class="figure"><a id="user-controlled_argument_of_newobject_op"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5567"/><img src="httpatomoreillycomsourcenostarchimages939293.png.jpg" alt="User-controlled argument of NewObject() after defining a new breakpoint"/></div></div><p class="title">Figure 5-7. User-controlled argument of <code class="literal">NewObject()</code> after defining a new breakpoint</p></div></div><div class="sect2" title="Step 5: Reverse Engineer the Object Methods"><div class="titlepage"><div><div><h2 class="title"><a id="step_5_colon_reverse_engineer_the_object"/>Step 5: Reverse Engineer the Object Methods</h2></div></div></div><p>To recap, I found an obvious vulnerability that happens while the ActiveX control processes the user-supplied string value that gets passed to <code class="literal">NewObject()</code>. <a class="xref" href="ch05.html#code_path_to_reach_the_vulnerable_functi" title="Figure 5-8. Code path to reach the vulnerable function (created in IDA Pro)">Figure 5-8</a> illustrates the code path to reach the vulnerable function.</p><div class="figure"><a id="code_path_to_reach_the_vulnerable_functi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5585"/><img src="httpatomoreillycomsourcenostarchimages939295.png.jpg" alt="Code path to reach the vulnerable function (created in IDA Pro)"/></div></div><p class="title">Figure 5-8. Code path to reach the vulnerable function (created in IDA Pro)</p></div><p>In <code class="literal">sub_1000767F</code> the user-provided wide-character string is converted to a character string using the <code class="literal">WideCharToMultiByte()</code> function. After that, <code class="literal">sub_10009642</code> is called, and the user-controlled character string is copied into another buffer. The code in <code class="literal">sub_10009642</code> allows a maximum of 256 user-controlled bytes to be copied into this new character buffer (pseudo C code: <code class="literal">strncpy (new_buffer, user_controlled_string, 256)</code>). The function <code class="literal">sub_10009826</code> is called, and it calls <code class="literal">sub_100096D0</code>, which then calls the vulnerable function <code class="literal">sub_1000B37D</code>.</p><div class="example"><a id="disassembly_of_the_vulnerable"/><p class="title">Example 5-3. Disassembly of the vulnerable function <code class="literal">sub_1000B37D</code> (created in IDA Pro)</p><div class="example-contents"><pre class="programlisting">[..]
.text:1000B37D ; int __cdecl sub_1000B37D(<strong class="userinput"><code>DWORD cbData</code></strong>,
 LPBYTE lpData, int, int, int)
.text:1000B37D sub_1000B37D proc near
.text:1000B37D
<strong class="userinput"><code>.text:1000B37D SubKey= byte ptr −10Ch</code></strong>
.text:1000B37D Type= dword ptr −8
.text:1000B37D hKey= dword ptr −4
.text:1000B37D cbData= dword ptr  8
.text:1000B37D lpData= dword ptr  0Ch
.text:1000B37D arg_8= dword ptr  10h
.text:1000B37D arg_C= dword ptr  14h
.text:1000B37D arg_10= dword ptr  18h
.text:1000B37D
.text:1000B37D push   ebp
.text:1000B37E mov    ebp, esp
.text:1000B380 sub    esp, 10Ch
.text:1000B386 push   edi
<strong class="userinput"><code>.text:1000B387 lea    eax, [ebp+SubKey] ; the address of SubKey is saved in eax</code></strong>
<strong class="userinput"><code>.text:1000B38D push   [ebp+cbData]      ; 4th parameter of sprintf(): cbData</code></strong>
.text:1000B390 xor    edi, edi
<strong class="userinput"><code>.text:1000B392 push   offset aAuthoring ; 3rd parameter of sprintf(): "Authoring"</code></strong>
<strong class="userinput"><code>.text:1000B397 push   offset aSoftwareWebexU ;</code></strong>
 <strong class="userinput"><code>2nd parameter of sprintf(): "SOFTWARE\\..</code></strong>
<strong class="userinput"><code>.text:1000B397                         ; ..Webex\\UCF\\Components\\%s\\%s\\Install"</code></strong>
<strong class="userinput"><code>.text:1000B39C push   eax              ; 1st parameter of</code></strong>
 <strong class="userinput"><code>sprintf(): address of SubKey</code></strong>
<strong class="userinput"><code>.text:1000B39D call   ds:sprintf       ; call to sprintf()</code></strong>
[..]
<strong class="userinput"><code>.data:10012228 ; char aSoftwareWebexU[]</code></strong>
<strong class="userinput"><code>.data:10012228 aSoftwareWebexU db 'SOFTWARE\Webex\UCF\Components\%s\%s\Install',0</code></strong>
[..]</pre></div></div><p>The first argument of <code class="literal">sub_1000B37D</code>, called <code class="literal">cbData</code>, holds a pointer to the user-controlled data stored in the new character buffer (see <code class="literal">new_buffer</code> in the description of <a class="xref" href="ch05.html#code_path_to_reach_the_vulnerable_functi" title="Figure 5-8. Code path to reach the vulnerable function (created in IDA Pro)">Figure 5-8</a>). As I said before, the user-controlled wide-character data is stored in this new buffer as a character string with a maximum length of 256 bytes. <a class="xref" href="ch05.html#disassembly_of_the_vulnerable" title="Example 5-3. Disassembly of the vulnerable function sub_1000B37D (created in IDA Pro)">Example 5-3</a> shows that the <code class="literal">sprintf()</code> function at address <code class="literal">.text:1000B39D</code> copies the user-controlled data pointed to by <code class="literal">cbData</code> into a stack buffer called <code class="literal">SubKey</code> (see <code class="literal">.text:1000B387</code> and <code class="literal">.text:1000B39C</code>).<a id="IDX-CHP-5-0017" class="indexterm"/></p><p>Next, I tried to retrieve the size of this <code class="literal">SubKey</code> stack buffer. I opened IDA Pro’s default stack frame displays by pressing <span class="keycap">ctrl-k</span>. As shown in <a class="xref" href="ch05.html#determining_the_size_of_the_subkey_stack" title="Figure 5-9. Determining the size of the SubKey stack buffer using IDA Pro’s default stack frame displays">Figure 5-9</a>, the stack buffer <code class="literal">SubKey</code> has a fixed size of 260 bytes. If the information from the disassembly shown in <a class="xref" href="ch05.html#disassembly_of_the_vulnerable" title="Example 5-3. Disassembly of the vulnerable function sub_1000B37D (created in IDA Pro)">Example 5-3</a> is combined with the information on the stack layout of the vulnerable function, the call to <code class="literal">sprintf()</code> can be expressed with the C code in <a class="xref" href="ch05.html#pseudo_c_code_of_the_vulnerable_call" title="Example 5-4. Pseudo C code of the vulnerable call to sprintf()">Example 5-4</a>.<a id="IDX-CHP-5-0018" class="indexterm"/></p><div class="figure"><a id="determining_the_size_of_the_subkey_stack"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5734"/><img src="httpatomoreillycomsourcenostarchimages939297.png.jpg" alt="Determining the size of the SubKey stack buffer using IDA Pro’s default stack frame displays"/></div></div><p class="title">Figure 5-9. Determining the size of the <code class="literal">SubKey</code> stack buffer using IDA Pro’s default stack frame displays</p></div><div class="example"><a id="pseudo_c_code_of_the_vulnerable_call"/><p class="title">Example 5-4. Pseudo C code of the vulnerable call to <code class="literal">sprintf()</code></p><div class="example-contents"><pre class="programlisting">[..]
int
sub_1000B37D(DWORD cbData, LPBYTE lpData, int val1, int val2, int val3)
{
  char SubKey[260];

  sprintf(&amp;SubKey, "SOFTWARE\\Webex\\UCF\\Components\\%s\\%s\\Install",
          "Authoring", cbData);
[..]</pre></div></div><p>The <code class="literal">sprintf()</code> library function copies the user-controlled data from <code class="literal">cbData</code> as well as the string “<code class="literal">Authoring</code>” (9 bytes) and the format string (39 bytes) into <code class="literal">SubKey</code>. If <code class="literal">cbData</code> is filled with the maximum amount of user-controlled data (256 bytes), a total of 304 bytes of data will be copied into the stack buffer. <code class="literal">SubKey</code> can only hold up to 260 bytes, and <code class="literal">sprintf()</code> doesn’t perform any length check. Therefore, as shown in <a class="xref" href="ch05.html#diagram_of_the_stack_buffer_overflow_tha" title="Figure 5-10. Diagram of the stack buffer overflow that occurs when an overly long string is passed to NewObject()">Figure 5-10</a>, it’s possible to write user-controlled data out of the bounds of <code class="literal">SubKey</code>, which leads to a stack buffer overflow (see Section A.1).</p><div class="figure"><a id="diagram_of_the_stack_buffer_overflow_tha"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5780"/><img src="httpatomoreillycomsourcenostarchimages939299.png.jpg" alt="Diagram of the stack buffer overflow that occurs when an overly long string is passed to NewObject()"/></div></div><p class="title">Figure 5-10. Diagram of the stack buffer overflow that occurs when an overly long string is passed to <code class="literal">NewObject()</code></p></div></div></div></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 5. Browse and You’re Owned</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="chapter" title="Chapter 5. Browse and You’re Owned"><div class="titlepage"><div><div><h1 class="title"><a id="browse_and_youare_owned"/>Chapter 5. Browse and You’re Owned</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Sunday, April 6, 2008</em></span><a id="IDX-CHP-5-0001" class="indexterm"/></p><p><span class="emphasis"><em>Dear Diary</em></span>,</p></div><p>Vulnerabilities in browsers and browser add-ons are all the rage these days, so I decided to have a look at some ActiveX controls. The first one on my list was Cisco’s online meeting and web-conferencing software called WebEx, which is widely used in business. After spending some time reverse engineering the WebEx ActiveX control for Microsoft’s Internet Explorer, I found an obvious bug that I could have found in a few seconds if I had fuzzed the control instead of reading the assembly. Fail. <span class="inlinemediaobject"><a id="I_inlinemediaobject5_d1e5037"/><img src="httpatomoreillycomsourcenostarchimages939227.png" alt=""/></span><a id="IDX-CHP-5-0002" class="indexterm"/><a id="IDX-CHP-5-0003" class="indexterm"/><a id="IDX-CHP-5-0004" class="indexterm"/></p><div class="sect1" title="5.1 Vulnerability Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_discovery-id3"/>5.1 Vulnerability Discovery</h1></div></div></div><p>I used the following process to search for a vulnerability:</p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>I used Windows XP SP3 32-bit and Internet Explorer 6 as the platform for all the following steps</em></span>.<a id="IDX-CHP-5-0005" class="indexterm"/></p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: List the registered WebEx objects and exported methods.</p></li><li class="listitem"><p>Step 2: Test the exported methods in the browser.</p></li><li class="listitem"><p>Step 3: Find the object methods in the binary.</p></li><li class="listitem"><p>Step 4: Find the user-controlled input values.</p></li><li class="listitem"><p>Step 5: Reverse engineer the object methods.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>A download link for the vulnerable version of WebEx Meeting Manager can be found at <a class="ulink" href="http://www.trapkit.de/books/bhd/">http://www.trapkit.de/books/bhd/</a>.</p></div><div class="sect2" title="Step 1: List the Registered WebEx Objects and Exported Methods"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_list_the_registered_webex_o"/>Step 1: List the Registered WebEx Objects and Exported Methods</h2></div></div></div><p>After downloading and installing the WebEx Meeting Manager software, I fired up COMRaider<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-1" class="footnoteref">45</a>]</sup> to generate a list of the exported interfaces the control provides to the caller. I clicked the <span class="strong"><strong>Start</strong></span> button in COMRaider and selected <span class="strong"><strong>Scan a directory for registered COM servers</strong></span> to test the WebEx components installed in <span class="emphasis"><em>C:\Program Files\Webex\</em></span>.<a id="IDX-CHP-5-0006" class="indexterm"/></p><p>As <a class="xref" href="ch05.html#registered_webex_objects_in_comraider" title="Figure 5-1. Registered WebEx objects in COMRaider">Figure 5-1</a> illustrates, two objects are registered in the WebEx install directory, and the object with GUID <code class="literal">{32E26FD9-F435-4A20-A561-35D4B987CFDC}</code> and ProgID <code class="literal">WebexUCFObject.WebexUCFObject.1</code> implements <code class="literal">IObjectSafety</code>. Internet Explorer will trust this object since it’s marked as <span class="emphasis"><em>safe for initialization</em></span> and <span class="emphasis"><em>safe for scripting</em></span>. That makes the object a promising target for “browse and you’re owned” attacks, since it’s possible to call its methods from within a web page.<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-2" class="footnoteref">46</a>]</sup></p><div class="figure"><a id="registered_webex_objects_in_comraider"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5128"/><img src="httpatomoreillycomsourcenostarchimages939281.png.jpg" alt="Registered WebEx objects in COMRaider"/></div></div><p class="title">Figure 5-1. Registered WebEx objects in COMRaider</p></div><p>Microsoft also provides a handy C# class called <code class="literal">ClassId.cs</code><sup>[<a href="ch05s05.html#ftn.CHP-5-FN-3" class="footnoteref">47</a>]</sup> that lists various properties of ActiveX controls. To use that class, I added the following lines to the source file and compiled it with the command-line version of Visual Studio’s C# compiler (<code class="literal">csc</code>):</p><a id="I_programlisting5_d1e5142"/><pre class="programlisting">[..]
namespace ClassId
{
    class ClassId
    {
        static void Main(string[] args)
        {
            SWI.ClassId_q.ClassId clsid = new SWI.ClassId_q.ClassId();

            if (args.Length == 0 || (args[0].Equals("/?") == true ||
                args[0].ToLower().StartsWith("-h") == true) ||
                args.Length &lt; 1)
            {
                Console.WriteLine("Usage: ClassID.exe &lt;CLSID&gt;\n");
                return;
            }

            clsid.set_clsid(args[0]);
            System.Console.WriteLine(clsid.ToString());
        }
    }
}</pre><p>To compile and use the tool, I ran the following commands in a command-prompt window:</p><a id="I_programlisting5_d1e5146"/><pre class="programlisting">C:\Documents and Settings\tk\Desktop&gt;<strong class="userinput"><code>csc /warn:0 /nologo ClassId.cs</code></strong>
C:\Documents and Settings\tk\Desktop&gt;
<strong class="userinput"><code>ClassId.exe {32E26FD9-F435-4A20-A561-35D4B987CFDC}</code></strong>
Clsid: {32E26FD9-F435-4A20-A561-35D4B987CFDC}
Progid: WebexUCFObject.WebexUCFObject.1
Binary Path: C:\Program Files\WebEx\WebEx\824\atucfobj.dll
<strong class="userinput"><code>Implements IObjectSafety: True</code></strong>
<strong class="userinput"><code>Safe For Initialization (IObjectSafety): True</code></strong>
<strong class="userinput"><code>Safe For Scripting (IObjectSafety): True</code></strong>
Safe For Initialization (Registry): False
Safe For Scripting (Registry): False
KillBitted: False</pre><p>The output of the tool shows that the object was indeed marked as <span class="emphasis"><em>safe for initialization</em></span> and <span class="emphasis"><em>safe for scripting</em></span> using <code class="literal">IObjectSafety</code>.</p><p>I then clicked the <span class="strong"><strong>Select</strong></span> button in COMRaider to see a list of the public methods exported by the object with GUID <code class="literal">{32E26FD9-F435-4A20-A561-35D4B987CFDC}</code>. As illustrated in <a class="xref" href="ch05.html#public_methods_exported_by_the_object_wi" title="Figure 5-2. Public methods exported by the object with GUID {32E26FD9-F435-4A20-A561-35D4B987CFDC}.">Figure 5-2</a>, a method called <code class="literal">NewObject()</code> is exported by the object and takes a string value as input.</p><div class="figure"><a id="public_methods_exported_by_the_object_wi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5193"/><img src="httpatomoreillycomsourcenostarchimages939283.png.jpg" alt="Public methods exported by the object with GUID {32E26FD9-F435-4A20-A561-35D4B987CFDC}."/></div></div><p class="title">Figure 5-2. Public methods exported by the object with GUID <code class="literal">{32E26FD9-F435-4A20-A561-35D4B987CFDC}</code>.</p></div></div><div class="sect2" title="Step 2: Test the Exported Methods in the Browser"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_test_the_exported_methods_i"/>Step 2: Test the Exported Methods in the Browser</h2></div></div></div><p>After I generated lists of the available objects and exported methods, I wrote a little HTML file that calls the <code class="literal">NewObject()</code> method with the help of VBScript:<a id="IDX-CHP-5-0007" class="indexterm"/></p><div class="example"><a id="html_file_to_call_the"/><p class="title">Example 5-1. HTML file to call the <code class="literal">NewObject()</code> method (<span class="emphasis"><em>webex_poc1.html</em></span>)</p><div class="example-contents"><pre class="programlisting">01    &lt;html&gt;
02     &lt;title&gt;WebEx PoC 1&lt;/title&gt;
03     &lt;body&gt;
04      &lt;object classid="clsid:32E26FD9-F435-4A20-A561-
35D4B987CFDC" id="obj"&gt;&lt;/object&gt;
05      &lt;script language='vbscript'&gt;
06        arg = String(12, "A")
07        obj.NewObject arg
08      &lt;/script&gt;
09     &lt;/body&gt;
10    &lt;/html&gt;</pre></div></div><p>In line 4 of <a class="xref" href="ch05.html#html_file_to_call_the" title="Example 5-1. HTML file to call the NewObject() method (webex_poc1.html)">Example 5-1</a>, the object with GUID or ClassID <code class="literal">{32E26FD9-F435-4A20-A561-35D4B987CFDC}</code> is instantiated. In line 7 the <code class="literal">NewObject()</code> method is called with a string value of 12 As as a parameter.</p><p>To test the HTML file, I implemented a little web server in Python that would serve the <span class="emphasis"><em>webex_poc1.html</em></span> file to the browser (see <a class="xref" href="ch05.html#simple_web_server_implemented" title="Example 5-2. Simple web server implemented in Python that serves the webex_poc1.html file to the browser (wwwserv.py)">Example 5-2</a>):<a id="IDX-CHP-5-0008" class="indexterm"/></p><div class="example"><a id="simple_web_server_implemented"/><p class="title">Example 5-2. Simple web server implemented in Python that serves the <span class="emphasis"><em>webex_poc1.html</em></span> file to the browser (<span class="emphasis"><em>wwwserv.py</em></span>)</p><div class="example-contents"><pre class="programlisting">01    import string,cgi
02    from os import curdir, sep
03    from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
04
05    class WWWHandler(BaseHTTPRequestHandler):
06
07       def do_GET(self):
08           try:
09               f = open(curdir + sep + "webex_poc1.html")
10
11               self.send_response(200)
12               self.send_header('Content-type', 'text/html')
13               self.end_headers()
14               self.wfile.write(f.read())
15               f.close()
16
17               return
18
19           except IOError:
20               self.send_error(404,'File Not Found: %s' % self.path)
21
22    def main():
23       try:
24           server = HTTPServer(('', 80), WWWHandler)
25           print 'server started'
26           server.serve_forever()
27       except KeyboardInterrupt:
28           print 'shutting down server'
29           server.socket.close()
30
31    if __name__ == '__main__':
32       main()</pre></div></div><p>While the ActiveX control of WebEx is marked as safe for scripting (see <a class="xref" href="ch05.html#registered_webex_objects_in_comraider" title="Figure 5-1. Registered WebEx objects in COMRaider">Figure 5-1</a>), it has been designed so that it can be run only from the <a class="ulink" href="http://webex.com">webex.com</a> domain. In practice, this requirement can be bypassed with the help of a <span class="emphasis"><em>Cross-Site Scripting (XSS)</em></span><sup>[<a href="ch05s05.html#ftn.CHP-5-FN-4" class="footnoteref">48</a>]</sup> vulnerability in the WebEx domain. Since XSS vulnerabilities are quite common in modern web applications, it shouldn’t be hard to identify such a vulnerability in the <a class="ulink" href="http://webex.com">webex.com</a> domain. To test the control without the need of an XSS vulnerability, I just added the following entry to my Windows <code class="literal">hosts</code> file (see <span class="emphasis"><em>C:\WINDOWS\system32\drivers\etc\hosts\</em></span>):<a id="IDX-CHP-5-0009" class="indexterm"/><a id="IDX-CHP-5-0010" class="indexterm"/></p><a id="I_programlisting5_d1e5278"/><pre class="programlisting">127.0.0.1       localhost, <strong class="userinput"><code>www.webex.com</code></strong></pre><p>After that, I started my little Python web server and pointed Internet Explorer to <a class="ulink" href="http://www.webex.com/">http://www.webex.com/</a> (see <a class="xref" href="ch05.html#testing_webex_underscore_poc1.html_with" title="Figure 5-3. Testing webex_poc1.html with my little Python web server">Figure 5-3</a>).</p><div class="figure"><a id="testing_webex_underscore_poc1.html_with"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5294"/><img src="httpatomoreillycomsourcenostarchimages939285.png.jpg" alt="Testing webex_poc1.html with my little Python web server"/></div></div><p class="title">Figure 5-3. Testing <span class="emphasis"><em>webex_poc1.html</em></span> with my little Python web server</p></div></div><div class="sect2" title="Step 3: Find the Object Methods in the Binary"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_find_the_object_methods_in"/>Step 3: Find the Object Methods in the Binary</h2></div></div></div><p>So far I had collected the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There is a WebEx object with ClassID <code class="literal">{32E26FD9-F435-4A20-A561-35D4B987CFDC}</code>.</p></li><li class="listitem"><p>This object implements <code class="literal">IObjectSafety</code> and is therefore a promising target, since its methods can be called from within the browser.</p></li><li class="listitem"><p>The object exports a method called <code class="literal">NewObject()</code> that takes a user-controlled string value as input.</p></li></ul></div><p>To reverse engineer the exported <code class="literal">NewObject()</code> method, I had to find it in the binary <code class="literal">atucfobj.dll</code>. To achieve this, I used a technique similar to the one Cody Pierce describes in one of his great MindshaRE articles.<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-5" class="footnoteref">49</a>]</sup> The general idea is to extract the addresses of the invoked methods from the arguments of <code class="literal">OLEAUT32!DispCallFunc</code> while debugging the browser.<a id="IDX-CHP-5-0011" class="indexterm"/></p><p>If a method of an ActiveX control gets invoked, the <code class="literal">DispCallFunc()</code><sup>[<a href="ch05s05.html#ftn.CHP-5-FN-6" class="footnoteref">50</a>]</sup> function usually performs the actual call. This function is exported by <code class="literal">OLEAUT32.dll</code>. The address of the invoked method can be determined with the help of the first two parameters (called <code class="literal">pvInstance</code> and <code class="literal">oVft</code>) of <code class="literal">DispCallFunc()</code>.<a id="IDX-CHP-5-0012" class="indexterm"/></p><p>To find the address of the <code class="literal">NewObject()</code> method, I started Internet Explorer from within WinDbg<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-7" class="footnoteref">51</a>]</sup> (also see Section B.2 for a description of the debugger commands) and set the following breakpoint at <code class="literal">OLEAUT32!DispCallFunc</code> (see also <a class="xref" href="ch05.html#defining_a_breakpoint_at_oleaut32_exclam" title="Figure 5-4. Defining a breakpoint at OLEAUT32!DispCallFunc in Internet Explorer">Figure 5-4</a>):<a id="IDX-CHP-5-0013" class="indexterm"/><a id="IDX-CHP-5-0014" class="indexterm"/></p><a id="I_programlisting5_d1e5381"/><pre class="programlisting">0:000&gt; <strong class="userinput"><code>bp OLEAUT32!DispCallFunc "u poi(poi(poi(esp+4))+(poi(esp+8))) L1;gc"</code></strong></pre><p>The debugger command <code class="literal">bp OLEAUT32!DispCallFunc</code> defines a breakpoint at the beginning of <code class="literal">DispCallFunc()</code>. If the breakpoint is triggered, the first two parameters of the function are evaluated. The first function parameter is referenced using the command <code class="literal">poi(poi(esp+4))</code>, and the second parameter is referenced by <code class="literal">poi(esp+8)</code>. These values are added together, and their sum represents the address of the invoked method. Subsequently, the first line (<code class="literal">L1</code>) of the method’s disassembly is printed to the screen (<code class="literal">u poi(result of the computation)</code>), and the execution of the control is resumed (<code class="literal">gc</code>).</p><p>I then started Internet Explorer with the <code class="literal">g</code> (Go) command of WinDbg and navigated to <a class="ulink" href="http://www.webex.com/">http://www.webex.com/</a> again. As expected, the breakpoint triggered in WinDbg showed the memory address of the called <code class="literal">NewObject()</code> method in <code class="literal">atucfobj.dll</code>.</p><p>As illustrated in <a class="xref" href="ch05.html#windbg_showing_the_memory_address_of_the" title="Figure 5-5. WinDbg showing the memory address of the NewObject() method">Figure 5-5</a>, the memory address of the <code class="literal">NewObject()</code> method was <code class="literal">0x01d5767f</code> in this example. The <code class="literal">atucfobj.dll</code> itself was loaded at address <code class="literal">0x01d50000</code> (see <code class="literal">ModLoad: 01d50000 01d69000 C:\Program Files\WebEx\WebEx\824\atucfobj.dll</code> in <a class="xref" href="ch05.html#windbg_showing_the_memory_address_of_the" title="Figure 5-5. WinDbg showing the memory address of the NewObject() method">Figure 5-5</a>). So the offset of <code class="literal">NewObject()</code> in <code class="literal">atucfobj.dll</code> was <code class="literal">0x01d5767f - 0x01d50000 = 0x767F</code>.</p><div class="figure"><a id="defining_a_breakpoint_at_oleaut32_exclam"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5459"/><img src="httpatomoreillycomsourcenostarchimages939287.png.jpg" alt="Defining a breakpoint at OLEAUT32!DispCallFunc in Internet Explorer"/></div></div><p class="title">Figure 5-4. Defining a breakpoint at <code class="literal">OLEAUT32!DispCallFunc</code> in Internet Explorer</p></div><div class="figure"><a id="windbg_showing_the_memory_address_of_the"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5471"/><img src="httpatomoreillycomsourcenostarchimages939289.png.jpg" alt="WinDbg showing the memory address of the NewObject() method"/></div></div><p class="title">Figure 5-5. WinDbg showing the memory address of the <code class="literal">NewObject()</code> method</p></div></div><div class="sect2" title="Step 4: Find the User-Controlled Input Values"><div class="titlepage"><div><div><h2 class="title"><a id="step_4_colon_find_the_user-controlled_in"/>Step 4: Find the User-Controlled Input Values</h2></div></div></div><p>Next, I disassembled the binary <span class="emphasis"><em>C:\Program Files\WebEx\WebEx\824\atucfobj.dll</em></span> with IDA Pro.<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-8" class="footnoteref">52</a>]</sup> In IDA, the imagebase of <code class="literal">atucfobj.dll</code> was <code class="literal">0x10000000</code>. So <code class="literal">NewObject()</code> was located at address <code class="literal">0x1000767f</code> (imagebase + offset of <code class="literal">NewObject()</code>: <code class="literal">0x10000000 + 0x767F</code>) in the disassembly (see <a class="xref" href="ch05.html#disassembly_of_the_newobject_open_parent" title="Figure 5-6. Disassembly of the NewObject() method in IDA Pro">Figure 5-6</a>).<a id="IDX-CHP-5-0015" class="indexterm"/><a id="IDX-CHP-5-0016" class="indexterm"/></p><div class="figure"><a id="disassembly_of_the_newobject_open_parent"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5519"/><img src="httpatomoreillycomsourcenostarchimages939291.png.jpg" alt="Disassembly of the NewObject() method in IDA Pro"/></div></div><p class="title">Figure 5-6. Disassembly of the <code class="literal">NewObject()</code> method in IDA Pro</p></div><p>Before I started reading the assembly, I had to ensure what function argument holds the user-controlled string value provided through the VBScript in <a class="xref" href="ch05.html#html_file_to_call_the" title="Example 5-1. HTML file to call the NewObject() method (webex_poc1.html)">Example 5-1</a>. Since the argument is a string, I guessed that my value was being held in the second parameter, <code class="literal">lpWideCharStr</code>, shown in IDA. I wanted to be sure, however, so I defined a new breakpoint at the <code class="literal">NewObject()</code> method and had a look at the arguments in the debugger (see Section B.2 for a description of the following debugger commands).</p><p>As illustrated in <a class="xref" href="ch05.html#user-controlled_argument_of_newobject_op" title="Figure 5-7. User-controlled argument of NewObject() after defining a new breakpoint">Figure 5-7</a>, I defined the new breakpoint at the address of <code class="literal">NewObject()</code> (<code class="literal">0:009&gt; bp 01d5767f</code>), continued the execution of Internet Explorer (<code class="literal">0:009&gt; g</code>), and again navigated to the <a class="ulink" href="http://www.webex.com/">http://www.webex.com/</a> domain. When the breakpoint was triggered, I inspected the value of the second function argument of <code class="literal">NewObject()</code> (<code class="literal">0:000&gt; dd poi(esp+8)</code> and <code class="literal">0:000&gt; du poi(esp+8)</code>). As the debugger output shows, the user-controlled data (a wide-character string consisting of 12 As) was indeed passed to the function through the second argument.</p><p>Finally, I had all information I needed to start auditing the method for security bugs.</p><div class="figure"><a id="user-controlled_argument_of_newobject_op"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5567"/><img src="httpatomoreillycomsourcenostarchimages939293.png.jpg" alt="User-controlled argument of NewObject() after defining a new breakpoint"/></div></div><p class="title">Figure 5-7. User-controlled argument of <code class="literal">NewObject()</code> after defining a new breakpoint</p></div></div><div class="sect2" title="Step 5: Reverse Engineer the Object Methods"><div class="titlepage"><div><div><h2 class="title"><a id="step_5_colon_reverse_engineer_the_object"/>Step 5: Reverse Engineer the Object Methods</h2></div></div></div><p>To recap, I found an obvious vulnerability that happens while the ActiveX control processes the user-supplied string value that gets passed to <code class="literal">NewObject()</code>. <a class="xref" href="ch05.html#code_path_to_reach_the_vulnerable_functi" title="Figure 5-8. Code path to reach the vulnerable function (created in IDA Pro)">Figure 5-8</a> illustrates the code path to reach the vulnerable function.</p><div class="figure"><a id="code_path_to_reach_the_vulnerable_functi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5585"/><img src="httpatomoreillycomsourcenostarchimages939295.png.jpg" alt="Code path to reach the vulnerable function (created in IDA Pro)"/></div></div><p class="title">Figure 5-8. Code path to reach the vulnerable function (created in IDA Pro)</p></div><p>In <code class="literal">sub_1000767F</code> the user-provided wide-character string is converted to a character string using the <code class="literal">WideCharToMultiByte()</code> function. After that, <code class="literal">sub_10009642</code> is called, and the user-controlled character string is copied into another buffer. The code in <code class="literal">sub_10009642</code> allows a maximum of 256 user-controlled bytes to be copied into this new character buffer (pseudo C code: <code class="literal">strncpy (new_buffer, user_controlled_string, 256)</code>). The function <code class="literal">sub_10009826</code> is called, and it calls <code class="literal">sub_100096D0</code>, which then calls the vulnerable function <code class="literal">sub_1000B37D</code>.</p><div class="example"><a id="disassembly_of_the_vulnerable"/><p class="title">Example 5-3. Disassembly of the vulnerable function <code class="literal">sub_1000B37D</code> (created in IDA Pro)</p><div class="example-contents"><pre class="programlisting">[..]
.text:1000B37D ; int __cdecl sub_1000B37D(<strong class="userinput"><code>DWORD cbData</code></strong>,
 LPBYTE lpData, int, int, int)
.text:1000B37D sub_1000B37D proc near
.text:1000B37D
<strong class="userinput"><code>.text:1000B37D SubKey= byte ptr −10Ch</code></strong>
.text:1000B37D Type= dword ptr −8
.text:1000B37D hKey= dword ptr −4
.text:1000B37D cbData= dword ptr  8
.text:1000B37D lpData= dword ptr  0Ch
.text:1000B37D arg_8= dword ptr  10h
.text:1000B37D arg_C= dword ptr  14h
.text:1000B37D arg_10= dword ptr  18h
.text:1000B37D
.text:1000B37D push   ebp
.text:1000B37E mov    ebp, esp
.text:1000B380 sub    esp, 10Ch
.text:1000B386 push   edi
<strong class="userinput"><code>.text:1000B387 lea    eax, [ebp+SubKey] ; the address of SubKey is saved in eax</code></strong>
<strong class="userinput"><code>.text:1000B38D push   [ebp+cbData]      ; 4th parameter of sprintf(): cbData</code></strong>
.text:1000B390 xor    edi, edi
<strong class="userinput"><code>.text:1000B392 push   offset aAuthoring ; 3rd parameter of sprintf(): "Authoring"</code></strong>
<strong class="userinput"><code>.text:1000B397 push   offset aSoftwareWebexU ;</code></strong>
 <strong class="userinput"><code>2nd parameter of sprintf(): "SOFTWARE\\..</code></strong>
<strong class="userinput"><code>.text:1000B397                         ; ..Webex\\UCF\\Components\\%s\\%s\\Install"</code></strong>
<strong class="userinput"><code>.text:1000B39C push   eax              ; 1st parameter of</code></strong>
 <strong class="userinput"><code>sprintf(): address of SubKey</code></strong>
<strong class="userinput"><code>.text:1000B39D call   ds:sprintf       ; call to sprintf()</code></strong>
[..]
<strong class="userinput"><code>.data:10012228 ; char aSoftwareWebexU[]</code></strong>
<strong class="userinput"><code>.data:10012228 aSoftwareWebexU db 'SOFTWARE\Webex\UCF\Components\%s\%s\Install',0</code></strong>
[..]</pre></div></div><p>The first argument of <code class="literal">sub_1000B37D</code>, called <code class="literal">cbData</code>, holds a pointer to the user-controlled data stored in the new character buffer (see <code class="literal">new_buffer</code> in the description of <a class="xref" href="ch05.html#code_path_to_reach_the_vulnerable_functi" title="Figure 5-8. Code path to reach the vulnerable function (created in IDA Pro)">Figure 5-8</a>). As I said before, the user-controlled wide-character data is stored in this new buffer as a character string with a maximum length of 256 bytes. <a class="xref" href="ch05.html#disassembly_of_the_vulnerable" title="Example 5-3. Disassembly of the vulnerable function sub_1000B37D (created in IDA Pro)">Example 5-3</a> shows that the <code class="literal">sprintf()</code> function at address <code class="literal">.text:1000B39D</code> copies the user-controlled data pointed to by <code class="literal">cbData</code> into a stack buffer called <code class="literal">SubKey</code> (see <code class="literal">.text:1000B387</code> and <code class="literal">.text:1000B39C</code>).<a id="IDX-CHP-5-0017" class="indexterm"/></p><p>Next, I tried to retrieve the size of this <code class="literal">SubKey</code> stack buffer. I opened IDA Pro’s default stack frame displays by pressing <span class="keycap">ctrl-k</span>. As shown in <a class="xref" href="ch05.html#determining_the_size_of_the_subkey_stack" title="Figure 5-9. Determining the size of the SubKey stack buffer using IDA Pro’s default stack frame displays">Figure 5-9</a>, the stack buffer <code class="literal">SubKey</code> has a fixed size of 260 bytes. If the information from the disassembly shown in <a class="xref" href="ch05.html#disassembly_of_the_vulnerable" title="Example 5-3. Disassembly of the vulnerable function sub_1000B37D (created in IDA Pro)">Example 5-3</a> is combined with the information on the stack layout of the vulnerable function, the call to <code class="literal">sprintf()</code> can be expressed with the C code in <a class="xref" href="ch05.html#pseudo_c_code_of_the_vulnerable_call" title="Example 5-4. Pseudo C code of the vulnerable call to sprintf()">Example 5-4</a>.<a id="IDX-CHP-5-0018" class="indexterm"/></p><div class="figure"><a id="determining_the_size_of_the_subkey_stack"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5734"/><img src="httpatomoreillycomsourcenostarchimages939297.png.jpg" alt="Determining the size of the SubKey stack buffer using IDA Pro’s default stack frame displays"/></div></div><p class="title">Figure 5-9. Determining the size of the <code class="literal">SubKey</code> stack buffer using IDA Pro’s default stack frame displays</p></div><div class="example"><a id="pseudo_c_code_of_the_vulnerable_call"/><p class="title">Example 5-4. Pseudo C code of the vulnerable call to <code class="literal">sprintf()</code></p><div class="example-contents"><pre class="programlisting">[..]
int
sub_1000B37D(DWORD cbData, LPBYTE lpData, int val1, int val2, int val3)
{
  char SubKey[260];

  sprintf(&amp;SubKey, "SOFTWARE\\Webex\\UCF\\Components\\%s\\%s\\Install",
          "Authoring", cbData);
[..]</pre></div></div><p>The <code class="literal">sprintf()</code> library function copies the user-controlled data from <code class="literal">cbData</code> as well as the string “<code class="literal">Authoring</code>” (9 bytes) and the format string (39 bytes) into <code class="literal">SubKey</code>. If <code class="literal">cbData</code> is filled with the maximum amount of user-controlled data (256 bytes), a total of 304 bytes of data will be copied into the stack buffer. <code class="literal">SubKey</code> can only hold up to 260 bytes, and <code class="literal">sprintf()</code> doesn’t perform any length check. Therefore, as shown in <a class="xref" href="ch05.html#diagram_of_the_stack_buffer_overflow_tha" title="Figure 5-10. Diagram of the stack buffer overflow that occurs when an overly long string is passed to NewObject()">Figure 5-10</a>, it’s possible to write user-controlled data out of the bounds of <code class="literal">SubKey</code>, which leads to a stack buffer overflow (see Section A.1).</p><div class="figure"><a id="diagram_of_the_stack_buffer_overflow_tha"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5780"/><img src="httpatomoreillycomsourcenostarchimages939299.png.jpg" alt="Diagram of the stack buffer overflow that occurs when an overly long string is passed to NewObject()"/></div></div><p class="title">Figure 5-10. Diagram of the stack buffer overflow that occurs when an overly long string is passed to <code class="literal">NewObject()</code></p></div></div></div></div></body></html>
