<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 6. One Kernel to Rule Them All</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="chapter" title="Chapter 6. One Kernel to Rule Them All"><div class="titlepage"><div><div><h1 class="title"><a id="one_kernel_to_rule_them_all"/>Chapter 6. One Kernel to Rule Them All</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Saturday, March 8, 2008</em></span><a id="IDX-CHP-6-0001" class="indexterm"/><a id="IDX-CHP-6-0002" class="indexterm"/></p><p><span class="emphasis"><em>Dear Diary</em></span>,</p></div><p>After spending time auditing open source kernels and finding some interesting bugs, I wondered whether I could find a bug in a Microsoft Windows driver. There are lots of third-party drivers available for Windows, so choosing just a few to explore wasn’t easy. I finally chose some antivirus products, since they’re usually promising targets for bug hunting.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-1" class="footnoteref">57</a>]</sup> I visited VirusTotal<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-2" class="footnoteref">58</a>]</sup> and chose the first antivirus product that I recognized on its list: avast! from ALWIL Software.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-3" class="footnoteref">59</a>]</sup> That turned out to be a serendipitous decision.<a id="IDX-CHP-6-0003" class="indexterm"/><a id="IDX-CHP-6-0004" class="indexterm"/><a id="IDX-CHP-6-0005" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>On June 1, 2010, ALWIL Software was renamed AVAST Software</em></span>.</p></div><div class="sect1" title="6.1 Vulnerability Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_discovery-id4"/>6.1 Vulnerability Discovery</h1></div></div></div><p>I used the following steps to find the vulnerability:<a id="IDX-CHP-6-0006" class="indexterm"/><a id="IDX-CHP-6-0007" class="indexterm"/><a id="IDX-CHP-6-0008" class="indexterm"/><a id="IDX-CHP-6-0009" class="indexterm"/><a id="IDX-CHP-6-0010" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>The vulnerability described in this chapter affects all Microsoft Windows platforms supported by avast! Professional 4.7. The platform that I used throughout this chapter was the default installation of Windows XP SP3 32-bit</em></span>.<a id="IDX-CHP-6-0011" class="indexterm"/></p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: Prepare a VMware guest for kernel debugging.<a id="IDX-CHP-6-0012" class="indexterm"/><a id="IDX-CHP-6-0013" class="indexterm"/></p></li><li class="listitem"><p>Step 2: Generate a list of the drivers and device objects created by avast!</p></li><li class="listitem"><p>Step 3: Check the device security settings.</p></li><li class="listitem"><p>Step 4: List the IOCTLs.</p></li><li class="listitem"><p>Step 5: Find the user-controlled input values.</p></li><li class="listitem"><p>Step 6: Reverse engineer the IOCTL handler.</p></li></ul></div><div class="sect2" title="Step 1: Prepare a VMware Guest for Kernel Debugging"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_prepare_a_vmware_guest_for"/>Step 1: Prepare a VMware Guest for Kernel Debugging</h2></div></div></div><p>First, I set up a Windows XP VMware<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-4" class="footnoteref">60</a>]</sup> guest system that I configured for remote kernel debugging with WinDbg.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-5" class="footnoteref">61</a>]</sup> The necessary steps are described in Section B.3.</p></div><div class="sect2" title="Step 2: Generate a List of the Drivers and Device Objects Created by avast!"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_generate_a_list_of_the_driv"/>Step 2: Generate a List of the Drivers and Device Objects Created by avast!</h2></div></div></div><p>After downloading and installing the latest version of avast! Professional<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-6" class="footnoteref">62</a>]</sup> in the VMware guest system, I used DriverView<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-7" class="footnoteref">63</a>]</sup> to generate a list of the drivers that avast! loaded.<a id="IDX-CHP-6-0014" class="indexterm"/></p><p>One of the benefits of DriverView is that it makes identification of third-party drivers easy. As illustrated in <a class="xref" href="ch06.html#a_list_of_the_avast_exclamation_drivers" title="Figure 6-1. A list of the avast! drivers in DriverView">Figure 6-1</a>, avast! loaded four drivers. I chose the first one on the list, called <span class="emphasis"><em>Aavmker4.sys</em></span>, and used IDA Pro<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-8" class="footnoteref">64</a>]</sup> to generate a list of the device objects of that driver.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>A driver can create device objects to represent devices, or an interface to the driver, at any time by calling <em class="replaceable"><code>IoCreateDevice</code></em> or <em class="replaceable"><code>IoCreateDeviceSecure</code></em>.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-9" class="footnoteref">65</a>]</sup></p></div><div class="figure"><a id="a_list_of_the_avast_exclamation_drivers"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e6215"/><img src="httpatomoreillycomsourcenostarchimages939305.png.jpg" alt="A list of the avast! drivers in DriverView"/></div></div><p class="title">Figure 6-1. A list of the avast! drivers in DriverView</p></div><p>After IDA disassembled the driver, I started reading the assembly of the driver’s initialization routine, called <code class="literal">DriverEntry()</code>.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-10" class="footnoteref">66</a>]</sup></p><a id="I_programlisting6_d1e6226"/><pre class="programlisting">[..]
.text:000105D2 ; const WCHAR aDeviceAavmker4
<strong class="userinput"><code>.text:000105D2 aDeviceAavmker4:                        ; DATA XREF: DriverEntry+12</code></strong>
<strong class="userinput"><code>.text:000105D2                 unicode 0, &lt;\Device\AavmKer4&gt;,0</code></strong>
[..]
.text:00010620 ; NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, →
PUNICODE_STRING RegistryPath)
.text:00010620                 public DriverEntry
.text:00010620 DriverEntry     proc near
.text:00010620
.text:00010620 SymbolicLinkName= UNICODE_STRING ptr −14h
.text:00010620 DestinationString= UNICODE_STRING ptr −0Ch
.text:00010620 DeviceObject    = dword ptr −4
.text:00010620 DriverObject    = dword ptr  8
.text:00010620 RegistryPath    = dword ptr  0Ch
.text:00010620
.text:00010620                 push    ebp
.text:00010621                 mov     ebp, esp
.text:00010623                 sub     esp, 14h
.text:00010626                 push    ebx
.text:00010627                 push    esi
.text:00010628                 mov     esi, ds:RtlInitUnicodeString
.text:0001062E                 push    edi
.text:0001062F                 lea     eax, [ebp+DestinationString]
<strong class="userinput"><code>.text:00010632                 push    offset aDeviceAavmker4 ; SourceString</code></strong>
.text:00010637                 push    eax             ; DestinationString
.text:00010638                 call    esi ; RtlInitUnicodeString
.text:0001063A                 mov     edi, [ebp+DriverObject]
.text:0001063D                 lea     eax, [ebp+DeviceObject]
.text:00010640                 xor     ebx, ebx
.text:00010642                 push    eax             ; DeviceObject
.text:00010643                 push    ebx             ; Exclusive
.text:00010644                 push    ebx             ; DeviceCharacteristics
.text:00010645                 lea     eax, [ebp+DestinationString]
.text:00010648                 push    22h             ; DeviceType
.text:0001064A                 push    eax             ; DeviceName
.text:0001064B                 push    ebx             ; DeviceExtensionSize
.text:0001064C                 push    edi             ; DriverObject
<strong class="userinput"><code>.text:0001064D                 call    ds:IoCreateDevice</code></strong>
.text:00010653                 cmp     eax, ebx
.text:00010655                 jl      loc_1075E
[..]</pre><p>In the <code class="literal">DriverEntry()</code> function, a device called <code class="literal">\Device\AavmKer4</code> (see <code class="literal">.text:00010632</code> and <code class="literal">.text:000105D2</code>) is created using the <code class="literal">IoCreateDevice()</code> function at address <code class="literal">.text:0001064D</code>. The illustrated assembly snippet of <code class="literal">DriverEntry()</code> can be translated into the following C code:</p><a id="I_programlisting6_d1e6264"/><pre class="programlisting">[..]
RtlInitUnicodeString (&amp;DestinationString, &amp;L"\\Device\\AavmKer4");
retval = IoCreateDevice (DriverObject, 0, &amp;DestinationString,
 0x22, 0, 0, &amp;DeviceObject);
[..]</pre></div><div class="sect2" title="Step 3: Check the Device Security Settings"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_check_the_device_security_s"/>Step 3: Check the Device Security Settings</h2></div></div></div><p>I then checked the security settings of the <code class="literal">AavmKer4</code> device using WinObj (see <a class="xref" href="ch06.html#navigating_to_the_security_settings_of_t" title="Figure 6-2. Navigating to the security settings of the AavmKer4 device in WinObj">Figure 6-2</a>).<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-11" class="footnoteref">67</a>]</sup><a id="IDX-CHP-6-0015" class="indexterm"/></p><div class="figure"><a id="navigating_to_the_security_settings_of_t"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e6286"/><img src="httpatomoreillycomsourcenostarchimages939307.png.jpg" alt="Navigating to the security settings of the AavmKer4 device in WinObj"/></div></div><p class="title">Figure 6-2. Navigating to the security settings of the <code class="literal">AavmKer4</code> device in WinObj</p></div><p>To view the security settings of the device in WinObj, I right-clicked the device name, chose <span class="strong"><strong>Properties</strong></span> from the option list, and then chose the <span class="strong"><strong>Security</strong></span> tab. The device object allows every system user (Everyone group) to read from or to write to the device (see <a class="xref" href="ch06.html#viewing_the_security_settings_of_reverse" title="Figure 6-3. Viewing the security settings of \Device\AavmKer4">Figure 6-3</a>). This means that every user of the system is allowed to send data to the IOCTLs implemented by the driver, which is great—this makes this driver a valuable target!</p></div><div class="sect2" title="Step 4: List the IOCTLs"><div class="titlepage"><div><div><h2 class="title"><a id="step_4_colon_list_the_ioctls"/>Step 4: List the IOCTLs</h2></div></div></div><p>A Windows user space application must call <code class="literal">DeviceIoControl()</code> in order to send an IOCTL request to a kernel driver. Such calls to <code class="literal">DeviceIoControl()</code> cause the I/O manager of Windows to create an <code class="literal">IRP_MJ_DEVICE_CONTROL</code> request, which is sent to the topmost driver. The driver implements a special dispatch routine to handle <code class="literal">IRP_MJ_DEVICE_CONTROL</code> requests, and that dispatch routine is referenced through an array called <code class="literal">MajorFunction[]</code>. This array is an element of the <code class="literal">DRIVER_OBJECT</code> data structure, which can be found in <span class="emphasis"><em>ntddk.h</em></span> of the Windows Driver Kit.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-12" class="footnoteref">68</a>]</sup> To save space, I removed the comments from the following code.<a id="IDX-CHP-6-0016" class="indexterm"/><a id="IDX-CHP-6-0017" class="indexterm"/><a id="IDX-CHP-6-0018" class="indexterm"/><a id="IDX-CHP-6-0019" class="indexterm"/></p><div class="figure"><a id="viewing_the_security_settings_of_reverse"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e6347"/><img src="httpatomoreillycomsourcenostarchimages939309.png.jpg" alt="Viewing the security settings of \Device\AavmKer4"/></div></div><p class="title">Figure 6-3. Viewing the security settings of <code class="literal">\Device\AavmKer4</code></p></div><a id="I_programlisting6_d1e6352"/><pre class="programlisting">[..]
typedef struct _DRIVER_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PDEVICE_OBJECT DeviceObject;
    ULONG Flags;
    PVOID DriverStart;
    ULONG DriverSize;
    PVOID DriverSection;
    PDRIVER_EXTENSION DriverExtension;
    UNICODE_STRING DriverName;
    PUNICODE_STRING HardwareDatabase;
    PFAST_IO_DISPATCH FastIoDispatch;
    PDRIVER_INITIALIZE DriverInit;
    PDRIVER_STARTIO DriverStartIo;
    PDRIVER_UNLOAD DriverUnload;
    <strong class="userinput"><code>PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];</code></strong>
} DRIVER_OBJECT;
[..]</pre><p>Below, the elements of the <code class="literal">MajorFunction[]</code> array are defined (also from <span class="emphasis"><em>ntddk.h</em></span>):<a id="IDX-CHP-6-0020" class="indexterm"/><a id="IDX-CHP-6-0021" class="indexterm"/></p><a id="I_programlisting6_d1e6373"/><pre class="programlisting">[..]
#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
<strong class="userinput"><code>#define IRP_MJ_DEVICE_CONTROL           0x0e</code></strong>
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP     // Obsolete....
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b
[..]</pre><p>To list the IOCTLs implemented by a driver, I had to find the driver’s IOCTL dispatch routine. If I’d had access to the C code of the driver, this would have been easy, since I know that the assignment of the dispatch routine usually looks like this:</p><a id="I_programlisting6_d1e6380"/><pre class="programlisting">DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IOCTL_dispatch_routine;</pre><p>Unfortunately, I didn’t have access to the source code of the avast! <span class="emphasis"><em>Aavmker4.sys</em></span> driver. How could I find the dispatch assignment using only the disassembly provided by IDA Pro?</p><p>To answer this question, I needed more information about the <code class="literal">DRIVER_OBJECT</code> data structure. I attached WinDbg to the VMware guest system and used the <code class="literal">dt</code> command (see Section B.2 for a detailed description of the following debugger commands) to display the available information about the structure:</p><a id="I_programlisting6_d1e6395"/><pre class="programlisting">kd&gt; <strong class="userinput"><code>.sympath SRV*c:\WinDBGSymbols*http://msdl.microsoft.com/download/symbols</code></strong>
kd&gt; <strong class="userinput"><code>.reload</code></strong>
[..]
kd&gt; <strong class="userinput"><code>dt -v _DRIVER_OBJECT .</code></strong>
nt!_DRIVER_OBJECT
struct _DRIVER_OBJECT, 15 elements, 0xa8 bytes
   +0x000 Type             : Int2B
   +0x002 Size             : Int2B
   +0x004 DeviceObject     :
   +0x008 Flags            : Uint4B
   +0x00c DriverStart      :
   +0x010 DriverSize       : Uint4B
   +0x014 DriverSection    :
   +0x018 DriverExtension  :
   +0x01c DriverName       : struct _UNICODE_STRING, 3 elements, 0x8 bytes
      +0x000 Length           : Uint2B
      +0x002 MaximumLength    : Uint2B
      +0x004 Buffer           : Ptr32 to Uint2B
   +0x024 HardwareDatabase :
   +0x028 FastIoDispatch   :
   +0x02c DriverInit       :
   +0x030 DriverStartIo    :
   +0x034 DriverUnload     :
   <strong class="userinput"><code>+0x038 MajorFunction    : [28]</code></strong></pre><p>The debugger output shows that the <code class="literal">MajorFunction[]</code> array starts at structure offset <code class="literal">0x38</code>. After looking at the <span class="emphasis"><em>ntddk.h</em></span> header file of the Windows Driver Kit, I knew that <code class="literal">IRP_MJ_DEVICE_CONTROL</code> was located at offset <code class="literal">0x0e</code> in <code class="literal">MajorFunction[]</code> and that the element size of the array was a pointer (4 bytes on 32-bit platforms).</p><p>So the assignment can be expressed as the following:</p><a id="I_programlisting6_d1e6432"/><pre class="programlisting">In C: DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IOCTL_dispatch_routine;
Offsets         : DriverObject   +   0x38  +  0x0e * 4   = IOCTL_dispatch_routine;
Simplified form : DriverObject   +   0x70                = IOCTL_dispatch_routine;</pre><p>There are countless ways to express this assignment in Intel assembly, but what I found in the driver code of avast! was these instructions:<a id="IDX-CHP-6-0022" class="indexterm"/></p><a id="I_programlisting6_d1e6441"/><pre class="programlisting">[..]
.text:00010748                 mov     eax, [ebp+DriverObject]
[..]
.text:00010750                 mov     dword ptr [eax+70h], offset sub_1098C
[..]</pre><p>At address <code class="literal">.text:00010748</code>, a pointer to a <code class="literal">DRIVER_OBJECT</code> is stored in <code class="literal">EAX</code>. Then at address <code class="literal">.text:00010750</code>, the function pointer of the IOCTL dispatch routine gets assigned to <code class="literal">MajorFunction[IRP_MJ_DEVICE_CONTROL]</code>.</p><a id="I_programlisting6_d1e6460"/><pre class="programlisting">Assignment in C: DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = sub_1098c;
Offsets        : DriverObject + 0x70                                = sub_1098c;</pre><p>I had finally found the IOCTL dispatch routine of the driver: <code class="literal">sub_1098C</code>! The IOCTL dispatch routine could also be found with the help of the debugger:</p><a id="I_programlisting6_d1e6467"/><pre class="programlisting">kd&gt; <strong class="userinput"><code>!drvobj AavmKer4 7</code></strong>
Driver object (86444f38) is for:
*** ERROR: Symbol file could not be found.  Defaulted to export
 symbols for Aavmker4.SYS -
 \Driver\Aavmker4
Driver Extension List: (id , addr)

Device Object list:
863a9150

DriverEntry:   f792d620 Aavmker4
DriverStartIo: 00000000
DriverUnload:  00000000
AddDevice:     00000000

Dispatch routines:
[00] IRP_MJ_CREATE                      f792d766         Aavmker4+0x766
[01] IRP_MJ_CREATE_NAMED_PIPE           f792d766         Aavmker4+0x766
[02] IRP_MJ_CLOSE                       f792d766         Aavmker4+0x766
[03] IRP_MJ_READ                        f792d766         Aavmker4+0x766
[04] IRP_MJ_WRITE                       f792d766         Aavmker4+0x766
[05] IRP_MJ_QUERY_INFORMATION           f792d766         Aavmker4+0x766
[06] IRP_MJ_SET_INFORMATION             f792d766         Aavmker4+0x766
[07] IRP_MJ_QUERY_EA                    f792d766         Aavmker4+0x766
[08] IRP_MJ_SET_EA                      f792d766         Aavmker4+0x766
[09] IRP_MJ_FLUSH_BUFFERS               f792d766         Aavmker4+0x766
[0a] IRP_MJ_QUERY_VOLUME_INFORMATION    f792d766         Aavmker4+0x766
[0b] IRP_MJ_SET_VOLUME_INFORMATION      f792d766         Aavmker4+0x766
[0c] IRP_MJ_DIRECTORY_CONTROL           f792d766         Aavmker4+0x766
[0d] IRP_MJ_FILE_SYSTEM_CONTROL         f792d766         Aavmker4+0x766
<strong class="userinput"><code>[0e] IRP_MJ_DEVICE_CONTROL              f792d98c         Aavmker4+0x98c</code></strong>
[..]</pre><p>The output of WinDbg shows that the <code class="literal">IRP_MJ_DEVICE_CONTROL</code> dispatch routine can be found at address <code class="literal">Aavmker4+0x98c</code>.</p><p>After I found the dispatch routine, I searched this function for the implemented IOCTLs. The IOCTL dispatch routine has the following prototype:<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-13" class="footnoteref">69</a>]</sup></p><a id="I_programlisting6_d1e6487"/><pre class="programlisting">NTSTATUS
  DispatchDeviceControl(
    __in struct _DEVICE_OBJECT  *DeviceObject,
    __in struct _IRP  *Irp
    )
  { ... }</pre><p>The second function parameter is a pointer to an <span class="emphasis"><em>I/O request packet</em></span> (<span class="emphasis"><em>IRP</em></span>) structure. An IRP is the basic structure that the Windows I/O manager uses to communicate with drivers and allow drivers to communicate with each other. This structure transports the user-supplied IOCTL data as well as the requested IOCTL code.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-14" class="footnoteref">70</a>]</sup><a id="IDX-CHP-6-0023" class="indexterm"/><a id="IDX-CHP-6-0024" class="indexterm"/><a id="IDX-CHP-6-0025" class="indexterm"/></p><p>I then had a look at the disassembly of the dispatch routine in order to generate a list of the IOCTLs:</p><a id="I_programlisting6_d1e6509"/><pre class="programlisting">[..]
.text:0001098C ; int __stdcall sub_1098C(int, PIRP Irp)
.text:0001098C sub_1098C       proc near               ; DATA XREF: DriverEntry+130
[..]
<strong class="userinput"><code>.text:000109B2                 mov     ebx, [ebp+Irp]  ; ebx = address of IRP</code></strong>
<strong class="userinput"><code>.text:000109B5                 mov     eax, [ebx+60h]</code></strong>
[..]</pre><p>A pointer to the IRP structure is stored in <code class="literal">EBX</code> at address <code class="literal">.text:000109B2</code> of the IOCTL dispatch routine. Then a value, located at offset <code class="literal">0x60</code> of the IRP structure, is referenced (see <code class="literal">.text:000109B5</code>).</p><a id="I_programlisting6_d1e6531"/><pre class="programlisting">kd&gt; <strong class="userinput"><code>dt -v -r 3 _IRP</code></strong>
nt!_IRP
struct _IRP, 21 elements, 0x70 bytes
  +0x000 Type             : ??
  +0x002 Size             : ??
  +0x004 MdlAddress       : ????
  +0x008 Flags            : ??
[..]
  <strong class="userinput"><code>+0x040 Tail             : union __unnamed, 3 elements, 0x30 bytes</code></strong>
     +0x000 Overlay          : struct __unnamed, 8 elements, 0x28 bytes
        +0x000 DeviceQueueEntry : struct _KDEVICE_QUEUE_ENTRY, 3 elements, 0x10 bytes
        +0x000 DriverContext    : [4] ????
        +0x010 Thread           : ????
        +0x014 AuxiliaryBuffer  : ????
        +0x018 ListEntry        : struct _LIST_ENTRY, 2 elements, 0x8 bytes
        <strong class="userinput"><code>+0x020 CurrentStackLocation : ????</code></strong>
[..]</pre><p>The output of WinDbg shows that the IRP structure member <code class="literal">CurrentStackLocation</code> is located at offset <code class="literal">0x60</code>. This structure is defined in <span class="emphasis"><em>ntddk.h</em></span> of the Windows Driver Kit:<a id="IDX-CHP-6-0026" class="indexterm"/></p><a id="I_programlisting6_d1e6556"/><pre class="programlisting">[..]
//
// I/O Request Packet (IRP) definition
//
typedef struct _IRP {
[..]
        <strong class="userinput"><code>//</code></strong>
        <strong class="userinput"><code>// Current stack location - contains a pointer to the current</code></strong>
        <strong class="userinput"><code>// IO_STACK_LOCATION structure in the IRP stack.  This field</code></strong>
        <strong class="userinput"><code>// should never be directly accessed by drivers.  They should</code></strong>
        <strong class="userinput"><code>// use the standard functions.</code></strong>
        <strong class="userinput"><code>//</code></strong>

        <strong class="userinput"><code>struct _IO_STACK_LOCATION *CurrentStackLocation;</code></strong>
[..]</pre><p>The layout of the <code class="literal">_IO_STACK_LOCATION</code> structure is shown below (see <span class="emphasis"><em>ntddk.h</em></span> of the Windows Driver Kit):<a id="IDX-CHP-6-0027" class="indexterm"/></p><a id="I_programlisting6_d1e6591"/><pre class="programlisting">[..]
<strong class="userinput"><code>typedef struct _IO_STACK_LOCATION {</code></strong>
    UCHAR MajorFunction;
    UCHAR MinorFunction;
    UCHAR Flags;
    UCHAR Control;
[..]
        //
        // System service parameters for:  NtDeviceIoControlFile
        //
        // Note that the user's output buffer is stored in the
        // UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer
        // field.
        //

        struct {
            <strong class="userinput"><code>ULONG OutputBufferLength;</code></strong>
            <strong class="userinput"><code>ULONG POINTER_ALIGNMENT InputBufferLength;</code></strong>
            <strong class="userinput"><code>ULONG POINTER_ALIGNMENT IoControlCode;</code></strong>
            PVOID Type3InputBuffer;
        } DeviceIoControl;
[..]</pre><p>In addition to the <code class="literal">IoControlCode</code> of the requested IOCTL, this structure contains information about the size of the input and output buffer. Now that I had more information about the <code class="literal">_IO_STACK_LOCATION</code> structure, I took a second look at the disassembly:</p><a id="I_programlisting6_d1e6614"/><pre class="programlisting">[..]
.text:0001098C ; int __stdcall sub_1098C(int, PIRP Irp)
.text:0001098C sub_1098C     proc near               ; DATA XREF: DriverEntry+130
[..]
.text:000109B2        mov    ebx, [ebp+Irp]  ; ebx = address of IRP
<strong class="userinput"><code>.text:000109B5        mov    eax, [ebx+60h]  ; eax = address of CurrentStackLocation</code></strong>
<strong class="userinput"><code>.text:000109B8        mov    esi, [eax+8]    ; ULONG InputBufferLength</code></strong>
.text:000109BB        mov    [ebp+var_1C], esi ; save InputBufferLength in var_1C
<strong class="userinput"><code>.text:000109BE        mov    edx, [eax+4]    ; ULONG OutputBufferLength</code></strong>
.text:000109C1        mov    [ebp+var_3C], edx ; save OutputBufferLength in var_3C
<strong class="userinput"><code>.text:000109C4        mov    eax, [eax+0Ch]  ; ULONG IoControlCode</code></strong>
<strong class="userinput"><code>.text:000109C7        mov    ecx, 0B2D6002Ch ; ecx = 0xB2D6002C</code></strong>
<strong class="userinput"><code>.text:000109CC        cmp    eax, ecx        ; compare 0xB2D6002C with IoControlCode</code></strong>
.text:000109CE        ja     loc_10D15
[..]</pre><p>As I mentioned before, a pointer to <code class="literal">_IO_STACK_LOCATION</code> is stored in <code class="literal">EAX</code> at address <code class="literal">.text:000109B5</code>, and then at address <code class="literal">.text:000109B8</code> the <code class="literal">InputBufferLength</code> is stored in <code class="literal">ESI</code>. At <code class="literal">.text:000109BE</code> the <code class="literal">OutputBufferLength</code> is stored in <code class="literal">EDX</code>, and at <code class="literal">.text:000109C4</code> the <code class="literal">IoControlCode</code> is stored in <code class="literal">EAX</code>. Later, the requested IOCTL code stored in <code class="literal">EAX</code> is compared with the value <code class="literal">0xB2D6002C</code> (see address <code class="literal">.text:000109C7</code> and <code class="literal">.text:000109CC</code>). Hey, I found the first valid IOCTL code of the driver! I searched the function for all values that are compared with the requested IOCTL code in <code class="literal">EAX</code> and got a list of the supported IOCTLs of <span class="emphasis"><em>Aavmker4.sys</em></span>.</p></div><div class="sect2" title="Step 5: Find the User-Controlled Input Values"><div class="titlepage"><div><div><h2 class="title"><a id="step_5_colon_find_the_user-controlled_in"/>Step 5: Find the User-Controlled Input Values</h2></div></div></div><p>After I generated the list of all the supported IOCTLs, I tried to locate the buffer containing the user-supplied IOCTL input data. All <code class="literal">IRP_MJ_DEVICE_CONTROL</code> requests supply both an input buffer and an output buffer. The way the system describes these buffers depends on the <span class="emphasis"><em>data transfer type</em></span>. The transfer type is stored in the IOCTL code itself. Under Microsoft Windows, the IOCTL code values are normally created using the <code class="literal">CTL_CODE</code> macro.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-15" class="footnoteref">71</a>]</sup> Here’s another excerpt from <span class="emphasis"><em>ntddk.h</em></span>:<a id="IDX-CHP-6-0028" class="indexterm"/><a id="IDX-CHP-6-0029" class="indexterm"/></p><a id="I_programlisting6_d1e6720"/><pre class="programlisting">[..]
//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

<strong class="userinput"><code>#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \</code></strong>
    <strong class="userinput"><code>((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \</code></strong>
<strong class="userinput"><code>)</code></strong>

[..]

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3
[..]</pre><p>The transfer type is specified using the <code class="literal">Method</code> parameter of the <code class="literal">CTL_CODE</code> macro. I wrote a little tool to reveal which data transfer type is used by the IOCTLs of <span class="emphasis"><em>Aavmker4.sys</em></span>:</p><div class="example"><a id="a_little_tool_that_i_wrote"/><p class="title">Example 6-1. A little tool that I wrote (<span class="emphasis"><em>IOCTL_method.c</em></span>) to show which data transfer type is used by the IOCTLs of <span class="emphasis"><em>Aavmker4.sys</em></span></p><div class="example-contents"><pre class="programlisting">01    #include &lt;windows.h&gt;
02    #include &lt;stdio.h&gt;
03
04    int
05    main (int argc, char *argv[])
06    {
07        unsigned int  method  = 0;
08        unsigned int  code    = 0;
09
10        if (argc != 2) {
11           fprintf (stderr, "Usage: %s &lt;IOCTL code&gt;\n", argv[0]);
12           return 1;
13        }
14
15        code = strtoul (argv[1], (char **) NULL, 16);
16        method = code &amp; 3;
17
18        switch (method) {
19           case 0:
20              printf ("METHOD_BUFFERED\n");
21              break;
22           case 1:
23              printf ("METHOD_IN_DIRECT\n");
24              break;
25           case 2:
26              printf ("METHOD_OUT_DIRECT\n");
27              break;
28           case 3:
29              printf ("METHOD_NEITHER\n");
30              break;
31           default:
32              fprintf (stderr, "ERROR: invalid IOCTL data transfer method\n");
33              break;
34        }
35
36        return 0;
37    }</pre></div></div><p>I then compiled the tool with the command-line C compiler of Visual Studio (<code class="literal">cl</code>):</p><a id="I_programlisting6_d1e6757"/><pre class="programlisting">C:\BHD&gt;<strong class="userinput"><code>cl /nologo IOCTL_method.c</code></strong>
IOCTL_method.c</pre><p>The following output shows the tool from <a class="xref" href="ch06.html#a_little_tool_that_i_wrote" title="Example 6-1. A little tool that I wrote (IOCTL_method.c) to show which data transfer type is used by the IOCTLs of Aavmker4.sys">Example 6-1</a> in action:</p><a id="I_programlisting6_d1e6766"/><pre class="programlisting">C:\BHD&gt;<strong class="userinput"><code>IOCTL_method.exe B2D6002C</code></strong>
METHOD_BUFFERED</pre><p>So the driver uses the <code class="literal">METHOD_BUFFERED</code> transfer type to describe the input and output buffers of an IOCTL request. According to the buffer descriptions in the Windows Driver Kit, the input buffer of IOCTLs, which use the <code class="literal">METHOD_BUFFERED</code> transfer type, can be found at <code class="literal">Irp-&gt;AssociatedIrp.SystemBuffer</code>.<a id="IDX-CHP-6-0030" class="indexterm"/></p><p>Below is an example of a reference to the input buffer in the disassembly of <span class="emphasis"><em>Aavmker4.sys</em></span>:</p><a id="I_programlisting6_d1e6791"/><pre class="programlisting">[..]
.text:00010CF1                 mov     eax, [ebx+0Ch]  ; ebx = address of IRP
.text:00010CF4                 mov     eax, [eax]
[..]</pre><p>In this example, <code class="literal">EBX</code> holds a pointer to the IRP structure. At address <code class="literal">.text:00010CF1</code>, the IRP structure member at offset <code class="literal">0x0c</code> is referenced.</p><a id="I_programlisting6_d1e6804"/><pre class="programlisting">kd&gt; <strong class="userinput"><code>dt -v -r 2 _IRP</code></strong>
nt!_IRP
struct _IRP, 21 elements, 0x70 bytes
   +0x000 Type             : ??
   +0x002 Size             : ??
   +0x004 MdlAddress       : ????
   +0x008 Flags            : ??
   <strong class="userinput"><code>+0x00c AssociatedIrp    : union __unnamed, 3 elements, 0x4 bytes</code></strong>
      +0x000 MasterIrp        : ????
      +0x000 IrpCount         : ??
      <strong class="userinput"><code>+0x000 SystemBuffer     : ????</code></strong>
[..]</pre><p>The output of WinDbg shows that <code class="literal">AssociatedIrp</code> is located at this offset (<code class="literal">IRP-&gt;AssociatedIrp</code>). At address <code class="literal">.text:00010CF4</code>, the input buffer of the IOCTL call is referenced and stored in <code class="literal">EAX</code> (<code class="literal">Irp-&gt;AssociatedIrp.SystemBuffer</code>). Now that I had found the supported IOCTLs, as well as the IOCTL input data, I started searching for bugs.<a id="IDX-CHP-6-0031" class="indexterm"/><a id="IDX-CHP-6-0032" class="indexterm"/></p></div><div class="sect2" title="Step 6: Reverse Engineer the IOCTL Handler"><div class="titlepage"><div><div><h2 class="title"><a id="step_6_colon_reverse_engineer_the_ioctl"/>Step 6: Reverse Engineer the IOCTL Handler</h2></div></div></div><p>To find a possible security defect, I audited the handler code of one IOCTL at a time while tracing the supplied input data. When I came across the IOCTL code <code class="literal">0xB2D60030</code>, I found a subtle bug.</p><p>If the IOCTL code <code class="literal">0xB2D60030</code> is requested by a user space application, the following code is executed:</p><a id="I_programlisting6_d1e6854"/><pre class="programlisting">[..]
.text:0001098C ; int __stdcall sub_1098C(int, PIRP Irp)
.text:0001098C sub_1098C       proc near               ; DATA XREF: DriverEntry+130
[..]
<strong class="userinput"><code>.text:00010D28                 cmp     eax, 0B2D60030h ; IOCTL-Code == 0xB2D60030 ?</code></strong>
.text:00010D2D                 jz      short loc_10DAB ; if so -&gt; loc_10DAB
[..]</pre><p>If the requested IOCTL code matches <code class="literal">0xB2D60030</code> (see <code class="literal">.text:00010D28</code>), the assembler code at address <code class="literal">.text:00010DAB</code> (<code class="literal">loc_10DAB</code>) is executed:</p><a id="I_programlisting6_d1e6873"/><pre class="programlisting">[..]
.text:000109B8            mov   esi, [eax+8]       ; ULONG InputBufferLength
<strong class="userinput"><code>.text:000109BB            mov   [ebp+var_1C], esi</code></strong>
[..]
.text:00010DAB loc_10DAB:                          ; CODE XREF: sub_1098C+3A1
<strong class="userinput"><code>.text:00010DAB            xor   edi, edi           ; EDI = 0</code></strong>
.text:00010DAD            cmp   byte_1240C, 0
.text:00010DB4            jz    short loc_10DC9
[..]
.text:00010DC9 loc_10DC9:                          ; CODE XREF: sub_1098C+428
<strong class="userinput"><code>.text:00010DC9            mov   esi, [ebx+0Ch]     ; Irp-&gt;AssociatedIrp.SystemBuffer</code></strong>
<strong class="userinput"><code>.text:00010DCC            cmp   [ebp+var_1C], 878h ; input data length == 0x878 ?</code></strong>
.text:00010DD3            jz    short loc_10DDF    ; if so -&gt; loc_10DDF
[..]</pre><p>At address <code class="literal">.text:00010DAB EDI</code> is set to 0. The <code class="literal">EBX</code> register holds a pointer to the IRP structure, and at address <code class="literal">.text:00010DC9</code> a pointer to the input buffer data is stored in <code class="literal">ESI</code> (<code class="literal">Irp-&gt;AssociatedIrp.SystemBuffer</code>).</p><p>At the beginning of the dispatch routine, the <code class="literal">InputBufferLength</code> of the request is stored in the stack variable <code class="literal">var_1c</code> (see <code class="literal">.text:000109BB</code>). The length of the input data at address <code class="literal">.text:00010DCC</code> is then compared to the value <code class="literal">0x878</code> (see <a class="xref" href="ch06.html#graph_view_of_the_vulnerable_code_path_i" title="Figure 6-4. Graph view of the vulnerable code path in IDA Pro, part 1">Figure 6-4</a>).</p><div class="figure"><a id="graph_view_of_the_vulnerable_code_path_i"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e6927"/><img src="httpatomoreillycomsourcenostarchimages939311.png.jpg" alt="Graph view of the vulnerable code path in IDA Pro, part 1"/></div></div><p class="title">Figure 6-4. Graph view of the vulnerable code path in IDA Pro, part 1</p></div><p>If the data length equals <code class="literal">0x878</code>, the user-controlled input data, pointed to by <code class="literal">ESI</code>, is further processed:<a id="IDX-CHP-6-0033" class="indexterm"/><a id="IDX-CHP-6-0034" class="indexterm"/></p><a id="I_programlisting6_d1e6946"/><pre class="programlisting">[..]
.text:00010DDF loc_10DDF:                     ; CODE XREF: sub_1098C+447
.text:00010DDF        mov   [ebp+var_4], edi
<strong class="userinput"><code>.text:00010DE2        cmp   [esi], edi        ; ESI == input data</code></strong>
.text:00010DE4        jz    short loc_10E34   ; if input data == NULL -&gt; loc_10E34
[..]
<strong class="userinput"><code>.text:00010DE6        mov   eax, [esi+870h]   ; ESI and EAX</code></strong>
 <strong class="userinput"><code>are pointing to the →</code></strong>
                                                <strong class="userinput"><code>input data</code></strong>
<strong class="userinput"><code>.text:00010DEC        mov   [ebp+var_48], eax ; a pointer to user controlled data →</code></strong>
                                                <strong class="userinput"><code>is stored in var_48</code></strong>
<strong class="userinput"><code>.text:00010DEF        cmp   dword ptr [eax], 0D0DEAD07h  ; validation of input data</code></strong>
.text:00010DF5        jnz   short loc_10E00
[..]
<strong class="userinput"><code>.text:00010DF7        cmp   dword ptr [eax+4], 10BAD0BAh ; validation of input data</code></strong>
.text:00010DFE        jz    short loc_10E06
[..]</pre><p>The code at address <code class="literal">.text:00010DE2</code> checks whether the input data equals NULL. If the input data is not NULL, a pointer from this data is extracted at <code class="literal">[user_data+0x870]</code> and stored in <code class="literal">EAX</code> (see <code class="literal">.text:00010DE6</code>). This pointer value is stored in the stack variable <code class="literal">var_48</code> (see <code class="literal">.text:00010DEC</code>). A check is then performed to see if the data, pointed to by <code class="literal">EAX</code>, starts with the values <code class="literal">0xD0DEAD07</code> and <code class="literal">0x10BAD0BA</code> (see <code class="literal">.text:00010DEF</code> and <code class="literal">.text:00010DF7</code>). If so, the parsing of the input data continues:</p><a id="I_programlisting6_d1e7010"/><pre class="programlisting">[..]
.text:00010E06 loc_10E06:                              ; CODE XREF: sub_1098C+472
.text:00010E06                 xor     edx, edx
.text:00010E08                 mov     eax, [ebp+var_48]
.text:00010E0B                 mov     [eax], edx
.text:00010E0D                 mov     [eax+4], edx
<strong class="userinput"><code>.text:00010E10                 add     esi, 4         ; source address</code></strong>
<strong class="userinput"><code>.text:00010E13                 mov     ecx, 21Ah      ; length</code></strong>
<strong class="userinput"><code>.text:00010E18                 mov     edi, [eax+18h] ; destination address</code></strong>
<strong class="userinput"><code>.text:00010E1B                 rep movsd              ; memcpy()</code></strong>
[..]</pre><p>The <code class="literal">rep movsd</code> instruction at address <code class="literal">.text:00010E1B</code> represents a <code class="literal">memcpy()</code> function. So <code class="literal">ESI</code> holds the source address, <code class="literal">EDI</code> holds the destination address, and <code class="literal">ECX</code> holds the length for the copy operation. <code class="literal">ECX</code> gets assigned the value <code class="literal">0x21a</code> (see <code class="literal">.text:00010E13</code>). <code class="literal">ESI</code> points to the user-controlled IOCTL data (see <code class="literal">.text:00010E10</code>), and <code class="literal">EDI</code> is also derived from user-controlled data pointed to by <code class="literal">EAX</code> (see <code class="literal">.text:00010E18</code> and <a class="xref" href="ch06.html#graph_view_of_the_vulnerable_code_pa" title="Figure 6-5. Graph view of the vulnerable code path in IDA Pro, part 2">Figure 6-5</a>).</p><div class="figure"><a id="graph_view_of_the_vulnerable_code_pa"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e7075"/><img src="httpatomoreillycomsourcenostarchimages939313.png.jpg" alt="Graph view of the vulnerable code path in IDA Pro, part 2"/></div></div><p class="title">Figure 6-5. Graph view of the vulnerable code path in IDA Pro, part 2</p></div><p>Here’s some pseudo C code of that <code class="literal">memcpy()</code> call:</p><a id="I_programlisting6_d1e7085"/><pre class="programlisting">memcpy ([EAX+0x18], ESI + 4, 0x21a * 4);</pre><p>Or, in more abstract terms:</p><a id="I_programlisting6_d1e7089"/><pre class="programlisting">memcpy (user_controlled_address, user_controlled_data, 0x868);</pre><p>It is therefore possible to write <code class="literal">0x868</code> bytes (<code class="literal">0x21a * 4</code> bytes, as the <code class="literal">rep movsd</code> instruction copies DWORDs from one location to another) of user-controllable data to an arbitrary user-controlled address in either user or kernel space. Nice!<a id="IDX-CHP-6-0035" class="indexterm"/></p><p>The anatomy of the bug, diagrammed in <a class="xref" href="ch06.html#overview_of_the_vulnerability_from_ioctl" title="Figure 6-6. Overview of the vulnerability from IOCTL request to memory corruption">Figure 6-6</a>, is as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>An IOCTL request (<code class="literal">0xB2D60030</code>) is sent to the kernel driver <span class="emphasis"><em>Aavmker4.sys</em></span> using the <code class="literal">AavmKer4</code> device.</p></li><li class="listitem"><p>The driver code checks whether the IOCTL input data length equals the value <code class="literal">0x878</code>. If so, proceed to step 3.</p><div class="figure"><a id="overview_of_the_vulnerability_from_ioctl"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e7131"/><img src="httpatomoreillycomsourcenostarchimages939315.png.jpg" alt="Overview of the vulnerability from IOCTL request to memory corruption"/></div></div><p class="title">Figure 6-6. Overview of the vulnerability from IOCTL request to memory corruption</p></div></li><li class="listitem"><p>The driver checks whether the user-controlled IOCTL input data contains the values <code class="literal">0xD0DEAD07</code> and <code class="literal">0x10BAD0BA</code>. If so, proceed to step 4.</p></li><li class="listitem"><p>The erroneous <code class="literal">memcpy()</code> call is executed.</p></li><li class="listitem"><p>The memory is corrupted.</p></li></ol></div></div></div></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 6. One Kernel to Rule Them All</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="chapter" title="Chapter 6. One Kernel to Rule Them All"><div class="titlepage"><div><div><h1 class="title"><a id="one_kernel_to_rule_them_all"/>Chapter 6. One Kernel to Rule Them All</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Saturday, March 8, 2008</em></span><a id="IDX-CHP-6-0001" class="indexterm"/><a id="IDX-CHP-6-0002" class="indexterm"/></p><p><span class="emphasis"><em>Dear Diary</em></span>,</p></div><p>After spending time auditing open source kernels and finding some interesting bugs, I wondered whether I could find a bug in a Microsoft Windows driver. There are lots of third-party drivers available for Windows, so choosing just a few to explore wasn’t easy. I finally chose some antivirus products, since they’re usually promising targets for bug hunting.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-1" class="footnoteref">57</a>]</sup> I visited VirusTotal<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-2" class="footnoteref">58</a>]</sup> and chose the first antivirus product that I recognized on its list: avast! from ALWIL Software.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-3" class="footnoteref">59</a>]</sup> That turned out to be a serendipitous decision.<a id="IDX-CHP-6-0003" class="indexterm"/><a id="IDX-CHP-6-0004" class="indexterm"/><a id="IDX-CHP-6-0005" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>On June 1, 2010, ALWIL Software was renamed AVAST Software</em></span>.</p></div><div class="sect1" title="6.1 Vulnerability Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_discovery-id4"/>6.1 Vulnerability Discovery</h1></div></div></div><p>I used the following steps to find the vulnerability:<a id="IDX-CHP-6-0006" class="indexterm"/><a id="IDX-CHP-6-0007" class="indexterm"/><a id="IDX-CHP-6-0008" class="indexterm"/><a id="IDX-CHP-6-0009" class="indexterm"/><a id="IDX-CHP-6-0010" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>The vulnerability described in this chapter affects all Microsoft Windows platforms supported by avast! Professional 4.7. The platform that I used throughout this chapter was the default installation of Windows XP SP3 32-bit</em></span>.<a id="IDX-CHP-6-0011" class="indexterm"/></p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: Prepare a VMware guest for kernel debugging.<a id="IDX-CHP-6-0012" class="indexterm"/><a id="IDX-CHP-6-0013" class="indexterm"/></p></li><li class="listitem"><p>Step 2: Generate a list of the drivers and device objects created by avast!</p></li><li class="listitem"><p>Step 3: Check the device security settings.</p></li><li class="listitem"><p>Step 4: List the IOCTLs.</p></li><li class="listitem"><p>Step 5: Find the user-controlled input values.</p></li><li class="listitem"><p>Step 6: Reverse engineer the IOCTL handler.</p></li></ul></div><div class="sect2" title="Step 1: Prepare a VMware Guest for Kernel Debugging"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_prepare_a_vmware_guest_for"/>Step 1: Prepare a VMware Guest for Kernel Debugging</h2></div></div></div><p>First, I set up a Windows XP VMware<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-4" class="footnoteref">60</a>]</sup> guest system that I configured for remote kernel debugging with WinDbg.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-5" class="footnoteref">61</a>]</sup> The necessary steps are described in Section B.3.</p></div><div class="sect2" title="Step 2: Generate a List of the Drivers and Device Objects Created by avast!"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_generate_a_list_of_the_driv"/>Step 2: Generate a List of the Drivers and Device Objects Created by avast!</h2></div></div></div><p>After downloading and installing the latest version of avast! Professional<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-6" class="footnoteref">62</a>]</sup> in the VMware guest system, I used DriverView<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-7" class="footnoteref">63</a>]</sup> to generate a list of the drivers that avast! loaded.<a id="IDX-CHP-6-0014" class="indexterm"/></p><p>One of the benefits of DriverView is that it makes identification of third-party drivers easy. As illustrated in <a class="xref" href="ch06.html#a_list_of_the_avast_exclamation_drivers" title="Figure 6-1. A list of the avast! drivers in DriverView">Figure 6-1</a>, avast! loaded four drivers. I chose the first one on the list, called <span class="emphasis"><em>Aavmker4.sys</em></span>, and used IDA Pro<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-8" class="footnoteref">64</a>]</sup> to generate a list of the device objects of that driver.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>A driver can create device objects to represent devices, or an interface to the driver, at any time by calling <em class="replaceable"><code>IoCreateDevice</code></em> or <em class="replaceable"><code>IoCreateDeviceSecure</code></em>.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-9" class="footnoteref">65</a>]</sup></p></div><div class="figure"><a id="a_list_of_the_avast_exclamation_drivers"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e6215"/><img src="httpatomoreillycomsourcenostarchimages939305.png.jpg" alt="A list of the avast! drivers in DriverView"/></div></div><p class="title">Figure 6-1. A list of the avast! drivers in DriverView</p></div><p>After IDA disassembled the driver, I started reading the assembly of the driver’s initialization routine, called <code class="literal">DriverEntry()</code>.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-10" class="footnoteref">66</a>]</sup></p><a id="I_programlisting6_d1e6226"/><pre class="programlisting">[..]
.text:000105D2 ; const WCHAR aDeviceAavmker4
<strong class="userinput"><code>.text:000105D2 aDeviceAavmker4:                        ; DATA XREF: DriverEntry+12</code></strong>
<strong class="userinput"><code>.text:000105D2                 unicode 0, &lt;\Device\AavmKer4&gt;,0</code></strong>
[..]
.text:00010620 ; NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, →
PUNICODE_STRING RegistryPath)
.text:00010620                 public DriverEntry
.text:00010620 DriverEntry     proc near
.text:00010620
.text:00010620 SymbolicLinkName= UNICODE_STRING ptr −14h
.text:00010620 DestinationString= UNICODE_STRING ptr −0Ch
.text:00010620 DeviceObject    = dword ptr −4
.text:00010620 DriverObject    = dword ptr  8
.text:00010620 RegistryPath    = dword ptr  0Ch
.text:00010620
.text:00010620                 push    ebp
.text:00010621                 mov     ebp, esp
.text:00010623                 sub     esp, 14h
.text:00010626                 push    ebx
.text:00010627                 push    esi
.text:00010628                 mov     esi, ds:RtlInitUnicodeString
.text:0001062E                 push    edi
.text:0001062F                 lea     eax, [ebp+DestinationString]
<strong class="userinput"><code>.text:00010632                 push    offset aDeviceAavmker4 ; SourceString</code></strong>
.text:00010637                 push    eax             ; DestinationString
.text:00010638                 call    esi ; RtlInitUnicodeString
.text:0001063A                 mov     edi, [ebp+DriverObject]
.text:0001063D                 lea     eax, [ebp+DeviceObject]
.text:00010640                 xor     ebx, ebx
.text:00010642                 push    eax             ; DeviceObject
.text:00010643                 push    ebx             ; Exclusive
.text:00010644                 push    ebx             ; DeviceCharacteristics
.text:00010645                 lea     eax, [ebp+DestinationString]
.text:00010648                 push    22h             ; DeviceType
.text:0001064A                 push    eax             ; DeviceName
.text:0001064B                 push    ebx             ; DeviceExtensionSize
.text:0001064C                 push    edi             ; DriverObject
<strong class="userinput"><code>.text:0001064D                 call    ds:IoCreateDevice</code></strong>
.text:00010653                 cmp     eax, ebx
.text:00010655                 jl      loc_1075E
[..]</pre><p>In the <code class="literal">DriverEntry()</code> function, a device called <code class="literal">\Device\AavmKer4</code> (see <code class="literal">.text:00010632</code> and <code class="literal">.text:000105D2</code>) is created using the <code class="literal">IoCreateDevice()</code> function at address <code class="literal">.text:0001064D</code>. The illustrated assembly snippet of <code class="literal">DriverEntry()</code> can be translated into the following C code:</p><a id="I_programlisting6_d1e6264"/><pre class="programlisting">[..]
RtlInitUnicodeString (&amp;DestinationString, &amp;L"\\Device\\AavmKer4");
retval = IoCreateDevice (DriverObject, 0, &amp;DestinationString,
 0x22, 0, 0, &amp;DeviceObject);
[..]</pre></div><div class="sect2" title="Step 3: Check the Device Security Settings"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_check_the_device_security_s"/>Step 3: Check the Device Security Settings</h2></div></div></div><p>I then checked the security settings of the <code class="literal">AavmKer4</code> device using WinObj (see <a class="xref" href="ch06.html#navigating_to_the_security_settings_of_t" title="Figure 6-2. Navigating to the security settings of the AavmKer4 device in WinObj">Figure 6-2</a>).<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-11" class="footnoteref">67</a>]</sup><a id="IDX-CHP-6-0015" class="indexterm"/></p><div class="figure"><a id="navigating_to_the_security_settings_of_t"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e6286"/><img src="httpatomoreillycomsourcenostarchimages939307.png.jpg" alt="Navigating to the security settings of the AavmKer4 device in WinObj"/></div></div><p class="title">Figure 6-2. Navigating to the security settings of the <code class="literal">AavmKer4</code> device in WinObj</p></div><p>To view the security settings of the device in WinObj, I right-clicked the device name, chose <span class="strong"><strong>Properties</strong></span> from the option list, and then chose the <span class="strong"><strong>Security</strong></span> tab. The device object allows every system user (Everyone group) to read from or to write to the device (see <a class="xref" href="ch06.html#viewing_the_security_settings_of_reverse" title="Figure 6-3. Viewing the security settings of \Device\AavmKer4">Figure 6-3</a>). This means that every user of the system is allowed to send data to the IOCTLs implemented by the driver, which is great—this makes this driver a valuable target!</p></div><div class="sect2" title="Step 4: List the IOCTLs"><div class="titlepage"><div><div><h2 class="title"><a id="step_4_colon_list_the_ioctls"/>Step 4: List the IOCTLs</h2></div></div></div><p>A Windows user space application must call <code class="literal">DeviceIoControl()</code> in order to send an IOCTL request to a kernel driver. Such calls to <code class="literal">DeviceIoControl()</code> cause the I/O manager of Windows to create an <code class="literal">IRP_MJ_DEVICE_CONTROL</code> request, which is sent to the topmost driver. The driver implements a special dispatch routine to handle <code class="literal">IRP_MJ_DEVICE_CONTROL</code> requests, and that dispatch routine is referenced through an array called <code class="literal">MajorFunction[]</code>. This array is an element of the <code class="literal">DRIVER_OBJECT</code> data structure, which can be found in <span class="emphasis"><em>ntddk.h</em></span> of the Windows Driver Kit.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-12" class="footnoteref">68</a>]</sup> To save space, I removed the comments from the following code.<a id="IDX-CHP-6-0016" class="indexterm"/><a id="IDX-CHP-6-0017" class="indexterm"/><a id="IDX-CHP-6-0018" class="indexterm"/><a id="IDX-CHP-6-0019" class="indexterm"/></p><div class="figure"><a id="viewing_the_security_settings_of_reverse"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e6347"/><img src="httpatomoreillycomsourcenostarchimages939309.png.jpg" alt="Viewing the security settings of \Device\AavmKer4"/></div></div><p class="title">Figure 6-3. Viewing the security settings of <code class="literal">\Device\AavmKer4</code></p></div><a id="I_programlisting6_d1e6352"/><pre class="programlisting">[..]
typedef struct _DRIVER_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PDEVICE_OBJECT DeviceObject;
    ULONG Flags;
    PVOID DriverStart;
    ULONG DriverSize;
    PVOID DriverSection;
    PDRIVER_EXTENSION DriverExtension;
    UNICODE_STRING DriverName;
    PUNICODE_STRING HardwareDatabase;
    PFAST_IO_DISPATCH FastIoDispatch;
    PDRIVER_INITIALIZE DriverInit;
    PDRIVER_STARTIO DriverStartIo;
    PDRIVER_UNLOAD DriverUnload;
    <strong class="userinput"><code>PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];</code></strong>
} DRIVER_OBJECT;
[..]</pre><p>Below, the elements of the <code class="literal">MajorFunction[]</code> array are defined (also from <span class="emphasis"><em>ntddk.h</em></span>):<a id="IDX-CHP-6-0020" class="indexterm"/><a id="IDX-CHP-6-0021" class="indexterm"/></p><a id="I_programlisting6_d1e6373"/><pre class="programlisting">[..]
#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
<strong class="userinput"><code>#define IRP_MJ_DEVICE_CONTROL           0x0e</code></strong>
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP     // Obsolete....
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b
[..]</pre><p>To list the IOCTLs implemented by a driver, I had to find the driver’s IOCTL dispatch routine. If I’d had access to the C code of the driver, this would have been easy, since I know that the assignment of the dispatch routine usually looks like this:</p><a id="I_programlisting6_d1e6380"/><pre class="programlisting">DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IOCTL_dispatch_routine;</pre><p>Unfortunately, I didn’t have access to the source code of the avast! <span class="emphasis"><em>Aavmker4.sys</em></span> driver. How could I find the dispatch assignment using only the disassembly provided by IDA Pro?</p><p>To answer this question, I needed more information about the <code class="literal">DRIVER_OBJECT</code> data structure. I attached WinDbg to the VMware guest system and used the <code class="literal">dt</code> command (see Section B.2 for a detailed description of the following debugger commands) to display the available information about the structure:</p><a id="I_programlisting6_d1e6395"/><pre class="programlisting">kd&gt; <strong class="userinput"><code>.sympath SRV*c:\WinDBGSymbols*http://msdl.microsoft.com/download/symbols</code></strong>
kd&gt; <strong class="userinput"><code>.reload</code></strong>
[..]
kd&gt; <strong class="userinput"><code>dt -v _DRIVER_OBJECT .</code></strong>
nt!_DRIVER_OBJECT
struct _DRIVER_OBJECT, 15 elements, 0xa8 bytes
   +0x000 Type             : Int2B
   +0x002 Size             : Int2B
   +0x004 DeviceObject     :
   +0x008 Flags            : Uint4B
   +0x00c DriverStart      :
   +0x010 DriverSize       : Uint4B
   +0x014 DriverSection    :
   +0x018 DriverExtension  :
   +0x01c DriverName       : struct _UNICODE_STRING, 3 elements, 0x8 bytes
      +0x000 Length           : Uint2B
      +0x002 MaximumLength    : Uint2B
      +0x004 Buffer           : Ptr32 to Uint2B
   +0x024 HardwareDatabase :
   +0x028 FastIoDispatch   :
   +0x02c DriverInit       :
   +0x030 DriverStartIo    :
   +0x034 DriverUnload     :
   <strong class="userinput"><code>+0x038 MajorFunction    : [28]</code></strong></pre><p>The debugger output shows that the <code class="literal">MajorFunction[]</code> array starts at structure offset <code class="literal">0x38</code>. After looking at the <span class="emphasis"><em>ntddk.h</em></span> header file of the Windows Driver Kit, I knew that <code class="literal">IRP_MJ_DEVICE_CONTROL</code> was located at offset <code class="literal">0x0e</code> in <code class="literal">MajorFunction[]</code> and that the element size of the array was a pointer (4 bytes on 32-bit platforms).</p><p>So the assignment can be expressed as the following:</p><a id="I_programlisting6_d1e6432"/><pre class="programlisting">In C: DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IOCTL_dispatch_routine;
Offsets         : DriverObject   +   0x38  +  0x0e * 4   = IOCTL_dispatch_routine;
Simplified form : DriverObject   +   0x70                = IOCTL_dispatch_routine;</pre><p>There are countless ways to express this assignment in Intel assembly, but what I found in the driver code of avast! was these instructions:<a id="IDX-CHP-6-0022" class="indexterm"/></p><a id="I_programlisting6_d1e6441"/><pre class="programlisting">[..]
.text:00010748                 mov     eax, [ebp+DriverObject]
[..]
.text:00010750                 mov     dword ptr [eax+70h], offset sub_1098C
[..]</pre><p>At address <code class="literal">.text:00010748</code>, a pointer to a <code class="literal">DRIVER_OBJECT</code> is stored in <code class="literal">EAX</code>. Then at address <code class="literal">.text:00010750</code>, the function pointer of the IOCTL dispatch routine gets assigned to <code class="literal">MajorFunction[IRP_MJ_DEVICE_CONTROL]</code>.</p><a id="I_programlisting6_d1e6460"/><pre class="programlisting">Assignment in C: DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = sub_1098c;
Offsets        : DriverObject + 0x70                                = sub_1098c;</pre><p>I had finally found the IOCTL dispatch routine of the driver: <code class="literal">sub_1098C</code>! The IOCTL dispatch routine could also be found with the help of the debugger:</p><a id="I_programlisting6_d1e6467"/><pre class="programlisting">kd&gt; <strong class="userinput"><code>!drvobj AavmKer4 7</code></strong>
Driver object (86444f38) is for:
*** ERROR: Symbol file could not be found.  Defaulted to export
 symbols for Aavmker4.SYS -
 \Driver\Aavmker4
Driver Extension List: (id , addr)

Device Object list:
863a9150

DriverEntry:   f792d620 Aavmker4
DriverStartIo: 00000000
DriverUnload:  00000000
AddDevice:     00000000

Dispatch routines:
[00] IRP_MJ_CREATE                      f792d766         Aavmker4+0x766
[01] IRP_MJ_CREATE_NAMED_PIPE           f792d766         Aavmker4+0x766
[02] IRP_MJ_CLOSE                       f792d766         Aavmker4+0x766
[03] IRP_MJ_READ                        f792d766         Aavmker4+0x766
[04] IRP_MJ_WRITE                       f792d766         Aavmker4+0x766
[05] IRP_MJ_QUERY_INFORMATION           f792d766         Aavmker4+0x766
[06] IRP_MJ_SET_INFORMATION             f792d766         Aavmker4+0x766
[07] IRP_MJ_QUERY_EA                    f792d766         Aavmker4+0x766
[08] IRP_MJ_SET_EA                      f792d766         Aavmker4+0x766
[09] IRP_MJ_FLUSH_BUFFERS               f792d766         Aavmker4+0x766
[0a] IRP_MJ_QUERY_VOLUME_INFORMATION    f792d766         Aavmker4+0x766
[0b] IRP_MJ_SET_VOLUME_INFORMATION      f792d766         Aavmker4+0x766
[0c] IRP_MJ_DIRECTORY_CONTROL           f792d766         Aavmker4+0x766
[0d] IRP_MJ_FILE_SYSTEM_CONTROL         f792d766         Aavmker4+0x766
<strong class="userinput"><code>[0e] IRP_MJ_DEVICE_CONTROL              f792d98c         Aavmker4+0x98c</code></strong>
[..]</pre><p>The output of WinDbg shows that the <code class="literal">IRP_MJ_DEVICE_CONTROL</code> dispatch routine can be found at address <code class="literal">Aavmker4+0x98c</code>.</p><p>After I found the dispatch routine, I searched this function for the implemented IOCTLs. The IOCTL dispatch routine has the following prototype:<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-13" class="footnoteref">69</a>]</sup></p><a id="I_programlisting6_d1e6487"/><pre class="programlisting">NTSTATUS
  DispatchDeviceControl(
    __in struct _DEVICE_OBJECT  *DeviceObject,
    __in struct _IRP  *Irp
    )
  { ... }</pre><p>The second function parameter is a pointer to an <span class="emphasis"><em>I/O request packet</em></span> (<span class="emphasis"><em>IRP</em></span>) structure. An IRP is the basic structure that the Windows I/O manager uses to communicate with drivers and allow drivers to communicate with each other. This structure transports the user-supplied IOCTL data as well as the requested IOCTL code.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-14" class="footnoteref">70</a>]</sup><a id="IDX-CHP-6-0023" class="indexterm"/><a id="IDX-CHP-6-0024" class="indexterm"/><a id="IDX-CHP-6-0025" class="indexterm"/></p><p>I then had a look at the disassembly of the dispatch routine in order to generate a list of the IOCTLs:</p><a id="I_programlisting6_d1e6509"/><pre class="programlisting">[..]
.text:0001098C ; int __stdcall sub_1098C(int, PIRP Irp)
.text:0001098C sub_1098C       proc near               ; DATA XREF: DriverEntry+130
[..]
<strong class="userinput"><code>.text:000109B2                 mov     ebx, [ebp+Irp]  ; ebx = address of IRP</code></strong>
<strong class="userinput"><code>.text:000109B5                 mov     eax, [ebx+60h]</code></strong>
[..]</pre><p>A pointer to the IRP structure is stored in <code class="literal">EBX</code> at address <code class="literal">.text:000109B2</code> of the IOCTL dispatch routine. Then a value, located at offset <code class="literal">0x60</code> of the IRP structure, is referenced (see <code class="literal">.text:000109B5</code>).</p><a id="I_programlisting6_d1e6531"/><pre class="programlisting">kd&gt; <strong class="userinput"><code>dt -v -r 3 _IRP</code></strong>
nt!_IRP
struct _IRP, 21 elements, 0x70 bytes
  +0x000 Type             : ??
  +0x002 Size             : ??
  +0x004 MdlAddress       : ????
  +0x008 Flags            : ??
[..]
  <strong class="userinput"><code>+0x040 Tail             : union __unnamed, 3 elements, 0x30 bytes</code></strong>
     +0x000 Overlay          : struct __unnamed, 8 elements, 0x28 bytes
        +0x000 DeviceQueueEntry : struct _KDEVICE_QUEUE_ENTRY, 3 elements, 0x10 bytes
        +0x000 DriverContext    : [4] ????
        +0x010 Thread           : ????
        +0x014 AuxiliaryBuffer  : ????
        +0x018 ListEntry        : struct _LIST_ENTRY, 2 elements, 0x8 bytes
        <strong class="userinput"><code>+0x020 CurrentStackLocation : ????</code></strong>
[..]</pre><p>The output of WinDbg shows that the IRP structure member <code class="literal">CurrentStackLocation</code> is located at offset <code class="literal">0x60</code>. This structure is defined in <span class="emphasis"><em>ntddk.h</em></span> of the Windows Driver Kit:<a id="IDX-CHP-6-0026" class="indexterm"/></p><a id="I_programlisting6_d1e6556"/><pre class="programlisting">[..]
//
// I/O Request Packet (IRP) definition
//
typedef struct _IRP {
[..]
        <strong class="userinput"><code>//</code></strong>
        <strong class="userinput"><code>// Current stack location - contains a pointer to the current</code></strong>
        <strong class="userinput"><code>// IO_STACK_LOCATION structure in the IRP stack.  This field</code></strong>
        <strong class="userinput"><code>// should never be directly accessed by drivers.  They should</code></strong>
        <strong class="userinput"><code>// use the standard functions.</code></strong>
        <strong class="userinput"><code>//</code></strong>

        <strong class="userinput"><code>struct _IO_STACK_LOCATION *CurrentStackLocation;</code></strong>
[..]</pre><p>The layout of the <code class="literal">_IO_STACK_LOCATION</code> structure is shown below (see <span class="emphasis"><em>ntddk.h</em></span> of the Windows Driver Kit):<a id="IDX-CHP-6-0027" class="indexterm"/></p><a id="I_programlisting6_d1e6591"/><pre class="programlisting">[..]
<strong class="userinput"><code>typedef struct _IO_STACK_LOCATION {</code></strong>
    UCHAR MajorFunction;
    UCHAR MinorFunction;
    UCHAR Flags;
    UCHAR Control;
[..]
        //
        // System service parameters for:  NtDeviceIoControlFile
        //
        // Note that the user's output buffer is stored in the
        // UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer
        // field.
        //

        struct {
            <strong class="userinput"><code>ULONG OutputBufferLength;</code></strong>
            <strong class="userinput"><code>ULONG POINTER_ALIGNMENT InputBufferLength;</code></strong>
            <strong class="userinput"><code>ULONG POINTER_ALIGNMENT IoControlCode;</code></strong>
            PVOID Type3InputBuffer;
        } DeviceIoControl;
[..]</pre><p>In addition to the <code class="literal">IoControlCode</code> of the requested IOCTL, this structure contains information about the size of the input and output buffer. Now that I had more information about the <code class="literal">_IO_STACK_LOCATION</code> structure, I took a second look at the disassembly:</p><a id="I_programlisting6_d1e6614"/><pre class="programlisting">[..]
.text:0001098C ; int __stdcall sub_1098C(int, PIRP Irp)
.text:0001098C sub_1098C     proc near               ; DATA XREF: DriverEntry+130
[..]
.text:000109B2        mov    ebx, [ebp+Irp]  ; ebx = address of IRP
<strong class="userinput"><code>.text:000109B5        mov    eax, [ebx+60h]  ; eax = address of CurrentStackLocation</code></strong>
<strong class="userinput"><code>.text:000109B8        mov    esi, [eax+8]    ; ULONG InputBufferLength</code></strong>
.text:000109BB        mov    [ebp+var_1C], esi ; save InputBufferLength in var_1C
<strong class="userinput"><code>.text:000109BE        mov    edx, [eax+4]    ; ULONG OutputBufferLength</code></strong>
.text:000109C1        mov    [ebp+var_3C], edx ; save OutputBufferLength in var_3C
<strong class="userinput"><code>.text:000109C4        mov    eax, [eax+0Ch]  ; ULONG IoControlCode</code></strong>
<strong class="userinput"><code>.text:000109C7        mov    ecx, 0B2D6002Ch ; ecx = 0xB2D6002C</code></strong>
<strong class="userinput"><code>.text:000109CC        cmp    eax, ecx        ; compare 0xB2D6002C with IoControlCode</code></strong>
.text:000109CE        ja     loc_10D15
[..]</pre><p>As I mentioned before, a pointer to <code class="literal">_IO_STACK_LOCATION</code> is stored in <code class="literal">EAX</code> at address <code class="literal">.text:000109B5</code>, and then at address <code class="literal">.text:000109B8</code> the <code class="literal">InputBufferLength</code> is stored in <code class="literal">ESI</code>. At <code class="literal">.text:000109BE</code> the <code class="literal">OutputBufferLength</code> is stored in <code class="literal">EDX</code>, and at <code class="literal">.text:000109C4</code> the <code class="literal">IoControlCode</code> is stored in <code class="literal">EAX</code>. Later, the requested IOCTL code stored in <code class="literal">EAX</code> is compared with the value <code class="literal">0xB2D6002C</code> (see address <code class="literal">.text:000109C7</code> and <code class="literal">.text:000109CC</code>). Hey, I found the first valid IOCTL code of the driver! I searched the function for all values that are compared with the requested IOCTL code in <code class="literal">EAX</code> and got a list of the supported IOCTLs of <span class="emphasis"><em>Aavmker4.sys</em></span>.</p></div><div class="sect2" title="Step 5: Find the User-Controlled Input Values"><div class="titlepage"><div><div><h2 class="title"><a id="step_5_colon_find_the_user-controlled_in"/>Step 5: Find the User-Controlled Input Values</h2></div></div></div><p>After I generated the list of all the supported IOCTLs, I tried to locate the buffer containing the user-supplied IOCTL input data. All <code class="literal">IRP_MJ_DEVICE_CONTROL</code> requests supply both an input buffer and an output buffer. The way the system describes these buffers depends on the <span class="emphasis"><em>data transfer type</em></span>. The transfer type is stored in the IOCTL code itself. Under Microsoft Windows, the IOCTL code values are normally created using the <code class="literal">CTL_CODE</code> macro.<sup>[<a href="ch06s05.html#ftn.CHP-6-FN-15" class="footnoteref">71</a>]</sup> Here’s another excerpt from <span class="emphasis"><em>ntddk.h</em></span>:<a id="IDX-CHP-6-0028" class="indexterm"/><a id="IDX-CHP-6-0029" class="indexterm"/></p><a id="I_programlisting6_d1e6720"/><pre class="programlisting">[..]
//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

<strong class="userinput"><code>#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \</code></strong>
    <strong class="userinput"><code>((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \</code></strong>
<strong class="userinput"><code>)</code></strong>

[..]

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3
[..]</pre><p>The transfer type is specified using the <code class="literal">Method</code> parameter of the <code class="literal">CTL_CODE</code> macro. I wrote a little tool to reveal which data transfer type is used by the IOCTLs of <span class="emphasis"><em>Aavmker4.sys</em></span>:</p><div class="example"><a id="a_little_tool_that_i_wrote"/><p class="title">Example 6-1. A little tool that I wrote (<span class="emphasis"><em>IOCTL_method.c</em></span>) to show which data transfer type is used by the IOCTLs of <span class="emphasis"><em>Aavmker4.sys</em></span></p><div class="example-contents"><pre class="programlisting">01    #include &lt;windows.h&gt;
02    #include &lt;stdio.h&gt;
03
04    int
05    main (int argc, char *argv[])
06    {
07        unsigned int  method  = 0;
08        unsigned int  code    = 0;
09
10        if (argc != 2) {
11           fprintf (stderr, "Usage: %s &lt;IOCTL code&gt;\n", argv[0]);
12           return 1;
13        }
14
15        code = strtoul (argv[1], (char **) NULL, 16);
16        method = code &amp; 3;
17
18        switch (method) {
19           case 0:
20              printf ("METHOD_BUFFERED\n");
21              break;
22           case 1:
23              printf ("METHOD_IN_DIRECT\n");
24              break;
25           case 2:
26              printf ("METHOD_OUT_DIRECT\n");
27              break;
28           case 3:
29              printf ("METHOD_NEITHER\n");
30              break;
31           default:
32              fprintf (stderr, "ERROR: invalid IOCTL data transfer method\n");
33              break;
34        }
35
36        return 0;
37    }</pre></div></div><p>I then compiled the tool with the command-line C compiler of Visual Studio (<code class="literal">cl</code>):</p><a id="I_programlisting6_d1e6757"/><pre class="programlisting">C:\BHD&gt;<strong class="userinput"><code>cl /nologo IOCTL_method.c</code></strong>
IOCTL_method.c</pre><p>The following output shows the tool from <a class="xref" href="ch06.html#a_little_tool_that_i_wrote" title="Example 6-1. A little tool that I wrote (IOCTL_method.c) to show which data transfer type is used by the IOCTLs of Aavmker4.sys">Example 6-1</a> in action:</p><a id="I_programlisting6_d1e6766"/><pre class="programlisting">C:\BHD&gt;<strong class="userinput"><code>IOCTL_method.exe B2D6002C</code></strong>
METHOD_BUFFERED</pre><p>So the driver uses the <code class="literal">METHOD_BUFFERED</code> transfer type to describe the input and output buffers of an IOCTL request. According to the buffer descriptions in the Windows Driver Kit, the input buffer of IOCTLs, which use the <code class="literal">METHOD_BUFFERED</code> transfer type, can be found at <code class="literal">Irp-&gt;AssociatedIrp.SystemBuffer</code>.<a id="IDX-CHP-6-0030" class="indexterm"/></p><p>Below is an example of a reference to the input buffer in the disassembly of <span class="emphasis"><em>Aavmker4.sys</em></span>:</p><a id="I_programlisting6_d1e6791"/><pre class="programlisting">[..]
.text:00010CF1                 mov     eax, [ebx+0Ch]  ; ebx = address of IRP
.text:00010CF4                 mov     eax, [eax]
[..]</pre><p>In this example, <code class="literal">EBX</code> holds a pointer to the IRP structure. At address <code class="literal">.text:00010CF1</code>, the IRP structure member at offset <code class="literal">0x0c</code> is referenced.</p><a id="I_programlisting6_d1e6804"/><pre class="programlisting">kd&gt; <strong class="userinput"><code>dt -v -r 2 _IRP</code></strong>
nt!_IRP
struct _IRP, 21 elements, 0x70 bytes
   +0x000 Type             : ??
   +0x002 Size             : ??
   +0x004 MdlAddress       : ????
   +0x008 Flags            : ??
   <strong class="userinput"><code>+0x00c AssociatedIrp    : union __unnamed, 3 elements, 0x4 bytes</code></strong>
      +0x000 MasterIrp        : ????
      +0x000 IrpCount         : ??
      <strong class="userinput"><code>+0x000 SystemBuffer     : ????</code></strong>
[..]</pre><p>The output of WinDbg shows that <code class="literal">AssociatedIrp</code> is located at this offset (<code class="literal">IRP-&gt;AssociatedIrp</code>). At address <code class="literal">.text:00010CF4</code>, the input buffer of the IOCTL call is referenced and stored in <code class="literal">EAX</code> (<code class="literal">Irp-&gt;AssociatedIrp.SystemBuffer</code>). Now that I had found the supported IOCTLs, as well as the IOCTL input data, I started searching for bugs.<a id="IDX-CHP-6-0031" class="indexterm"/><a id="IDX-CHP-6-0032" class="indexterm"/></p></div><div class="sect2" title="Step 6: Reverse Engineer the IOCTL Handler"><div class="titlepage"><div><div><h2 class="title"><a id="step_6_colon_reverse_engineer_the_ioctl"/>Step 6: Reverse Engineer the IOCTL Handler</h2></div></div></div><p>To find a possible security defect, I audited the handler code of one IOCTL at a time while tracing the supplied input data. When I came across the IOCTL code <code class="literal">0xB2D60030</code>, I found a subtle bug.</p><p>If the IOCTL code <code class="literal">0xB2D60030</code> is requested by a user space application, the following code is executed:</p><a id="I_programlisting6_d1e6854"/><pre class="programlisting">[..]
.text:0001098C ; int __stdcall sub_1098C(int, PIRP Irp)
.text:0001098C sub_1098C       proc near               ; DATA XREF: DriverEntry+130
[..]
<strong class="userinput"><code>.text:00010D28                 cmp     eax, 0B2D60030h ; IOCTL-Code == 0xB2D60030 ?</code></strong>
.text:00010D2D                 jz      short loc_10DAB ; if so -&gt; loc_10DAB
[..]</pre><p>If the requested IOCTL code matches <code class="literal">0xB2D60030</code> (see <code class="literal">.text:00010D28</code>), the assembler code at address <code class="literal">.text:00010DAB</code> (<code class="literal">loc_10DAB</code>) is executed:</p><a id="I_programlisting6_d1e6873"/><pre class="programlisting">[..]
.text:000109B8            mov   esi, [eax+8]       ; ULONG InputBufferLength
<strong class="userinput"><code>.text:000109BB            mov   [ebp+var_1C], esi</code></strong>
[..]
.text:00010DAB loc_10DAB:                          ; CODE XREF: sub_1098C+3A1
<strong class="userinput"><code>.text:00010DAB            xor   edi, edi           ; EDI = 0</code></strong>
.text:00010DAD            cmp   byte_1240C, 0
.text:00010DB4            jz    short loc_10DC9
[..]
.text:00010DC9 loc_10DC9:                          ; CODE XREF: sub_1098C+428
<strong class="userinput"><code>.text:00010DC9            mov   esi, [ebx+0Ch]     ; Irp-&gt;AssociatedIrp.SystemBuffer</code></strong>
<strong class="userinput"><code>.text:00010DCC            cmp   [ebp+var_1C], 878h ; input data length == 0x878 ?</code></strong>
.text:00010DD3            jz    short loc_10DDF    ; if so -&gt; loc_10DDF
[..]</pre><p>At address <code class="literal">.text:00010DAB EDI</code> is set to 0. The <code class="literal">EBX</code> register holds a pointer to the IRP structure, and at address <code class="literal">.text:00010DC9</code> a pointer to the input buffer data is stored in <code class="literal">ESI</code> (<code class="literal">Irp-&gt;AssociatedIrp.SystemBuffer</code>).</p><p>At the beginning of the dispatch routine, the <code class="literal">InputBufferLength</code> of the request is stored in the stack variable <code class="literal">var_1c</code> (see <code class="literal">.text:000109BB</code>). The length of the input data at address <code class="literal">.text:00010DCC</code> is then compared to the value <code class="literal">0x878</code> (see <a class="xref" href="ch06.html#graph_view_of_the_vulnerable_code_path_i" title="Figure 6-4. Graph view of the vulnerable code path in IDA Pro, part 1">Figure 6-4</a>).</p><div class="figure"><a id="graph_view_of_the_vulnerable_code_path_i"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e6927"/><img src="httpatomoreillycomsourcenostarchimages939311.png.jpg" alt="Graph view of the vulnerable code path in IDA Pro, part 1"/></div></div><p class="title">Figure 6-4. Graph view of the vulnerable code path in IDA Pro, part 1</p></div><p>If the data length equals <code class="literal">0x878</code>, the user-controlled input data, pointed to by <code class="literal">ESI</code>, is further processed:<a id="IDX-CHP-6-0033" class="indexterm"/><a id="IDX-CHP-6-0034" class="indexterm"/></p><a id="I_programlisting6_d1e6946"/><pre class="programlisting">[..]
.text:00010DDF loc_10DDF:                     ; CODE XREF: sub_1098C+447
.text:00010DDF        mov   [ebp+var_4], edi
<strong class="userinput"><code>.text:00010DE2        cmp   [esi], edi        ; ESI == input data</code></strong>
.text:00010DE4        jz    short loc_10E34   ; if input data == NULL -&gt; loc_10E34
[..]
<strong class="userinput"><code>.text:00010DE6        mov   eax, [esi+870h]   ; ESI and EAX</code></strong>
 <strong class="userinput"><code>are pointing to the →</code></strong>
                                                <strong class="userinput"><code>input data</code></strong>
<strong class="userinput"><code>.text:00010DEC        mov   [ebp+var_48], eax ; a pointer to user controlled data →</code></strong>
                                                <strong class="userinput"><code>is stored in var_48</code></strong>
<strong class="userinput"><code>.text:00010DEF        cmp   dword ptr [eax], 0D0DEAD07h  ; validation of input data</code></strong>
.text:00010DF5        jnz   short loc_10E00
[..]
<strong class="userinput"><code>.text:00010DF7        cmp   dword ptr [eax+4], 10BAD0BAh ; validation of input data</code></strong>
.text:00010DFE        jz    short loc_10E06
[..]</pre><p>The code at address <code class="literal">.text:00010DE2</code> checks whether the input data equals NULL. If the input data is not NULL, a pointer from this data is extracted at <code class="literal">[user_data+0x870]</code> and stored in <code class="literal">EAX</code> (see <code class="literal">.text:00010DE6</code>). This pointer value is stored in the stack variable <code class="literal">var_48</code> (see <code class="literal">.text:00010DEC</code>). A check is then performed to see if the data, pointed to by <code class="literal">EAX</code>, starts with the values <code class="literal">0xD0DEAD07</code> and <code class="literal">0x10BAD0BA</code> (see <code class="literal">.text:00010DEF</code> and <code class="literal">.text:00010DF7</code>). If so, the parsing of the input data continues:</p><a id="I_programlisting6_d1e7010"/><pre class="programlisting">[..]
.text:00010E06 loc_10E06:                              ; CODE XREF: sub_1098C+472
.text:00010E06                 xor     edx, edx
.text:00010E08                 mov     eax, [ebp+var_48]
.text:00010E0B                 mov     [eax], edx
.text:00010E0D                 mov     [eax+4], edx
<strong class="userinput"><code>.text:00010E10                 add     esi, 4         ; source address</code></strong>
<strong class="userinput"><code>.text:00010E13                 mov     ecx, 21Ah      ; length</code></strong>
<strong class="userinput"><code>.text:00010E18                 mov     edi, [eax+18h] ; destination address</code></strong>
<strong class="userinput"><code>.text:00010E1B                 rep movsd              ; memcpy()</code></strong>
[..]</pre><p>The <code class="literal">rep movsd</code> instruction at address <code class="literal">.text:00010E1B</code> represents a <code class="literal">memcpy()</code> function. So <code class="literal">ESI</code> holds the source address, <code class="literal">EDI</code> holds the destination address, and <code class="literal">ECX</code> holds the length for the copy operation. <code class="literal">ECX</code> gets assigned the value <code class="literal">0x21a</code> (see <code class="literal">.text:00010E13</code>). <code class="literal">ESI</code> points to the user-controlled IOCTL data (see <code class="literal">.text:00010E10</code>), and <code class="literal">EDI</code> is also derived from user-controlled data pointed to by <code class="literal">EAX</code> (see <code class="literal">.text:00010E18</code> and <a class="xref" href="ch06.html#graph_view_of_the_vulnerable_code_pa" title="Figure 6-5. Graph view of the vulnerable code path in IDA Pro, part 2">Figure 6-5</a>).</p><div class="figure"><a id="graph_view_of_the_vulnerable_code_pa"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e7075"/><img src="httpatomoreillycomsourcenostarchimages939313.png.jpg" alt="Graph view of the vulnerable code path in IDA Pro, part 2"/></div></div><p class="title">Figure 6-5. Graph view of the vulnerable code path in IDA Pro, part 2</p></div><p>Here’s some pseudo C code of that <code class="literal">memcpy()</code> call:</p><a id="I_programlisting6_d1e7085"/><pre class="programlisting">memcpy ([EAX+0x18], ESI + 4, 0x21a * 4);</pre><p>Or, in more abstract terms:</p><a id="I_programlisting6_d1e7089"/><pre class="programlisting">memcpy (user_controlled_address, user_controlled_data, 0x868);</pre><p>It is therefore possible to write <code class="literal">0x868</code> bytes (<code class="literal">0x21a * 4</code> bytes, as the <code class="literal">rep movsd</code> instruction copies DWORDs from one location to another) of user-controllable data to an arbitrary user-controlled address in either user or kernel space. Nice!<a id="IDX-CHP-6-0035" class="indexterm"/></p><p>The anatomy of the bug, diagrammed in <a class="xref" href="ch06.html#overview_of_the_vulnerability_from_ioctl" title="Figure 6-6. Overview of the vulnerability from IOCTL request to memory corruption">Figure 6-6</a>, is as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>An IOCTL request (<code class="literal">0xB2D60030</code>) is sent to the kernel driver <span class="emphasis"><em>Aavmker4.sys</em></span> using the <code class="literal">AavmKer4</code> device.</p></li><li class="listitem"><p>The driver code checks whether the IOCTL input data length equals the value <code class="literal">0x878</code>. If so, proceed to step 3.</p><div class="figure"><a id="overview_of_the_vulnerability_from_ioctl"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e7131"/><img src="httpatomoreillycomsourcenostarchimages939315.png.jpg" alt="Overview of the vulnerability from IOCTL request to memory corruption"/></div></div><p class="title">Figure 6-6. Overview of the vulnerability from IOCTL request to memory corruption</p></div></li><li class="listitem"><p>The driver checks whether the user-controlled IOCTL input data contains the values <code class="literal">0xD0DEAD07</code> and <code class="literal">0x10BAD0BA</code>. If so, proceed to step 4.</p></li><li class="listitem"><p>The erroneous <code class="literal">memcpy()</code> call is executed.</p></li><li class="listitem"><p>The memory is corrupted.</p></li></ol></div></div></div></div></body></html>
