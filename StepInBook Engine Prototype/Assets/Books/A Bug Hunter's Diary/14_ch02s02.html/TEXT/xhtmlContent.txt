<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>2.2 Exploitation</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="2.2 Exploitation"><div class="titlepage"><div><div><h1 class="title"><a id="exploitation"/>2.2 Exploitation</h1></div></div></div><p>To exploit the vulnerability, I performed the following steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: Find a sample TiVo movie file.</p></li><li class="listitem"><p>Step 2: Find a code path to reach the vulnerable code.</p></li><li class="listitem"><p>Step 3: Manipulate the TiVo movie file to crash VLC.</p></li><li class="listitem"><p>Step 4: Manipulate the TiVo movie file to gain control of <code class="literal">EIP</code>.</p></li></ul></div><div class="figure"><a id="overview_of_the_vulnerability_from_input"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e893"/><img src="httpatomoreillycomsourcenostarchimages939231.png.jpg" alt="Overview of the vulnerability from input to stack buffer overflow"/></div></div><p class="title">Figure 2-2. Overview of the vulnerability from input to stack buffer overflow</p></div><p>There’s more than one way to exploit a file-format bug. You can create a file with the right format from scratch, or you can manipulate a valid preexisting file. I chose the latter in this example.</p><div class="sect2" title="Step 1: Find a Sample TiVo Movie File"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_find_a_sample_tivo_movie_fi"/>Step 1: Find a Sample TiVo Movie File</h2></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>The website</em></span> <a class="ulink" href="http://samples.mplayerhq.hu/">http://samples.mplayerhq.hu/</a> <span class="emphasis"><em>is a good starting point to search for all kinds of multimedia file-format samples</em></span></p></div><p>First I downloaded the following TiVo sample file from <a class="ulink" href="http://samples.mplayerhq.hu/">http://samples.mplayerhq.hu/</a>:</p><a id="I_programlisting2_d1e916"/><pre class="programlisting"><strong class="userinput"><code>$ wget http://samples.mplayerhq.hu/TiVo/test-dtivo-junkskip.ty%2b</code></strong>
--2008-10-12 21:12:25--  http://samples.mplayerhq.hu/TiVo/test-dtivo-junkskip.ty%2b
Resolving samples.mplayerhq.hu... 213.144.138.186
Connecting to samples.mplayerhq.hu|213.144.138.186|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 5242880 (5.0M) [text/plain]
Saving to: `test-dtivo-junkskip.ty+'

100%[=========================&gt;] 5,242,880    240K/s   in 22s

2008-10-12 21:12:48 (232 KB/s) - `test-dtivo-junkskip.ty+' saved [5242880/5242880]</pre></div><div class="sect2" title="Step 2: Find a Code Path to Reach the Vulnerable Code"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_find_a_code_path_to_reach_t"/>Step 2: Find a Code Path to Reach the Vulnerable Code</h2></div></div></div><p>I couldn’t find documentation on the specifications of the TiVo file format, so I read the source code in order to find a path to reach the vulnerable code in <code class="literal">parse_master()</code>.</p><p>If a TiVo file is loaded by VLC, the following execution flow is taken (all source code references are from <span class="emphasis"><em>vlc-0.9.4\modules\demux\Ty.c</em></span> of VLC). The first relevant function that’s called is <code class="literal">Demux()</code>:</p><a id="I_programlisting2_d1e936"/><pre class="programlisting">[..]
<strong class="userinput"><code>386    static int Demux( demux_t *p_demux )</code></strong>
387    {
388        demux_sys_t  *p_sys = p_demux-&gt;p_sys;
389        ty_rec_hdr_t *p_rec;
390        block_t      *p_block_in = NULL;
391
392        /*msg_Dbg(p_demux, "ty demux processing" );*/
393
394        /* did we hit EOF earlier? */
395        if( p_sys-&gt;eof )
396            return 0;
397
398        /*
399         * what we do (1 record now.. maybe more later):
400         * - use stream_Read() to read the chunk header &amp; record headers
401         * - discard entire chunk if it is a PART header chunk
402         * - parse all the headers into record header array
403         * - keep a pointer of which record we're on
404         * - use stream_Block() to fetch each record
405         * - parse out PTS from PES headers
406         * - set PTS for data packets
407         * - pass the data on to the proper codec via es_out_Send()
408
409         * if this is the first time or
410         * if we're at the end of this chunk, start a new one
411         */
412        /* parse the next chunk's record headers */
413        if( p_sys-&gt;b_first_chunk || p_sys-&gt;i_cur_rec &gt;= p_sys-&gt;i_num_recs )
414        {
<strong class="userinput"><code>415               if( get_chunk_header(p_demux) == 0 )</code></strong>
[..]</pre><p>After some sanity checks in lines 395 and 413, the function <code class="literal">get_chunk_header()</code> is called in line 415.</p><a id="I_programlisting2_d1e949"/><pre class="programlisting">[..]
 <strong class="userinput"><code>112    #define TIVO_PES_FILEID   ( 0xf5467abd )</code></strong>
[..]
1839    static int get_chunk_header(demux_t *p_demux)
1840    {
1841        int i_readSize, i_num_recs;
1842        uint8_t *p_hdr_buf;
1843        const uint8_t *p_peek;
1844        demux_sys_t *p_sys = p_demux-&gt;p_sys;
1845        int i_payload_size;                /* sum of all records' sizes */
1846
1847        msg_Dbg(p_demux, "parsing ty chunk #%d", p_sys-&gt;i_cur_chunk );
1848
1849        /* if we have left-over filler space from the last chunk, get that */
1850        if (p_sys-&gt;i_stuff_cnt &gt; 0) {
1851            stream_Read( p_demux-&gt;s, NULL, p_sys-&gt;i_stuff_cnt);
1852            p_sys-&gt;i_stuff_cnt = 0;
1853        }
1854
1855        /* read the TY packet header */
<strong class="userinput"><code>1856        i_readSize = stream_Peek( p_demux-&gt;s, &amp;p_peek, 4 );</code></strong>
1857        p_sys-&gt;i_cur_chunk++;
1858
1859        if ( (i_readSize &lt; 4) || ( U32_AT(&amp;p_peek[ 0 ] ) == 0 ))
1860        {
1861            /* EOF */
1862            p_sys-&gt;eof = 1;
1863            return 0;
1864        }
1865
1866        /* check if it's a PART Header */
<strong class="userinput"><code>1867        if( U32_AT( &amp;p_peek[ 0 ] ) == TIVO_PES_FILEID )</code></strong>
1868        {
1869            /* parse master chunk */
<strong class="userinput"><code>1870            parse_master(p_demux);</code></strong>
1871            return get_chunk_header(p_demux);
1872        }
[..]</pre><p>In line 1856 of <code class="literal">get_chunk_header()</code>, the user-controlled data from the TiVo file is assigned to the pointer <code class="literal">p_peek</code>. Then, in line 1867, the process checks whether the file data pointed to by <code class="literal">p_peek</code> equals <code class="literal">TIVO_PES_FILEID</code> (which is defined as <code class="literal">0xf5467abd</code> in line 112). If so, the vulnerable function <code class="literal">parse_master()</code> gets called (see line 1870).</p><p>To reach the vulnerable function using this code path, the TiVo sample file had to contain the value of <code class="literal">TIVO_PES_FILEID</code>. I searched the TiVo sample file for the <code class="literal">TIVO_PES_FILEID</code> pattern and found it at file offset <code class="literal">0x00300000</code> (see <a class="xref" href="ch02s02.html#tivo_underscore_pes_underscore_fileid_pa" title="Figure 2-3. TIVO_PES_FILEID pattern in TiVo sample file">Figure 2-3</a>).</p><div class="figure"><a id="tivo_underscore_pes_underscore_fileid_pa"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1002"/><img src="httpatomoreillycomsourcenostarchimages939233.png.jpg" alt="TIVO_PES_FILEID pattern in TiVo sample file"/></div></div><p class="title">Figure 2-3. <code class="literal">TIVO_PES_FILEID</code> pattern in TiVo sample file</p></div><p>Based on the information from the <code class="literal">parse_master()</code> function (see the following source code snippet) the value of <code class="literal">i_map_size</code> should be found at offset 20 (<code class="literal">0x14</code>) relative to the <code class="literal">TIVO_PES_FILEID</code> pattern found at file offset <code class="literal">0x00300000</code>.</p><a id="I_programlisting2_d1e1024"/><pre class="programlisting">[..]
1641     stream_Read(p_demux-&gt;s, mst_buf, 32);
1642     i_map_size = U32_AT(&amp;mst_buf[<strong class="userinput"><code>20</code></strong>]);  /* size of bitmask, in bytes */
[..]</pre><p>At this point, I had discovered that the TiVo sample file I downloaded already triggers the vulnerable <code class="literal">parse_master()</code> function, so it wouldn’t be necessary to adjust the sample file. Great!</p></div><div class="sect2" title="Step 3: Manipulate the TiVo Movie File to Crash VLC"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_manipulate_the_tivo_movie_f"/>Step 3: Manipulate the TiVo Movie File to Crash VLC</h2></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Get the vulnerable Windows version of VLC from</em></span> <a class="ulink" href="http://download.videolan.org/pub/videolan/vlc/0.9.4/win32/">http://download.videolan.org/pub/videolan/vlc/0.9.4/win32/</a>.</p></div><p>Next, I tried to manipulate the TiVo sample file in order to crash VLC. To achieve this, all I had to do was change the 4-byte value at the sample file offset of <code class="literal">i_map_size</code> (which was <code class="literal">0x00300014</code> in this example).</p><p>As illustrated in <a class="xref" href="ch02s02.html#new_value_for_i_underscore_map_underscor" title="Figure 2-4. New value for i_map_size in TiVo sample file">Figure 2-4</a>, I changed the 32-bit value at file offset <code class="literal">0x00300014</code> from <code class="literal">0x00000002</code> to <code class="literal">0x000000ff</code>. The new value of 255 bytes (<code class="literal">0xff</code>) should be enough to overflow the 32-byte stack buffer and to overwrite the return address stored after the buffer on the stack (see Section A.1). Next, I opened the altered sample file with VLC while debugging the media player with Immunity Debugger.<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-3" class="footnoteref">8</a>]</sup> The movie file was played as before, but after a few seconds—as soon as the altered file data was processed—the VLC player crashed, with the result shown in <a class="xref" href="ch02s02.html#vlc_access_violation_in_immunity_debugge" title="Figure 2-5. VLC access violation in Immunity Debugger">Figure 2-5</a>.<a id="IDX-CHP-2-0008" class="indexterm"/><a id="IDX-CHP-2-0009" class="indexterm"/></p><div class="figure"><a id="new_value_for_i_underscore_map_underscor"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1088"/><img src="httpatomoreillycomsourcenostarchimages939235.png.jpg" alt="New value for i_map_size in TiVo sample file"/></div></div><p class="title">Figure 2-4. New value for <code class="literal">i_map_size</code> in TiVo sample file</p></div><div class="figure"><a id="vlc_access_violation_in_immunity_debugge"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1096"/><img src="httpatomoreillycomsourcenostarchimages939237.png.jpg" alt="VLC access violation in Immunity Debugger"/></div></div><p class="title">Figure 2-5. VLC access violation in Immunity Debugger</p></div><p>As expected, VLC crashed while parsing the malformed TiVo file. The crash was very promising, since the instruction pointer (<code class="literal">EIP</code> register) was pointing to an invalid memory location (indicated by the message <code class="literal">Access violation when executing [20030000]</code> in the status bar of the debugger). This might mean that I could easily gain control of the instruction pointer.</p></div><div class="sect2" title="Step 4: Manipulate the TiVo Movie File to Gain Control of EIP"><div class="titlepage"><div><div><h2 class="title"><a id="step_4_colon_manipulate_the_tivo_movie_f"/>Step 4: Manipulate the TiVo Movie File to Gain Control of EIP</h2></div></div></div><p>My next step was to determine which bytes of the sample file actually overwrote the return address of the current stack frame so that I could take control of <code class="literal">EIP</code>. The debugger stated that <code class="literal">EIP</code> had a value of <code class="literal">0x20030000</code> at the time of the crash. To determine which offset this value is found at, I could try to calculate the exact file offset, or I could simply search the file for the byte pattern. I chose the latter approach and started from file offset <code class="literal">0x00300000</code>. I found the desired byte sequence at file offset <code class="literal">0x0030005c</code>, represented in little-endian notation, and I changed the 4 bytes to the value <code class="literal">0x41414141</code> (as illustrated in <a class="xref" href="ch02s02.html#new_value_for_eip_in_tivo_sample_file" title="Figure 2-6. New value for EIP in TiVo sample file">Figure 2-6</a>).<a id="IDX-CHP-2-0010" class="indexterm"/></p><div class="figure"><a id="new_value_for_eip_in_tivo_sample_file"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1144"/><img src="httpatomoreillycomsourcenostarchimages939239.png.jpg" alt="New value for EIP in TiVo sample file"/></div></div><p class="title">Figure 2-6. New value for <code class="literal">EIP</code> in TiVo sample file</p></div><p>I then restarted VLC in the debugger and opened the new file (see <a class="xref" href="ch02s02.html#eip_control_of_vlc_media_player" title="Figure 2-7. EIP control of VLC media player">Figure 2-7</a>).</p><div class="figure"><a id="eip_control_of_vlc_media_player"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1158"/><img src="httpatomoreillycomsourcenostarchimages939241.png.jpg" alt="EIP control of VLC media player"/></div></div><p class="title">Figure 2-7. <code class="literal">EIP</code> control of VLC media player</p></div><p><code class="literal">EIP = 41414141</code> . . . Mission <code class="literal">EIP</code> control accomplished! I was able to build a working exploit, intended to achieve arbitrary code execution, using the well-known <code class="literal">jmp reg</code> technique, as described in “Variations in Exploit Methods Between Linux and Windows” by David Litchfield.<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-4" class="footnoteref">9</a>]</sup><a id="IDX-CHP-2-0011" class="indexterm"/><a id="IDX-CHP-2-0012" class="indexterm"/><a id="IDX-CHP-2-0013" class="indexterm"/><a id="IDX-CHP-2-0014" class="indexterm"/><a id="IDX-CHP-2-0015" class="indexterm"/><a id="IDX-CHP-2-0016" class="indexterm"/><a id="IDX-CHP-2-0017" class="indexterm"/><a id="IDX-CHP-2-0018" class="indexterm"/><a id="IDX-CHP-2-0019" class="indexterm"/></p><p>Since Germany has strict laws against it, I will not provide you with a full working exploit, but if you’re interested, you can watch a short video I recorded that shows the exploit in action.<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-5" class="footnoteref">10</a>]</sup></p></div></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>2.2 Exploitation</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="2.2 Exploitation"><div class="titlepage"><div><div><h1 class="title"><a id="exploitation"/>2.2 Exploitation</h1></div></div></div><p>To exploit the vulnerability, I performed the following steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: Find a sample TiVo movie file.</p></li><li class="listitem"><p>Step 2: Find a code path to reach the vulnerable code.</p></li><li class="listitem"><p>Step 3: Manipulate the TiVo movie file to crash VLC.</p></li><li class="listitem"><p>Step 4: Manipulate the TiVo movie file to gain control of <code class="literal">EIP</code>.</p></li></ul></div><div class="figure"><a id="overview_of_the_vulnerability_from_input"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e893"/><img src="httpatomoreillycomsourcenostarchimages939231.png.jpg" alt="Overview of the vulnerability from input to stack buffer overflow"/></div></div><p class="title">Figure 2-2. Overview of the vulnerability from input to stack buffer overflow</p></div><p>There’s more than one way to exploit a file-format bug. You can create a file with the right format from scratch, or you can manipulate a valid preexisting file. I chose the latter in this example.</p><div class="sect2" title="Step 1: Find a Sample TiVo Movie File"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_find_a_sample_tivo_movie_fi"/>Step 1: Find a Sample TiVo Movie File</h2></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>The website</em></span> <a class="ulink" href="http://samples.mplayerhq.hu/">http://samples.mplayerhq.hu/</a> <span class="emphasis"><em>is a good starting point to search for all kinds of multimedia file-format samples</em></span></p></div><p>First I downloaded the following TiVo sample file from <a class="ulink" href="http://samples.mplayerhq.hu/">http://samples.mplayerhq.hu/</a>:</p><a id="I_programlisting2_d1e916"/><pre class="programlisting"><strong class="userinput"><code>$ wget http://samples.mplayerhq.hu/TiVo/test-dtivo-junkskip.ty%2b</code></strong>
--2008-10-12 21:12:25--  http://samples.mplayerhq.hu/TiVo/test-dtivo-junkskip.ty%2b
Resolving samples.mplayerhq.hu... 213.144.138.186
Connecting to samples.mplayerhq.hu|213.144.138.186|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 5242880 (5.0M) [text/plain]
Saving to: `test-dtivo-junkskip.ty+'

100%[=========================&gt;] 5,242,880    240K/s   in 22s

2008-10-12 21:12:48 (232 KB/s) - `test-dtivo-junkskip.ty+' saved [5242880/5242880]</pre></div><div class="sect2" title="Step 2: Find a Code Path to Reach the Vulnerable Code"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_find_a_code_path_to_reach_t"/>Step 2: Find a Code Path to Reach the Vulnerable Code</h2></div></div></div><p>I couldn’t find documentation on the specifications of the TiVo file format, so I read the source code in order to find a path to reach the vulnerable code in <code class="literal">parse_master()</code>.</p><p>If a TiVo file is loaded by VLC, the following execution flow is taken (all source code references are from <span class="emphasis"><em>vlc-0.9.4\modules\demux\Ty.c</em></span> of VLC). The first relevant function that’s called is <code class="literal">Demux()</code>:</p><a id="I_programlisting2_d1e936"/><pre class="programlisting">[..]
<strong class="userinput"><code>386    static int Demux( demux_t *p_demux )</code></strong>
387    {
388        demux_sys_t  *p_sys = p_demux-&gt;p_sys;
389        ty_rec_hdr_t *p_rec;
390        block_t      *p_block_in = NULL;
391
392        /*msg_Dbg(p_demux, "ty demux processing" );*/
393
394        /* did we hit EOF earlier? */
395        if( p_sys-&gt;eof )
396            return 0;
397
398        /*
399         * what we do (1 record now.. maybe more later):
400         * - use stream_Read() to read the chunk header &amp; record headers
401         * - discard entire chunk if it is a PART header chunk
402         * - parse all the headers into record header array
403         * - keep a pointer of which record we're on
404         * - use stream_Block() to fetch each record
405         * - parse out PTS from PES headers
406         * - set PTS for data packets
407         * - pass the data on to the proper codec via es_out_Send()
408
409         * if this is the first time or
410         * if we're at the end of this chunk, start a new one
411         */
412        /* parse the next chunk's record headers */
413        if( p_sys-&gt;b_first_chunk || p_sys-&gt;i_cur_rec &gt;= p_sys-&gt;i_num_recs )
414        {
<strong class="userinput"><code>415               if( get_chunk_header(p_demux) == 0 )</code></strong>
[..]</pre><p>After some sanity checks in lines 395 and 413, the function <code class="literal">get_chunk_header()</code> is called in line 415.</p><a id="I_programlisting2_d1e949"/><pre class="programlisting">[..]
 <strong class="userinput"><code>112    #define TIVO_PES_FILEID   ( 0xf5467abd )</code></strong>
[..]
1839    static int get_chunk_header(demux_t *p_demux)
1840    {
1841        int i_readSize, i_num_recs;
1842        uint8_t *p_hdr_buf;
1843        const uint8_t *p_peek;
1844        demux_sys_t *p_sys = p_demux-&gt;p_sys;
1845        int i_payload_size;                /* sum of all records' sizes */
1846
1847        msg_Dbg(p_demux, "parsing ty chunk #%d", p_sys-&gt;i_cur_chunk );
1848
1849        /* if we have left-over filler space from the last chunk, get that */
1850        if (p_sys-&gt;i_stuff_cnt &gt; 0) {
1851            stream_Read( p_demux-&gt;s, NULL, p_sys-&gt;i_stuff_cnt);
1852            p_sys-&gt;i_stuff_cnt = 0;
1853        }
1854
1855        /* read the TY packet header */
<strong class="userinput"><code>1856        i_readSize = stream_Peek( p_demux-&gt;s, &amp;p_peek, 4 );</code></strong>
1857        p_sys-&gt;i_cur_chunk++;
1858
1859        if ( (i_readSize &lt; 4) || ( U32_AT(&amp;p_peek[ 0 ] ) == 0 ))
1860        {
1861            /* EOF */
1862            p_sys-&gt;eof = 1;
1863            return 0;
1864        }
1865
1866        /* check if it's a PART Header */
<strong class="userinput"><code>1867        if( U32_AT( &amp;p_peek[ 0 ] ) == TIVO_PES_FILEID )</code></strong>
1868        {
1869            /* parse master chunk */
<strong class="userinput"><code>1870            parse_master(p_demux);</code></strong>
1871            return get_chunk_header(p_demux);
1872        }
[..]</pre><p>In line 1856 of <code class="literal">get_chunk_header()</code>, the user-controlled data from the TiVo file is assigned to the pointer <code class="literal">p_peek</code>. Then, in line 1867, the process checks whether the file data pointed to by <code class="literal">p_peek</code> equals <code class="literal">TIVO_PES_FILEID</code> (which is defined as <code class="literal">0xf5467abd</code> in line 112). If so, the vulnerable function <code class="literal">parse_master()</code> gets called (see line 1870).</p><p>To reach the vulnerable function using this code path, the TiVo sample file had to contain the value of <code class="literal">TIVO_PES_FILEID</code>. I searched the TiVo sample file for the <code class="literal">TIVO_PES_FILEID</code> pattern and found it at file offset <code class="literal">0x00300000</code> (see <a class="xref" href="ch02s02.html#tivo_underscore_pes_underscore_fileid_pa" title="Figure 2-3. TIVO_PES_FILEID pattern in TiVo sample file">Figure 2-3</a>).</p><div class="figure"><a id="tivo_underscore_pes_underscore_fileid_pa"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1002"/><img src="httpatomoreillycomsourcenostarchimages939233.png.jpg" alt="TIVO_PES_FILEID pattern in TiVo sample file"/></div></div><p class="title">Figure 2-3. <code class="literal">TIVO_PES_FILEID</code> pattern in TiVo sample file</p></div><p>Based on the information from the <code class="literal">parse_master()</code> function (see the following source code snippet) the value of <code class="literal">i_map_size</code> should be found at offset 20 (<code class="literal">0x14</code>) relative to the <code class="literal">TIVO_PES_FILEID</code> pattern found at file offset <code class="literal">0x00300000</code>.</p><a id="I_programlisting2_d1e1024"/><pre class="programlisting">[..]
1641     stream_Read(p_demux-&gt;s, mst_buf, 32);
1642     i_map_size = U32_AT(&amp;mst_buf[<strong class="userinput"><code>20</code></strong>]);  /* size of bitmask, in bytes */
[..]</pre><p>At this point, I had discovered that the TiVo sample file I downloaded already triggers the vulnerable <code class="literal">parse_master()</code> function, so it wouldn’t be necessary to adjust the sample file. Great!</p></div><div class="sect2" title="Step 3: Manipulate the TiVo Movie File to Crash VLC"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_manipulate_the_tivo_movie_f"/>Step 3: Manipulate the TiVo Movie File to Crash VLC</h2></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Get the vulnerable Windows version of VLC from</em></span> <a class="ulink" href="http://download.videolan.org/pub/videolan/vlc/0.9.4/win32/">http://download.videolan.org/pub/videolan/vlc/0.9.4/win32/</a>.</p></div><p>Next, I tried to manipulate the TiVo sample file in order to crash VLC. To achieve this, all I had to do was change the 4-byte value at the sample file offset of <code class="literal">i_map_size</code> (which was <code class="literal">0x00300014</code> in this example).</p><p>As illustrated in <a class="xref" href="ch02s02.html#new_value_for_i_underscore_map_underscor" title="Figure 2-4. New value for i_map_size in TiVo sample file">Figure 2-4</a>, I changed the 32-bit value at file offset <code class="literal">0x00300014</code> from <code class="literal">0x00000002</code> to <code class="literal">0x000000ff</code>. The new value of 255 bytes (<code class="literal">0xff</code>) should be enough to overflow the 32-byte stack buffer and to overwrite the return address stored after the buffer on the stack (see Section A.1). Next, I opened the altered sample file with VLC while debugging the media player with Immunity Debugger.<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-3" class="footnoteref">8</a>]</sup> The movie file was played as before, but after a few seconds—as soon as the altered file data was processed—the VLC player crashed, with the result shown in <a class="xref" href="ch02s02.html#vlc_access_violation_in_immunity_debugge" title="Figure 2-5. VLC access violation in Immunity Debugger">Figure 2-5</a>.<a id="IDX-CHP-2-0008" class="indexterm"/><a id="IDX-CHP-2-0009" class="indexterm"/></p><div class="figure"><a id="new_value_for_i_underscore_map_underscor"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1088"/><img src="httpatomoreillycomsourcenostarchimages939235.png.jpg" alt="New value for i_map_size in TiVo sample file"/></div></div><p class="title">Figure 2-4. New value for <code class="literal">i_map_size</code> in TiVo sample file</p></div><div class="figure"><a id="vlc_access_violation_in_immunity_debugge"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1096"/><img src="httpatomoreillycomsourcenostarchimages939237.png.jpg" alt="VLC access violation in Immunity Debugger"/></div></div><p class="title">Figure 2-5. VLC access violation in Immunity Debugger</p></div><p>As expected, VLC crashed while parsing the malformed TiVo file. The crash was very promising, since the instruction pointer (<code class="literal">EIP</code> register) was pointing to an invalid memory location (indicated by the message <code class="literal">Access violation when executing [20030000]</code> in the status bar of the debugger). This might mean that I could easily gain control of the instruction pointer.</p></div><div class="sect2" title="Step 4: Manipulate the TiVo Movie File to Gain Control of EIP"><div class="titlepage"><div><div><h2 class="title"><a id="step_4_colon_manipulate_the_tivo_movie_f"/>Step 4: Manipulate the TiVo Movie File to Gain Control of EIP</h2></div></div></div><p>My next step was to determine which bytes of the sample file actually overwrote the return address of the current stack frame so that I could take control of <code class="literal">EIP</code>. The debugger stated that <code class="literal">EIP</code> had a value of <code class="literal">0x20030000</code> at the time of the crash. To determine which offset this value is found at, I could try to calculate the exact file offset, or I could simply search the file for the byte pattern. I chose the latter approach and started from file offset <code class="literal">0x00300000</code>. I found the desired byte sequence at file offset <code class="literal">0x0030005c</code>, represented in little-endian notation, and I changed the 4 bytes to the value <code class="literal">0x41414141</code> (as illustrated in <a class="xref" href="ch02s02.html#new_value_for_eip_in_tivo_sample_file" title="Figure 2-6. New value for EIP in TiVo sample file">Figure 2-6</a>).<a id="IDX-CHP-2-0010" class="indexterm"/></p><div class="figure"><a id="new_value_for_eip_in_tivo_sample_file"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1144"/><img src="httpatomoreillycomsourcenostarchimages939239.png.jpg" alt="New value for EIP in TiVo sample file"/></div></div><p class="title">Figure 2-6. New value for <code class="literal">EIP</code> in TiVo sample file</p></div><p>I then restarted VLC in the debugger and opened the new file (see <a class="xref" href="ch02s02.html#eip_control_of_vlc_media_player" title="Figure 2-7. EIP control of VLC media player">Figure 2-7</a>).</p><div class="figure"><a id="eip_control_of_vlc_media_player"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1158"/><img src="httpatomoreillycomsourcenostarchimages939241.png.jpg" alt="EIP control of VLC media player"/></div></div><p class="title">Figure 2-7. <code class="literal">EIP</code> control of VLC media player</p></div><p><code class="literal">EIP = 41414141</code> . . . Mission <code class="literal">EIP</code> control accomplished! I was able to build a working exploit, intended to achieve arbitrary code execution, using the well-known <code class="literal">jmp reg</code> technique, as described in “Variations in Exploit Methods Between Linux and Windows” by David Litchfield.<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-4" class="footnoteref">9</a>]</sup><a id="IDX-CHP-2-0011" class="indexterm"/><a id="IDX-CHP-2-0012" class="indexterm"/><a id="IDX-CHP-2-0013" class="indexterm"/><a id="IDX-CHP-2-0014" class="indexterm"/><a id="IDX-CHP-2-0015" class="indexterm"/><a id="IDX-CHP-2-0016" class="indexterm"/><a id="IDX-CHP-2-0017" class="indexterm"/><a id="IDX-CHP-2-0018" class="indexterm"/><a id="IDX-CHP-2-0019" class="indexterm"/></p><p>Since Germany has strict laws against it, I will not provide you with a full working exploit, but if you’re interested, you can watch a short video I recorded that shows the exploit in action.<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-5" class="footnoteref">10</a>]</sup></p></div></div></body></html>
