<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>5.2 Exploitation</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="5.2 Exploitation"><div class="titlepage"><div><div><h1 class="title"><a id="exploitation-id3"/>5.2 Exploitation</h1></div></div></div><p>After I found the vulnerability, exploitation was easy. All I had to do was tweak the length of the string argument supplied to <code class="literal">NewObject()</code> to overflow the stack buffer and gain control of the return address of the current stack frame.</p><p>As illustrated in <a class="xref" href="ch05.html#determining_the_size_of_the_subkey_stack" title="Figure 5-9. Determining the size of the SubKey stack buffer using IDA Pro’s default stack frame displays">Figure 5-9</a>, the distance from the <code class="literal">SubKey</code> buffer to the saved return address on the stack is 272 bytes (the offset of the saved return address (<code class="literal">+00000004</code>) minus the offset of <code class="literal">SubKey</code> (<code class="literal">−0000010C</code>): <code class="literal">0x4 - −0x10c = 0x110</code> (272)). I also had to account for the fact that the string “<code class="literal">Authoring</code>” and part of the format string will be copied into <code class="literal">SubKey</code> right before the user-controlled data (see <a class="xref" href="ch05.html#diagram_of_the_stack_buffer_overflow_tha" title="Figure 5-10. Diagram of the stack buffer overflow that occurs when an overly long string is passed to NewObject()">Figure 5-10</a>). All in all I had to subtract 40 bytes (“<code class="literal">SOFTWARE\Webex\UCF\Components\Authoring\</code>”) from the distance between <code class="literal">SubKey</code> and the saved return address (272 – 40 = 232). So I had to provide 232 bytes of dummy data to fill the stack and reach the saved return address. The following 4 bytes of the user-controlled data should then overwrite the value of the saved return address on the stack.</p><p>So I changed the number of supplied characters in line 6 of <span class="emphasis"><em>webex_poc1.html</em></span> and named the new file <span class="emphasis"><em>webex_poc2.html</em></span> (see <a class="xref" href="ch05s02.html#html_file_that_passes_an_overly" title="Example 5-5. HTML file that passes an overly long string to the NewObject() method (webex_poc2.html)">Example 5-5</a>):</p><div class="example"><a id="html_file_that_passes_an_overly"/><p class="title">Example 5-5. HTML file that passes an overly long string to the <code class="literal">NewObject()</code> method (<span class="emphasis"><em>webex_poc2.html</em></span>)</p><div class="example-contents"><pre class="programlisting">01    &lt;html&gt;
02     &lt;title&gt;WebEx PoC 2&lt;/title&gt;
03     &lt;body&gt;
04      &lt;object classid="clsid:32E26FD9-F435-4A20-A561-35D4B987CFDC"
 id="obj"&gt;&lt;/object&gt;
05      &lt;script language='vbscript'&gt;
<strong class="userinput"><code>06         arg = String(232, "A") + String(4, "B")</code></strong>
07         obj.NewObject arg
08      &lt;/script&gt;
09     &lt;/body&gt;
10    &lt;/html&gt;</pre></div></div><p>Then, I adjusted the little Python web server to serve the new HTML file.<a id="IDX-CHP-5-0019" class="indexterm"/><a id="IDX-CHP-5-0020" class="indexterm"/></p><p>The original <span class="emphasis"><em>wwwserv.py</em></span>:</p><a id="I_programlisting5_d1e5866"/><pre class="programlisting">09            f = open(curdir + sep + "<strong class="userinput"><code>webex_poc1.html</code></strong>")</pre><p>The adjusted <span class="emphasis"><em>wwwserv.py</em></span>:</p><a id="I_programlisting5_d1e5876"/><pre class="programlisting">09            f = open(curdir + sep + "<strong class="userinput"><code>webex_poc2.html</code></strong>")</pre><p>I restarted the web server, loaded Internet Explorer in WinDbg, and navigated to <a class="ulink" href="http://www.webex.com/">http://www.webex.com/</a> again.</p><p>As illustrated in <a class="xref" href="ch05s02.html#eip_control_of_internet_explorer" title="Figure 5-11. EIP control of Internet Explorer">Figure 5-11</a>, I now had full control over <code class="literal">EIP</code>. The bug could be easily exploited for arbitrary code execution using the well-known heap spraying technique.</p><div class="figure"><a id="eip_control_of_internet_explorer"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5898"/><img src="httpatomoreillycomsourcenostarchimages939301.png.jpg" alt="EIP control of Internet Explorer"/></div></div><p class="title">Figure 5-11. <code class="literal">EIP</code> control of Internet Explorer</p></div><p>As usual, German laws prevent me from providing a full working exploit, but if you’re interested, you can watch a short video I recorded that shows the exploit in action on the book’s website.<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-9" class="footnoteref">53</a>]</sup><a id="IDX-CHP-5-0021" class="indexterm"/><a id="IDX-CHP-5-0022" class="indexterm"/><a id="IDX-CHP-5-0023" class="indexterm"/><a id="IDX-CHP-5-0024" class="indexterm"/><a id="IDX-CHP-5-0025" class="indexterm"/></p><p>As I mentioned before, I could have found the bug much faster if I had fuzzed the ActiveX control with COMRaider instead of reading the assembly. But hey, fuzzing is not as cool as reading assembly, right?</p></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>5.2 Exploitation</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="5.2 Exploitation"><div class="titlepage"><div><div><h1 class="title"><a id="exploitation-id3"/>5.2 Exploitation</h1></div></div></div><p>After I found the vulnerability, exploitation was easy. All I had to do was tweak the length of the string argument supplied to <code class="literal">NewObject()</code> to overflow the stack buffer and gain control of the return address of the current stack frame.</p><p>As illustrated in <a class="xref" href="ch05.html#determining_the_size_of_the_subkey_stack" title="Figure 5-9. Determining the size of the SubKey stack buffer using IDA Pro’s default stack frame displays">Figure 5-9</a>, the distance from the <code class="literal">SubKey</code> buffer to the saved return address on the stack is 272 bytes (the offset of the saved return address (<code class="literal">+00000004</code>) minus the offset of <code class="literal">SubKey</code> (<code class="literal">−0000010C</code>): <code class="literal">0x4 - −0x10c = 0x110</code> (272)). I also had to account for the fact that the string “<code class="literal">Authoring</code>” and part of the format string will be copied into <code class="literal">SubKey</code> right before the user-controlled data (see <a class="xref" href="ch05.html#diagram_of_the_stack_buffer_overflow_tha" title="Figure 5-10. Diagram of the stack buffer overflow that occurs when an overly long string is passed to NewObject()">Figure 5-10</a>). All in all I had to subtract 40 bytes (“<code class="literal">SOFTWARE\Webex\UCF\Components\Authoring\</code>”) from the distance between <code class="literal">SubKey</code> and the saved return address (272 – 40 = 232). So I had to provide 232 bytes of dummy data to fill the stack and reach the saved return address. The following 4 bytes of the user-controlled data should then overwrite the value of the saved return address on the stack.</p><p>So I changed the number of supplied characters in line 6 of <span class="emphasis"><em>webex_poc1.html</em></span> and named the new file <span class="emphasis"><em>webex_poc2.html</em></span> (see <a class="xref" href="ch05s02.html#html_file_that_passes_an_overly" title="Example 5-5. HTML file that passes an overly long string to the NewObject() method (webex_poc2.html)">Example 5-5</a>):</p><div class="example"><a id="html_file_that_passes_an_overly"/><p class="title">Example 5-5. HTML file that passes an overly long string to the <code class="literal">NewObject()</code> method (<span class="emphasis"><em>webex_poc2.html</em></span>)</p><div class="example-contents"><pre class="programlisting">01    &lt;html&gt;
02     &lt;title&gt;WebEx PoC 2&lt;/title&gt;
03     &lt;body&gt;
04      &lt;object classid="clsid:32E26FD9-F435-4A20-A561-35D4B987CFDC"
 id="obj"&gt;&lt;/object&gt;
05      &lt;script language='vbscript'&gt;
<strong class="userinput"><code>06         arg = String(232, "A") + String(4, "B")</code></strong>
07         obj.NewObject arg
08      &lt;/script&gt;
09     &lt;/body&gt;
10    &lt;/html&gt;</pre></div></div><p>Then, I adjusted the little Python web server to serve the new HTML file.<a id="IDX-CHP-5-0019" class="indexterm"/><a id="IDX-CHP-5-0020" class="indexterm"/></p><p>The original <span class="emphasis"><em>wwwserv.py</em></span>:</p><a id="I_programlisting5_d1e5866"/><pre class="programlisting">09            f = open(curdir + sep + "<strong class="userinput"><code>webex_poc1.html</code></strong>")</pre><p>The adjusted <span class="emphasis"><em>wwwserv.py</em></span>:</p><a id="I_programlisting5_d1e5876"/><pre class="programlisting">09            f = open(curdir + sep + "<strong class="userinput"><code>webex_poc2.html</code></strong>")</pre><p>I restarted the web server, loaded Internet Explorer in WinDbg, and navigated to <a class="ulink" href="http://www.webex.com/">http://www.webex.com/</a> again.</p><p>As illustrated in <a class="xref" href="ch05s02.html#eip_control_of_internet_explorer" title="Figure 5-11. EIP control of Internet Explorer">Figure 5-11</a>, I now had full control over <code class="literal">EIP</code>. The bug could be easily exploited for arbitrary code execution using the well-known heap spraying technique.</p><div class="figure"><a id="eip_control_of_internet_explorer"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e5898"/><img src="httpatomoreillycomsourcenostarchimages939301.png.jpg" alt="EIP control of Internet Explorer"/></div></div><p class="title">Figure 5-11. <code class="literal">EIP</code> control of Internet Explorer</p></div><p>As usual, German laws prevent me from providing a full working exploit, but if you’re interested, you can watch a short video I recorded that shows the exploit in action on the book’s website.<sup>[<a href="ch05s05.html#ftn.CHP-5-FN-9" class="footnoteref">53</a>]</sup><a id="IDX-CHP-5-0021" class="indexterm"/><a id="IDX-CHP-5-0022" class="indexterm"/><a id="IDX-CHP-5-0023" class="indexterm"/><a id="IDX-CHP-5-0024" class="indexterm"/><a id="IDX-CHP-5-0025" class="indexterm"/></p><p>As I mentioned before, I could have found the bug much faster if I had fuzzed the ActiveX control with COMRaider instead of reading the assembly. But hey, fuzzing is not as cool as reading assembly, right?</p></div></body></html>
