<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 7. A Bug Older Than 4.4BSD</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="chapter" title="Chapter 7. A Bug Older Than 4.4BSD"><div class="titlepage"><div><div><h1 class="title"><a id="a_bug_older_than_4.4bsd"/>Chapter 7. A Bug Older Than 4.4BSD</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Saturday, March 3, 2007</em></span><a id="IDX-CHP-7-0001" class="indexterm"/><a id="IDX-CHP-7-0002" class="indexterm"/></p><p><span class="emphasis"><em>Dear Diary</em></span>,</p></div><p>Last week my Apple MacBook finally arrived. After getting acquainted with the Mac OS X platform, I decided to take a closer look at the XNU kernel of OS X. After a few hours of digging through the kernel code, I found a nice bug that occurs when the kernel tries to handle a special TTY IOCTL. The bug was easy to trigger, and I wrote a POC code that allows an unprivileged local user to crash the system via kernel panic. As usual, I then tried to develop an exploit to see if the bug allows arbitrary code execution. At this point, things got a bit more complicated. To develop the exploit code, I needed a way to debug the OS X kernel. That’s not a problem if you own two Macs, but I only had one: my brand-new MacBook.<a id="IDX-CHP-7-0003" class="indexterm"/><a id="IDX-CHP-7-0004" class="indexterm"/><a id="IDX-CHP-7-0005" class="indexterm"/><a id="IDX-CHP-7-0006" class="indexterm"/></p><div class="sect1" title="7.1 Vulnerability Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_discovery-id5"/>7.1 Vulnerability Discovery</h1></div></div></div><p>First I downloaded the latest source code release of the XNU kernel,<sup>[<a href="ch07s05.html#ftn.CHP-7-FN-1" class="footnoteref">75</a>]</sup> and then I searched for a vulnerability in the following way:</p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>I used an Intel Mac with OS X 10.4.8 and kernel version xnu-792.15.4.obj~4/ RELEASE_I386 as a platform throughout this chapter</em></span>.</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: List the IOCTLs of the kernel.</p></li><li class="listitem"><p>Step 2: Identify the input data.</p></li><li class="listitem"><p>Step 3: Trace the input data.</p></li></ul></div><p>These steps will be detailed in the following sections.</p><div class="sect2" title="Step 1: List the IOCTLs of the Kernel"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_list_the_ioctls_of_the"/>Step 1: List the IOCTLs of the Kernel</h2></div></div></div><p>To generate a list of the IOCTLs of the kernel, I simply searched the kernel source code for the usual IOCTL macros. Every IOCTL is assigned its own number, which is usually created by a macro. Depending on the IOCTL type, the XNU kernel of OS X defines the following macros: <code class="literal">_IOR</code>, <code class="literal">_IOW</code>, and <code class="literal">_IOWR</code>.</p><a id="I_programlisting7_d1e7671"/><pre class="programlisting">osx$ <strong class="userinput"><code>pwd</code></strong>
/Users/tk/xnu-792.13.8

osx$ <strong class="userinput"><code>grep -rnw -e _IOR -e _IOW -e _IOWR *</code></strong>
[..]
xnu-792.13.8/bsd/net/bpf.h:161:#define BIOCGRSIG        _IOR('B',114, u_int)
xnu-792.13.8/bsd/net/bpf.h:162:#define BIOCSRSIG        _IOW('B',115, u_int)
xnu-792.13.8/bsd/net/bpf.h:163:#define BIOCGHDRCMPLT    _IOR('B',116, u_int)
xnu-792.13.8/bsd/net/bpf.h:164:#define BIOCSHDRCMPLT    _IOW('B',117, u_int)
xnu-792.13.8/bsd/net/bpf.h:165:#define BIOCGSEESENT     _IOR('B',118, u_int)
xnu-792.13.8/bsd/net/bpf.h:166:#define BIOCSSEESENT     _IOW('B',119, u_int)
[..]</pre><p>I now had a list of IOCTLs supported by the XNU kernel. To find the source files that implement the IOCTLs, I searched the whole kernel source for each IOCTL name from the list. Here’s an example of the <code class="literal">BIOCGRSIG</code> IOCTL:</p><a id="I_programlisting7_d1e7684"/><pre class="programlisting">osx$ <strong class="userinput"><code>grep --include=*.c -rn BIOCGRSIG *</code></strong>
xnu-792.13.8/bsd/net/bpf.c:1143:        case BIOCGRSIG:</pre></div><div class="sect2" title="Step 2: Identify the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_identify_the_input_data-id3"/>Step 2: Identify the Input Data</h2></div></div></div><p>To identify the user-supplied input data of an IOCTL request, I took a look at some of the kernel functions that process the requests. I discovered that such functions typically expect an argument called <code class="literal">cmd</code> of type <code class="literal">u_long</code> and a second argument called <code class="literal">data</code> of type <code class="literal">caddr_t</code>.</p><p>Here are some examples:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>xnu-792.13.8/bsd/netat/at.c</em></span></p></dd></dl></div><a id="I_programlisting7_d1e7717"/><pre class="programlisting">[..]
135 int
136 at_control(so, <strong class="userinput"><code>cmd</code></strong>, <strong class="userinput"><code>data</code></strong>, ifp)
137      struct socket *so;
138      <strong class="userinput"><code>u_long cmd;</code></strong>
139      <strong class="userinput"><code>caddr_t data;</code></strong>
140      struct ifnet *ifp;
141 {
[..]</pre><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>xnu-792.13.8/bsd/net/if.c</em></span></p></dd></dl></div><a id="I_programlisting7_d1e7740"/><pre class="programlisting">[..]
1025 int
1026 ifioctl(so, <strong class="userinput"><code>cmd</code></strong>, <strong class="userinput"><code>data</code></strong>, p)
1027     struct socket *so;
1028     <strong class="userinput"><code>u_long cmd;</code></strong>
1029     <strong class="userinput"><code>caddr_t data;</code></strong>
1030     struct proc *p;
1031 {
[..]</pre><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>xnu-792.13.8/bsd/dev/vn/vn.c</em></span></p></dd></dl></div><a id="I_programlisting7_d1e7763"/><pre class="programlisting">[..]
877 static int
878 vnioctl(dev_t dev, <strong class="userinput"><code>u_long cmd</code></strong>, <strong class="userinput"><code>caddr_t data</code></strong>,
879     __unused int flag, struct proc *p,
880     int is_char)
881 {
[..]</pre><p>The names of these function arguments are quite descriptive: The <code class="literal">cmd</code> argument holds the requested IOCTL code, and the <code class="literal">data</code> argument holds the user-supplied IOCTL data.</p><p>On Mac OS X, an IOCTL request is typically sent to the kernel using the <code class="literal">ioctl()</code> system call. This system call has the following prototype:<a id="IDX-CHP-7-0007" class="indexterm"/><a id="IDX-CHP-7-0008" class="indexterm"/></p><a id="I_programlisting7_d1e7795"/><pre class="programlisting">osx$ <strong class="userinput"><code>man ioctl</code></strong>
[..]
<strong class="userinput"><code>SYNOPSIS</code></strong>
   <strong class="userinput"><code>#include &lt;sys/ioctl.h&gt;</code></strong>

   int
   <strong class="userinput"><code>ioctl</code></strong>(<span class="underline">int</span> <span class="underline">d</span>, <span class="underline">unsigned</span> <span class="underline">long</span> <span class="underline">request</span>, <span class="underline">char</span> <span class="underline">*argp</span>);

<strong class="userinput"><code>DESCRIPTION</code></strong>
   The <strong class="userinput"><code>ioctl()</code></strong> function manipulates the underlying device parameters of spe-
   cial files. In particular, many operating characteristics of character
   special files (e.g. terminals) may be controlled with <strong class="userinput"><code>ioctl()</code></strong> requests.
   The argument <span class="underline">d</span> must be an open file descriptor.

   An ioctl <span class="underline">request</span> has encoded in it whether the argument is an "in"
   parameter or "out" parameter, and the size of the argument <span class="underline">argp</span> in
   bytes. Macros and defines used in specifying an ioctl <span class="underline">request</span> are
   located in the file &lt;<span class="underline">sys/ioctl.h</span>&gt;.
[..]</pre><p>If an IOCTL request is sent to the kernel, the argument <code class="literal">request</code> has to be filled with the appropriate IOCTL code, and <code class="literal">argp</code> has to be filled with the user-supplied IOCTL input data. The <code class="literal">request</code> and <code class="literal">argp</code> arguments of <code class="literal">ioctl()</code> correspond to the kernel function arguments <code class="literal">cmd</code> and <code class="literal">data</code>.</p><p>I had found what I was looking for: Most kernel functions that process incoming IOCTL requests take an argument called <code class="literal">data</code> that holds, or points to, the user-supplied IOCTL input data.</p></div><div class="sect2" title="Step 3: Trace the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_trace_the_input_data-id3"/>Step 3: Trace the Input Data</h2></div></div></div><p>After I found the locations in the kernel where IOCTL requests are handled, I traced the input data through the kernel functions while looking for potentially vulnerable locations. While reading the code, I stumbled upon some locations that looked intriguing. The most interesting potential bug I found happens if the kernel tries to handle a special TTY IOCTL request. The following listing shows the relevant lines from the source code of the XNU kernel.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>xnu-792.13.8/bsd/kern/tty.c</em></span></p></dd></dl></div><a id="I_programlisting7_d1e7900"/><pre class="programlisting">[..]
 816    /*
 817     * Ioctls for all tty devices.  Called after line-discipline specific ioctl
 818     * has been called to do discipline-specific functions and/or reject any
 819     * of these ioctl commands.
 820     */
 821    /* ARGSUSED */
 822    int
 823    ttioctl(register struct tty *tp,
 824       <strong class="userinput"><code>u_long cmd</code></strong>, <strong class="userinput"><code>caddr_t data</code></strong>, int flag,
 825       struct proc *p)
 826    {
[..]
 <strong class="userinput"><code>872       switch (cmd) {            /* Process the ioctl. */</code></strong>
[..]
<strong class="userinput"><code>1089       case TIOCSETD: {        /* set line discipline */</code></strong>
<strong class="userinput"><code>1090           register int t = *(int *)data;</code></strong>
1091           dev_t device = tp-&gt;t_dev;
1092
<strong class="userinput"><code>1093           if (t &gt;= nlinesw)</code></strong>
1094               return (ENXIO);
<strong class="userinput"><code>1095           if (t != tp-&gt;t_line) {</code></strong>
1096               s = spltty();
1097               (*linesw[tp-&gt;t_line].l_close)(tp, flag);
<strong class="userinput"><code>1098               error = (*linesw[t].l_open)(device, tp);</code></strong>
1099               if (error) {
1100                   (void)(*linesw[tp-&gt;t_line].l_open)(device, tp);
1101                   splx(s);
1102                   return (error);
1103               }
1104               tp-&gt;t_line = t;
1105               splx(s);
1106           }
1107           break;
1108       }
[..]</pre><p>If a <code class="literal">TIOCSETD</code> IOCTL request is sent to the kernel, the switch case in line 1089 is chosen. In line 1090, the user-supplied <code class="literal">data</code> of type <code class="literal">caddr_t</code>, which is simply a typedef for <code class="literal">char *</code>, is stored in the signed int variable <code class="literal">t</code>. Then in line 1093, the value of <code class="literal">t</code> is compared with <code class="literal">nlinesw</code>. Since <code class="literal">data</code> is supplied by the user, it’s possible to provide a string value that corresponds to the unsigned integer value of <code class="literal">0x80000000</code> or greater. If this is done, <code class="literal">t</code> will have a negative value due to the type conversion in line 1090. <a class="xref" href="ch07.html#example_program_that_demonstrates_the" title="Example 7-1. Example program that demonstrates the type conversion behavior (conversion_bug_example.c)">Example 7-1</a> illustrates how <code class="literal">t</code> can become negative:<a id="IDX-CHP-7-0009" class="indexterm"/></p><div class="example"><a id="example_program_that_demonstrates_the"/><p class="title">Example 7-1. Example program that demonstrates the type conversion behavior (<span class="emphasis"><em>conversion_bug_example.c</em></span>)</p><div class="example-contents"><pre class="programlisting">01    typedef char *  caddr_t;
02
03    // output the bit pattern
04    void
05    bitpattern (int a)
06    {
07           int             m       = 0;
08           int             b       = 0;
09           int             cnt     = 0;
10           int             nbits   = 0;
11           unsigned int    mask    = 0;
12
13           nbits = 8 * sizeof (int);
14           m = 0x1 &lt;&lt; (nbits - 1);
15
16           mask = m;
17           for (cnt = 1; cnt &lt;= nbits; cnt++) {
18                   b = (a &amp; mask) ? 1 : 0;
19                   printf ("%x", b);
20                   if (cnt % 4 == 0)
21                           printf (" ");
22                   mask &gt;&gt;= 1;
23           }
24           printf ("\n");
25    }
26
27    int
28    main ()
29    {
30           caddr_t data    = "\xff\xff\xff\xff";
31           int     t       = 0;
32
33           t = *(int *)data;
34
35           printf ("Bit pattern of t: ");
36           bitpattern (t);
37
38           printf ("t = %d (0x%08x)\n", t, t);
39
40           return 0;
41    }</pre></div></div><p>Lines 30, 31, and 33 are nearly identical to lines in the OS X kernel source code. In this example, I chose the hardcoded value <code class="literal">0xffffffff</code> as IOCTL input data (see line 30). After the type conversion in line 33, the bit patterns, as well as the decimal value of <code class="literal">t</code>, are printed to the console. The example program results in the following output when it’s executed:</p><a id="I_programlisting7_d1e7985"/><pre class="programlisting">osx$ <strong class="userinput"><code>gcc -o conversion_bug_example conversion_bug_example.c</code></strong>

osx$ <strong class="userinput"><code>./conversion_bug_example</code></strong>
Bit pattern of t: 1111 1111 1111 1111 1111 1111 1111 1111
t = −1 (0xffffffff)</pre><p>The output shows that <code class="literal">t</code> gets the value −1 if a character string consisting of 4 <code class="literal">0xff</code> byte values is converted into a signed int. See Section A.3 for more information on type conversions and the associated security problems.</p><p>If <code class="literal">t</code> is negative, the check in line 1093 of the kernel code will return <code class="literal">FALSE</code> because the signed int variable <code class="literal">nlinesw</code> has a value greater than zero. If that happens, the user-supplied value of <code class="literal">t</code> gets further processing. In line 1098, the value of <code class="literal">t</code> is used as an index into an array of function pointers. Since I could control the index into that array, I could specify an arbitrary memory location that would be executed by the kernel. This leads to full control of the kernel execution flow. Thank you, Apple, for the terrific bug. <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e8019"/><img src="httpatomoreillycomsourcenostarchimages939227.png" alt=""/></span></p><p>Here is the anatomy of the bug, as diagrammed in <a class="xref" href="ch07.html#description_of_the_vulnerability_that_i" title="Figure 7-1. Description of the vulnerability that I discovered in the XNU kernel of OS X">Figure 7-1</a>:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The function pointer array <code class="literal">linesw[]</code> gets referenced.</p></li><li class="listitem"><p>The user-controlled value of <code class="literal">t</code> is used as an array index for <code class="literal">linesw[]</code>.</p></li><li class="listitem"><p>A pointer to the assumed address of the <code class="literal">l_open()</code> function gets referenced based on the user-controllable memory location.</p></li><li class="listitem"><p>The assumed address of <code class="literal">l_open()</code> gets referenced and called.</p></li><li class="listitem"><p>The value at the assumed address of <code class="literal">l_open()</code> gets copied into the instruction pointer (<code class="literal">EIP</code> register).</p></li></ol></div><div class="figure"><a id="description_of_the_vulnerability_that_i"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e8069"/><img src="httpatomoreillycomsourcenostarchimages939323.png.jpg" alt="Description of the vulnerability that I discovered in the XNU kernel of OS X"/></div></div><p class="title">Figure 7-1. Description of the vulnerability that I discovered in the XNU kernel of OS X</p></div><p>Because the value of <code class="literal">t</code> is supplied by the user (see (2)), it is possible to control the address of the value that gets copied into <code class="literal">EIP</code>.</p></div></div></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 7. A Bug Older Than 4.4BSD</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="chapter" title="Chapter 7. A Bug Older Than 4.4BSD"><div class="titlepage"><div><div><h1 class="title"><a id="a_bug_older_than_4.4bsd"/>Chapter 7. A Bug Older Than 4.4BSD</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Saturday, March 3, 2007</em></span><a id="IDX-CHP-7-0001" class="indexterm"/><a id="IDX-CHP-7-0002" class="indexterm"/></p><p><span class="emphasis"><em>Dear Diary</em></span>,</p></div><p>Last week my Apple MacBook finally arrived. After getting acquainted with the Mac OS X platform, I decided to take a closer look at the XNU kernel of OS X. After a few hours of digging through the kernel code, I found a nice bug that occurs when the kernel tries to handle a special TTY IOCTL. The bug was easy to trigger, and I wrote a POC code that allows an unprivileged local user to crash the system via kernel panic. As usual, I then tried to develop an exploit to see if the bug allows arbitrary code execution. At this point, things got a bit more complicated. To develop the exploit code, I needed a way to debug the OS X kernel. That’s not a problem if you own two Macs, but I only had one: my brand-new MacBook.<a id="IDX-CHP-7-0003" class="indexterm"/><a id="IDX-CHP-7-0004" class="indexterm"/><a id="IDX-CHP-7-0005" class="indexterm"/><a id="IDX-CHP-7-0006" class="indexterm"/></p><div class="sect1" title="7.1 Vulnerability Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_discovery-id5"/>7.1 Vulnerability Discovery</h1></div></div></div><p>First I downloaded the latest source code release of the XNU kernel,<sup>[<a href="ch07s05.html#ftn.CHP-7-FN-1" class="footnoteref">75</a>]</sup> and then I searched for a vulnerability in the following way:</p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>I used an Intel Mac with OS X 10.4.8 and kernel version xnu-792.15.4.obj~4/ RELEASE_I386 as a platform throughout this chapter</em></span>.</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: List the IOCTLs of the kernel.</p></li><li class="listitem"><p>Step 2: Identify the input data.</p></li><li class="listitem"><p>Step 3: Trace the input data.</p></li></ul></div><p>These steps will be detailed in the following sections.</p><div class="sect2" title="Step 1: List the IOCTLs of the Kernel"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_list_the_ioctls_of_the"/>Step 1: List the IOCTLs of the Kernel</h2></div></div></div><p>To generate a list of the IOCTLs of the kernel, I simply searched the kernel source code for the usual IOCTL macros. Every IOCTL is assigned its own number, which is usually created by a macro. Depending on the IOCTL type, the XNU kernel of OS X defines the following macros: <code class="literal">_IOR</code>, <code class="literal">_IOW</code>, and <code class="literal">_IOWR</code>.</p><a id="I_programlisting7_d1e7671"/><pre class="programlisting">osx$ <strong class="userinput"><code>pwd</code></strong>
/Users/tk/xnu-792.13.8

osx$ <strong class="userinput"><code>grep -rnw -e _IOR -e _IOW -e _IOWR *</code></strong>
[..]
xnu-792.13.8/bsd/net/bpf.h:161:#define BIOCGRSIG        _IOR('B',114, u_int)
xnu-792.13.8/bsd/net/bpf.h:162:#define BIOCSRSIG        _IOW('B',115, u_int)
xnu-792.13.8/bsd/net/bpf.h:163:#define BIOCGHDRCMPLT    _IOR('B',116, u_int)
xnu-792.13.8/bsd/net/bpf.h:164:#define BIOCSHDRCMPLT    _IOW('B',117, u_int)
xnu-792.13.8/bsd/net/bpf.h:165:#define BIOCGSEESENT     _IOR('B',118, u_int)
xnu-792.13.8/bsd/net/bpf.h:166:#define BIOCSSEESENT     _IOW('B',119, u_int)
[..]</pre><p>I now had a list of IOCTLs supported by the XNU kernel. To find the source files that implement the IOCTLs, I searched the whole kernel source for each IOCTL name from the list. Here’s an example of the <code class="literal">BIOCGRSIG</code> IOCTL:</p><a id="I_programlisting7_d1e7684"/><pre class="programlisting">osx$ <strong class="userinput"><code>grep --include=*.c -rn BIOCGRSIG *</code></strong>
xnu-792.13.8/bsd/net/bpf.c:1143:        case BIOCGRSIG:</pre></div><div class="sect2" title="Step 2: Identify the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_identify_the_input_data-id3"/>Step 2: Identify the Input Data</h2></div></div></div><p>To identify the user-supplied input data of an IOCTL request, I took a look at some of the kernel functions that process the requests. I discovered that such functions typically expect an argument called <code class="literal">cmd</code> of type <code class="literal">u_long</code> and a second argument called <code class="literal">data</code> of type <code class="literal">caddr_t</code>.</p><p>Here are some examples:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>xnu-792.13.8/bsd/netat/at.c</em></span></p></dd></dl></div><a id="I_programlisting7_d1e7717"/><pre class="programlisting">[..]
135 int
136 at_control(so, <strong class="userinput"><code>cmd</code></strong>, <strong class="userinput"><code>data</code></strong>, ifp)
137      struct socket *so;
138      <strong class="userinput"><code>u_long cmd;</code></strong>
139      <strong class="userinput"><code>caddr_t data;</code></strong>
140      struct ifnet *ifp;
141 {
[..]</pre><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>xnu-792.13.8/bsd/net/if.c</em></span></p></dd></dl></div><a id="I_programlisting7_d1e7740"/><pre class="programlisting">[..]
1025 int
1026 ifioctl(so, <strong class="userinput"><code>cmd</code></strong>, <strong class="userinput"><code>data</code></strong>, p)
1027     struct socket *so;
1028     <strong class="userinput"><code>u_long cmd;</code></strong>
1029     <strong class="userinput"><code>caddr_t data;</code></strong>
1030     struct proc *p;
1031 {
[..]</pre><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>xnu-792.13.8/bsd/dev/vn/vn.c</em></span></p></dd></dl></div><a id="I_programlisting7_d1e7763"/><pre class="programlisting">[..]
877 static int
878 vnioctl(dev_t dev, <strong class="userinput"><code>u_long cmd</code></strong>, <strong class="userinput"><code>caddr_t data</code></strong>,
879     __unused int flag, struct proc *p,
880     int is_char)
881 {
[..]</pre><p>The names of these function arguments are quite descriptive: The <code class="literal">cmd</code> argument holds the requested IOCTL code, and the <code class="literal">data</code> argument holds the user-supplied IOCTL data.</p><p>On Mac OS X, an IOCTL request is typically sent to the kernel using the <code class="literal">ioctl()</code> system call. This system call has the following prototype:<a id="IDX-CHP-7-0007" class="indexterm"/><a id="IDX-CHP-7-0008" class="indexterm"/></p><a id="I_programlisting7_d1e7795"/><pre class="programlisting">osx$ <strong class="userinput"><code>man ioctl</code></strong>
[..]
<strong class="userinput"><code>SYNOPSIS</code></strong>
   <strong class="userinput"><code>#include &lt;sys/ioctl.h&gt;</code></strong>

   int
   <strong class="userinput"><code>ioctl</code></strong>(<span class="underline">int</span> <span class="underline">d</span>, <span class="underline">unsigned</span> <span class="underline">long</span> <span class="underline">request</span>, <span class="underline">char</span> <span class="underline">*argp</span>);

<strong class="userinput"><code>DESCRIPTION</code></strong>
   The <strong class="userinput"><code>ioctl()</code></strong> function manipulates the underlying device parameters of spe-
   cial files. In particular, many operating characteristics of character
   special files (e.g. terminals) may be controlled with <strong class="userinput"><code>ioctl()</code></strong> requests.
   The argument <span class="underline">d</span> must be an open file descriptor.

   An ioctl <span class="underline">request</span> has encoded in it whether the argument is an "in"
   parameter or "out" parameter, and the size of the argument <span class="underline">argp</span> in
   bytes. Macros and defines used in specifying an ioctl <span class="underline">request</span> are
   located in the file &lt;<span class="underline">sys/ioctl.h</span>&gt;.
[..]</pre><p>If an IOCTL request is sent to the kernel, the argument <code class="literal">request</code> has to be filled with the appropriate IOCTL code, and <code class="literal">argp</code> has to be filled with the user-supplied IOCTL input data. The <code class="literal">request</code> and <code class="literal">argp</code> arguments of <code class="literal">ioctl()</code> correspond to the kernel function arguments <code class="literal">cmd</code> and <code class="literal">data</code>.</p><p>I had found what I was looking for: Most kernel functions that process incoming IOCTL requests take an argument called <code class="literal">data</code> that holds, or points to, the user-supplied IOCTL input data.</p></div><div class="sect2" title="Step 3: Trace the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_trace_the_input_data-id3"/>Step 3: Trace the Input Data</h2></div></div></div><p>After I found the locations in the kernel where IOCTL requests are handled, I traced the input data through the kernel functions while looking for potentially vulnerable locations. While reading the code, I stumbled upon some locations that looked intriguing. The most interesting potential bug I found happens if the kernel tries to handle a special TTY IOCTL request. The following listing shows the relevant lines from the source code of the XNU kernel.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>xnu-792.13.8/bsd/kern/tty.c</em></span></p></dd></dl></div><a id="I_programlisting7_d1e7900"/><pre class="programlisting">[..]
 816    /*
 817     * Ioctls for all tty devices.  Called after line-discipline specific ioctl
 818     * has been called to do discipline-specific functions and/or reject any
 819     * of these ioctl commands.
 820     */
 821    /* ARGSUSED */
 822    int
 823    ttioctl(register struct tty *tp,
 824       <strong class="userinput"><code>u_long cmd</code></strong>, <strong class="userinput"><code>caddr_t data</code></strong>, int flag,
 825       struct proc *p)
 826    {
[..]
 <strong class="userinput"><code>872       switch (cmd) {            /* Process the ioctl. */</code></strong>
[..]
<strong class="userinput"><code>1089       case TIOCSETD: {        /* set line discipline */</code></strong>
<strong class="userinput"><code>1090           register int t = *(int *)data;</code></strong>
1091           dev_t device = tp-&gt;t_dev;
1092
<strong class="userinput"><code>1093           if (t &gt;= nlinesw)</code></strong>
1094               return (ENXIO);
<strong class="userinput"><code>1095           if (t != tp-&gt;t_line) {</code></strong>
1096               s = spltty();
1097               (*linesw[tp-&gt;t_line].l_close)(tp, flag);
<strong class="userinput"><code>1098               error = (*linesw[t].l_open)(device, tp);</code></strong>
1099               if (error) {
1100                   (void)(*linesw[tp-&gt;t_line].l_open)(device, tp);
1101                   splx(s);
1102                   return (error);
1103               }
1104               tp-&gt;t_line = t;
1105               splx(s);
1106           }
1107           break;
1108       }
[..]</pre><p>If a <code class="literal">TIOCSETD</code> IOCTL request is sent to the kernel, the switch case in line 1089 is chosen. In line 1090, the user-supplied <code class="literal">data</code> of type <code class="literal">caddr_t</code>, which is simply a typedef for <code class="literal">char *</code>, is stored in the signed int variable <code class="literal">t</code>. Then in line 1093, the value of <code class="literal">t</code> is compared with <code class="literal">nlinesw</code>. Since <code class="literal">data</code> is supplied by the user, it’s possible to provide a string value that corresponds to the unsigned integer value of <code class="literal">0x80000000</code> or greater. If this is done, <code class="literal">t</code> will have a negative value due to the type conversion in line 1090. <a class="xref" href="ch07.html#example_program_that_demonstrates_the" title="Example 7-1. Example program that demonstrates the type conversion behavior (conversion_bug_example.c)">Example 7-1</a> illustrates how <code class="literal">t</code> can become negative:<a id="IDX-CHP-7-0009" class="indexterm"/></p><div class="example"><a id="example_program_that_demonstrates_the"/><p class="title">Example 7-1. Example program that demonstrates the type conversion behavior (<span class="emphasis"><em>conversion_bug_example.c</em></span>)</p><div class="example-contents"><pre class="programlisting">01    typedef char *  caddr_t;
02
03    // output the bit pattern
04    void
05    bitpattern (int a)
06    {
07           int             m       = 0;
08           int             b       = 0;
09           int             cnt     = 0;
10           int             nbits   = 0;
11           unsigned int    mask    = 0;
12
13           nbits = 8 * sizeof (int);
14           m = 0x1 &lt;&lt; (nbits - 1);
15
16           mask = m;
17           for (cnt = 1; cnt &lt;= nbits; cnt++) {
18                   b = (a &amp; mask) ? 1 : 0;
19                   printf ("%x", b);
20                   if (cnt % 4 == 0)
21                           printf (" ");
22                   mask &gt;&gt;= 1;
23           }
24           printf ("\n");
25    }
26
27    int
28    main ()
29    {
30           caddr_t data    = "\xff\xff\xff\xff";
31           int     t       = 0;
32
33           t = *(int *)data;
34
35           printf ("Bit pattern of t: ");
36           bitpattern (t);
37
38           printf ("t = %d (0x%08x)\n", t, t);
39
40           return 0;
41    }</pre></div></div><p>Lines 30, 31, and 33 are nearly identical to lines in the OS X kernel source code. In this example, I chose the hardcoded value <code class="literal">0xffffffff</code> as IOCTL input data (see line 30). After the type conversion in line 33, the bit patterns, as well as the decimal value of <code class="literal">t</code>, are printed to the console. The example program results in the following output when it’s executed:</p><a id="I_programlisting7_d1e7985"/><pre class="programlisting">osx$ <strong class="userinput"><code>gcc -o conversion_bug_example conversion_bug_example.c</code></strong>

osx$ <strong class="userinput"><code>./conversion_bug_example</code></strong>
Bit pattern of t: 1111 1111 1111 1111 1111 1111 1111 1111
t = −1 (0xffffffff)</pre><p>The output shows that <code class="literal">t</code> gets the value −1 if a character string consisting of 4 <code class="literal">0xff</code> byte values is converted into a signed int. See Section A.3 for more information on type conversions and the associated security problems.</p><p>If <code class="literal">t</code> is negative, the check in line 1093 of the kernel code will return <code class="literal">FALSE</code> because the signed int variable <code class="literal">nlinesw</code> has a value greater than zero. If that happens, the user-supplied value of <code class="literal">t</code> gets further processing. In line 1098, the value of <code class="literal">t</code> is used as an index into an array of function pointers. Since I could control the index into that array, I could specify an arbitrary memory location that would be executed by the kernel. This leads to full control of the kernel execution flow. Thank you, Apple, for the terrific bug. <span class="inlinemediaobject"><a id="I_inlinemediaobject7_d1e8019"/><img src="httpatomoreillycomsourcenostarchimages939227.png" alt=""/></span></p><p>Here is the anatomy of the bug, as diagrammed in <a class="xref" href="ch07.html#description_of_the_vulnerability_that_i" title="Figure 7-1. Description of the vulnerability that I discovered in the XNU kernel of OS X">Figure 7-1</a>:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The function pointer array <code class="literal">linesw[]</code> gets referenced.</p></li><li class="listitem"><p>The user-controlled value of <code class="literal">t</code> is used as an array index for <code class="literal">linesw[]</code>.</p></li><li class="listitem"><p>A pointer to the assumed address of the <code class="literal">l_open()</code> function gets referenced based on the user-controllable memory location.</p></li><li class="listitem"><p>The assumed address of <code class="literal">l_open()</code> gets referenced and called.</p></li><li class="listitem"><p>The value at the assumed address of <code class="literal">l_open()</code> gets copied into the instruction pointer (<code class="literal">EIP</code> register).</p></li></ol></div><div class="figure"><a id="description_of_the_vulnerability_that_i"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e8069"/><img src="httpatomoreillycomsourcenostarchimages939323.png.jpg" alt="Description of the vulnerability that I discovered in the XNU kernel of OS X"/></div></div><p class="title">Figure 7-1. Description of the vulnerability that I discovered in the XNU kernel of OS X</p></div><p>Because the value of <code class="literal">t</code> is supplied by the user (see (2)), it is possible to control the address of the value that gets copied into <code class="literal">EIP</code>.</p></div></div></div></body></html>
