<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 4. NULL Pointer FTW</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="chapter" title="Chapter 4. NULL Pointer FTW"><div class="titlepage"><div><div><h1 class="title"><a id="null_pointer_ftw"/>Chapter 4. NULL Pointer FTW</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Saturday, January 24, 2009</em></span></p><p><span class="emphasis"><em>Dear Diary</em></span>,</p></div><p>I found a really beautiful bug today: a type conversion vulnerability leading to a NULL pointer dereference (see Section A.2). Under normal circumstances this wouldn’t be a big deal, since the bug affects a user space library, which generally means that at worst it would crash a user space application. But this bug is different from the average user space NULL pointer dereferences, and it’s possible to exploit this vulnerability to execute arbitrary code.<a id="IDX-CHP-4-0001" class="indexterm"/><a id="IDX-CHP-4-0002" class="indexterm"/><a id="IDX-CHP-4-0003" class="indexterm"/></p><p>The vulnerability affects the FFmpeg multimedia library that is used by many popular software projects, including Google Chrome, VLC media player, MPlayer, and Xine to name just a few. There are also rumors that YouTube uses FFmpeg as backend conversion software.<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-1" class="footnoteref">37</a>]</sup><a id="IDX-CHP-4-0004" class="indexterm"/><a id="IDX-CHP-4-0005" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>There are other examples of exploitable user space NULL pointer dereferences. See Mark Dowd’s MacGyver exploit for Flash</em></span> (<a class="ulink" href="http://blogs.iss.net/archive/flash.html">http://blogs.iss.net/archive/flash.html</a>) <span class="emphasis"><em>or Justin Schuh’s Firefox bug</em></span> (<a class="ulink" href="http://blogs.iss.net/archive/cve-2008-0017.html">http://blogs.iss.net/archive/cve-2008-0017.html</a>).</p></div><div class="sect1" title="4.1 Vulnerability Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_discovery-id2"/>4.1 Vulnerability Discovery</h1></div></div></div><p>To find the vulnerability I did the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: List the demuxers of FFmpeg.<a id="IDX-CHP-4-0006" class="indexterm"/></p></li><li class="listitem"><p>Step 2: Identify the input data.</p></li><li class="listitem"><p>Step 3: Trace the input data.</p></li></ul></div><div class="sect2" title="Step 1: List the Demuxers of FFmpeg"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_list_the_demuxers_of_ffmpeg"/>Step 1: List the Demuxers of FFmpeg</h2></div></div></div><p>After getting the latest source code revision from the FFmpeg SVN repository, I generated a list of the demuxers that are available in the <code class="literal">libavformat</code> library, which is included with FFmpeg (see <a class="xref" href="ch04.html#ffmpeg_libavformat_demuxers" title="Figure 4-1. FFmpeg libavformat demuxers">Figure 4-1</a>). I noticed that FFmpeg separates most demuxers in different C files under the directory <span class="emphasis"><em>libavformat/</em></span>.</p><div class="figure"><a id="ffmpeg_libavformat_demuxers"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e3555"/><img src="httpatomoreillycomsourcenostarchimages939263.png.jpg" alt="FFmpeg libavformat demuxers"/></div></div><p class="title">Figure 4-1. FFmpeg libavformat demuxers</p></div><div class="note" title="Note"><h3 class="title">Note</h3><p>FFmpeg development has moved to a Git repository,<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-2" class="footnoteref">38</a>]</sup>and the SVN repository is no longer updated. The vulnerable source code revision (SVN-r16556) of FFmpeg can now be downloaded from this book’s website.<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-3" class="footnoteref">39</a>]</sup></p></div></div><div class="sect2" title="Step 2: Identify the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_identify_the_input_data-id2"/>Step 2: Identify the Input Data</h2></div></div></div><p>Next, I tried to identify the input data processed by the demuxers. While reading the source code, I discovered that most demuxers declare a function called <em class="replaceable"><code>demuxername</code></em><code class="literal">_read_header()</code>, which usually takes a parameter of the type <code class="literal">AVFormatContext</code>. This function declares and initializes a pointer that looks like this:</p><a id="I_programlisting4_d1e3579"/><pre class="programlisting">[..]
ByteIOContext *pb = s-&gt;pb;
[..]</pre><p>Many different <code class="literal">get_</code><em class="replaceable"><code>something</code></em> functions (e.g., <code class="literal">get_le32()</code>, <code class="literal">get_buffer()</code>) and special macros (e.g., <code class="literal">AV_RL32</code>, <code class="literal">AV_RL16</code>) are then used to extract portions of the data pointed to by <code class="literal">pb</code>. At this point, I was pretty sure that <code class="literal">pb</code> had to be a pointer to the input data of the media files being processed.</p></div><div class="sect2" title="Step 3: Trace the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_trace_the_input_data-id2"/>Step 3: Trace the Input Data</h2></div></div></div><p>I decided to search for bugs by tracing the input data of each demuxer at the source code level. I started with the first demuxer file from the list, called <span class="emphasis"><em>4xm.c</em></span>. While auditing the demuxer of the 4X movie file format,<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-4" class="footnoteref">40</a>]</sup> I found the vulnerability shown in the listing below.<a id="IDX-CHP-4-0007" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>libavformat/4xm.c</em></span></p></dd><dt><span class="term"><span class="strong"><strong>Function</strong></span></span></dt><dd><p><code class="literal">fourxm_read_header()</code></p></dd></dl></div><a id="I_programlisting4_d1e3637"/><pre class="programlisting">[..]
 93    static int fourxm_read_header(AVFormatContext *s,
 94                                  AVFormatParameters *ap)
 95    {
 <strong class="userinput"><code>96      ByteIOContext *pb = s-&gt;pb;</code></strong>
 ..
<strong class="userinput"><code>101      unsigned char *header;</code></strong>
 ..
<strong class="userinput"><code>103      int current_track = −1;</code></strong>
 ..
<strong class="userinput"><code>106      fourxm-&gt;track_count = 0;</code></strong>
<strong class="userinput"><code>107      fourxm-&gt;tracks = NULL;</code></strong>
 ..
120       /* allocate space for the header and load the whole thing */
<strong class="userinput"><code>121       header = av_malloc(header_size);</code></strong>
122       if (!header)
123           return AVERROR(ENOMEM);
<strong class="userinput"><code>124       if (get_buffer(pb, header, header_size) != header_size)</code></strong>
125           return AVERROR(EIO);
 ..
<strong class="userinput"><code>160      } else if (fourcc_tag == strk_TAG) {</code></strong>
161          /* check that there is enough data */
162          if (size != strk_SIZE) {
163              av_free(header);
164              return AVERROR_INVALIDDATA;
165          }
<strong class="userinput"><code>166          current_track = AV_RL32(&amp;header[i + 8]);</code></strong>
<strong class="userinput"><code>167          if (current_track + 1 &gt; fourxm-&gt;track_count) {</code></strong>
168             fourxm-&gt;track_count = current_track + 1;
169             if((unsigned)fourxm-&gt;track_count &gt;= UINT_MAX / sizeof(AudioTrack))
170               return −1;
<strong class="userinput"><code>171             fourxm-&gt;tracks = av_realloc(fourxm-&gt;tracks,</code></strong>
<strong class="userinput"><code>172                 fourxm-&gt;track_count * sizeof(AudioTrack));</code></strong>
173             if (!fourxm-&gt;tracks) {
174               av_free(header);
175               return AVERROR(ENOMEM);
176             }
177          }
<strong class="userinput"><code>178          fourxm-&gt;tracks[current_track].adpcm = AV_RL32(&amp;header[i + 12]);</code></strong>
<strong class="userinput"><code>179          fourxm-&gt;tracks[current_track].channels = AV_RL32(&amp;header[i + 36]);</code></strong>
<strong class="userinput"><code>180          fourxm-&gt;tracks[current_track].sample_rate = AV_RL32(&amp;header[i + 40]);</code></strong>
<strong class="userinput"><code>181          fourxm-&gt;tracks[current_track].bits = AV_RL32(&amp;header[i + 44]);</code></strong>
[..]</pre><p>The <code class="literal">get_buffer()</code> function in line 124 copies input data from the processed media file into the heap buffer pointed to by <code class="literal">header</code> (see lines 101 and 121). If the media file contains a so-called <code class="literal">strk</code> chunk (see line 160) the <code class="literal">AV_RL32()</code> macro in line 166 reads an unsigned int from the header data and stores the value in the signed int variable <code class="literal">current_track</code> (see line 103). The conversion of a user-controlled unsigned int value from the media file to a signed int could cause a conversion bug! My interest piqued, I continued to search through the code, excited that I might be on to something.</p><p>The <code class="literal">if</code> statement in line 167 checks whether the user-controlled value of <code class="literal">current_track + 1</code> is greater than <code class="literal">fourxm-&gt;track_count</code>. The signed int variable <code class="literal">fourxm-&gt;track_count</code> is initialized with 0 (see line 106). Supplying a value &gt;= <code class="literal">0x80000000</code> for <code class="literal">current_track</code> causes a change in sign that results in <code class="literal">current_track</code> being interpreted as negative (to find out why, see Section A.3). If <code class="literal">current_track</code> is interpreted as negative, the <code class="literal">if</code> statement in line 167 will always return <code class="literal">false</code> (as the signed int variable <code class="literal">fourxm-&gt;track_count</code> has a value of zero), and the buffer allocation in line 171 will never be reached. Clearly, it was a bad idea to convert that user-controlled unsigned int to a signed int.</p><p>Since <code class="literal">fourxm-&gt;tracks</code> is initialized with <code class="literal">NULL</code> (see line 107) and line 171 is never reached, the write operations in lines 178–181 lead to four NULL pointer dereferences. Because NULL is dereferenced by the user-controlled value of <code class="literal">current_track</code>, it’s possible to write user-controlled data at a wide range of memory locations.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Perhaps you wouldn’t technically call this a NULL pointer “dereference,” since I’m not actually dereferencing NULL but a nonexistent structure that’s located at a user-controlled offset from NULL. In the end it depends on how you define the term <span class="emphasis"><em>NULL pointer dereference</em></span>.</p></div><p>The expected behavior of FFmpeg is shown in <a class="xref" href="ch04.html#expected_behavior_when_ffmpeg_operates_n" title="Figure 4-2. Expected behavior when FFmpeg operates normally">Figure 4-2</a> as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><code class="literal">fourxm-&gt;tracks</code> is initialized with <code class="literal">NULL</code> (see line 107).</p></li><li class="listitem"><p>If the processed media file contains a <code class="literal">strk</code> chunk, the value of <code class="literal">current_track</code> is extracted from the user-controlled data of the chunk (see line 166).</p></li><li class="listitem"><p>If the value of <code class="literal">current_track + 1</code> is greater than zero, a heap buffer is allocated.</p></li><li class="listitem"><p>The heap buffer pointed to by <code class="literal">fourxm-&gt;tracks</code> is allocated (see lines 171 and 172).</p></li><li class="listitem"><p>Data from the media file is copied into the heap buffer, while <code class="literal">current_track</code> is used as an array index into the buffer (see lines 178–181).</p></li><li class="listitem"><p>When this behavior occurs, there is no security problem.</p></li></ol></div><div class="figure"><a id="expected_behavior_when_ffmpeg_operates_n"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e3805"/><img src="httpatomoreillycomsourcenostarchimages939265.png.jpg" alt="Expected behavior when FFmpeg operates normally"/></div></div><p class="title">Figure 4-2. Expected behavior when FFmpeg operates normally</p></div><p><a class="xref" href="ch04.html#unexpected_behavior_of_ffmpeg_causing_me" title="Figure 4-3. Unexpected behavior of FFmpeg causing memory corruption">Figure 4-3</a> shows what happens when this bug affects FFmpeg:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><code class="literal">fourxm-&gt;tracks</code> is initialized with <code class="literal">NULL</code> (see line 107).</p></li><li class="listitem"><p>If the processed media file contains a <code class="literal">strk</code> chunk, the value of <code class="literal">current_track</code> is extracted from the user-controlled data of the chunk (see line 166).</p></li><li class="listitem"><p>If the value of <code class="literal">current_track + 1</code> is less than zero, the heap buffer isn’t allocated.</p></li><li class="listitem"><p><code class="literal">fourxm-&gt;tracks</code> still points to memory address <code class="literal">NULL</code>.</p></li><li class="listitem"><p>The resulting NULL pointer is then dereferenced by the user-controlled value of <code class="literal">current_track</code>, and four 32-bit values of user-controlled data are assigned to the dereferenced locations (see lines 178–181).</p></li><li class="listitem"><p>Four user-controlled memory locations can be overwritten with four user-controlled data bytes each.</p></li></ol></div><div class="figure"><a id="unexpected_behavior_of_ffmpeg_causing_me"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e3858"/><img src="httpatomoreillycomsourcenostarchimages939267.png.jpg" alt="Unexpected behavior of FFmpeg causing memory corruption"/></div></div><p class="title">Figure 4-3. Unexpected behavior of FFmpeg causing memory corruption</p></div><p>What a beautiful bug!</p></div></div></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 4. NULL Pointer FTW</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="chapter" title="Chapter 4. NULL Pointer FTW"><div class="titlepage"><div><div><h1 class="title"><a id="null_pointer_ftw"/>Chapter 4. NULL Pointer FTW</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Saturday, January 24, 2009</em></span></p><p><span class="emphasis"><em>Dear Diary</em></span>,</p></div><p>I found a really beautiful bug today: a type conversion vulnerability leading to a NULL pointer dereference (see Section A.2). Under normal circumstances this wouldn’t be a big deal, since the bug affects a user space library, which generally means that at worst it would crash a user space application. But this bug is different from the average user space NULL pointer dereferences, and it’s possible to exploit this vulnerability to execute arbitrary code.<a id="IDX-CHP-4-0001" class="indexterm"/><a id="IDX-CHP-4-0002" class="indexterm"/><a id="IDX-CHP-4-0003" class="indexterm"/></p><p>The vulnerability affects the FFmpeg multimedia library that is used by many popular software projects, including Google Chrome, VLC media player, MPlayer, and Xine to name just a few. There are also rumors that YouTube uses FFmpeg as backend conversion software.<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-1" class="footnoteref">37</a>]</sup><a id="IDX-CHP-4-0004" class="indexterm"/><a id="IDX-CHP-4-0005" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>There are other examples of exploitable user space NULL pointer dereferences. See Mark Dowd’s MacGyver exploit for Flash</em></span> (<a class="ulink" href="http://blogs.iss.net/archive/flash.html">http://blogs.iss.net/archive/flash.html</a>) <span class="emphasis"><em>or Justin Schuh’s Firefox bug</em></span> (<a class="ulink" href="http://blogs.iss.net/archive/cve-2008-0017.html">http://blogs.iss.net/archive/cve-2008-0017.html</a>).</p></div><div class="sect1" title="4.1 Vulnerability Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_discovery-id2"/>4.1 Vulnerability Discovery</h1></div></div></div><p>To find the vulnerability I did the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: List the demuxers of FFmpeg.<a id="IDX-CHP-4-0006" class="indexterm"/></p></li><li class="listitem"><p>Step 2: Identify the input data.</p></li><li class="listitem"><p>Step 3: Trace the input data.</p></li></ul></div><div class="sect2" title="Step 1: List the Demuxers of FFmpeg"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_list_the_demuxers_of_ffmpeg"/>Step 1: List the Demuxers of FFmpeg</h2></div></div></div><p>After getting the latest source code revision from the FFmpeg SVN repository, I generated a list of the demuxers that are available in the <code class="literal">libavformat</code> library, which is included with FFmpeg (see <a class="xref" href="ch04.html#ffmpeg_libavformat_demuxers" title="Figure 4-1. FFmpeg libavformat demuxers">Figure 4-1</a>). I noticed that FFmpeg separates most demuxers in different C files under the directory <span class="emphasis"><em>libavformat/</em></span>.</p><div class="figure"><a id="ffmpeg_libavformat_demuxers"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e3555"/><img src="httpatomoreillycomsourcenostarchimages939263.png.jpg" alt="FFmpeg libavformat demuxers"/></div></div><p class="title">Figure 4-1. FFmpeg libavformat demuxers</p></div><div class="note" title="Note"><h3 class="title">Note</h3><p>FFmpeg development has moved to a Git repository,<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-2" class="footnoteref">38</a>]</sup>and the SVN repository is no longer updated. The vulnerable source code revision (SVN-r16556) of FFmpeg can now be downloaded from this book’s website.<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-3" class="footnoteref">39</a>]</sup></p></div></div><div class="sect2" title="Step 2: Identify the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_identify_the_input_data-id2"/>Step 2: Identify the Input Data</h2></div></div></div><p>Next, I tried to identify the input data processed by the demuxers. While reading the source code, I discovered that most demuxers declare a function called <em class="replaceable"><code>demuxername</code></em><code class="literal">_read_header()</code>, which usually takes a parameter of the type <code class="literal">AVFormatContext</code>. This function declares and initializes a pointer that looks like this:</p><a id="I_programlisting4_d1e3579"/><pre class="programlisting">[..]
ByteIOContext *pb = s-&gt;pb;
[..]</pre><p>Many different <code class="literal">get_</code><em class="replaceable"><code>something</code></em> functions (e.g., <code class="literal">get_le32()</code>, <code class="literal">get_buffer()</code>) and special macros (e.g., <code class="literal">AV_RL32</code>, <code class="literal">AV_RL16</code>) are then used to extract portions of the data pointed to by <code class="literal">pb</code>. At this point, I was pretty sure that <code class="literal">pb</code> had to be a pointer to the input data of the media files being processed.</p></div><div class="sect2" title="Step 3: Trace the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_trace_the_input_data-id2"/>Step 3: Trace the Input Data</h2></div></div></div><p>I decided to search for bugs by tracing the input data of each demuxer at the source code level. I started with the first demuxer file from the list, called <span class="emphasis"><em>4xm.c</em></span>. While auditing the demuxer of the 4X movie file format,<sup>[<a href="ch04s05.html#ftn.CHP-4-FN-4" class="footnoteref">40</a>]</sup> I found the vulnerability shown in the listing below.<a id="IDX-CHP-4-0007" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>libavformat/4xm.c</em></span></p></dd><dt><span class="term"><span class="strong"><strong>Function</strong></span></span></dt><dd><p><code class="literal">fourxm_read_header()</code></p></dd></dl></div><a id="I_programlisting4_d1e3637"/><pre class="programlisting">[..]
 93    static int fourxm_read_header(AVFormatContext *s,
 94                                  AVFormatParameters *ap)
 95    {
 <strong class="userinput"><code>96      ByteIOContext *pb = s-&gt;pb;</code></strong>
 ..
<strong class="userinput"><code>101      unsigned char *header;</code></strong>
 ..
<strong class="userinput"><code>103      int current_track = −1;</code></strong>
 ..
<strong class="userinput"><code>106      fourxm-&gt;track_count = 0;</code></strong>
<strong class="userinput"><code>107      fourxm-&gt;tracks = NULL;</code></strong>
 ..
120       /* allocate space for the header and load the whole thing */
<strong class="userinput"><code>121       header = av_malloc(header_size);</code></strong>
122       if (!header)
123           return AVERROR(ENOMEM);
<strong class="userinput"><code>124       if (get_buffer(pb, header, header_size) != header_size)</code></strong>
125           return AVERROR(EIO);
 ..
<strong class="userinput"><code>160      } else if (fourcc_tag == strk_TAG) {</code></strong>
161          /* check that there is enough data */
162          if (size != strk_SIZE) {
163              av_free(header);
164              return AVERROR_INVALIDDATA;
165          }
<strong class="userinput"><code>166          current_track = AV_RL32(&amp;header[i + 8]);</code></strong>
<strong class="userinput"><code>167          if (current_track + 1 &gt; fourxm-&gt;track_count) {</code></strong>
168             fourxm-&gt;track_count = current_track + 1;
169             if((unsigned)fourxm-&gt;track_count &gt;= UINT_MAX / sizeof(AudioTrack))
170               return −1;
<strong class="userinput"><code>171             fourxm-&gt;tracks = av_realloc(fourxm-&gt;tracks,</code></strong>
<strong class="userinput"><code>172                 fourxm-&gt;track_count * sizeof(AudioTrack));</code></strong>
173             if (!fourxm-&gt;tracks) {
174               av_free(header);
175               return AVERROR(ENOMEM);
176             }
177          }
<strong class="userinput"><code>178          fourxm-&gt;tracks[current_track].adpcm = AV_RL32(&amp;header[i + 12]);</code></strong>
<strong class="userinput"><code>179          fourxm-&gt;tracks[current_track].channels = AV_RL32(&amp;header[i + 36]);</code></strong>
<strong class="userinput"><code>180          fourxm-&gt;tracks[current_track].sample_rate = AV_RL32(&amp;header[i + 40]);</code></strong>
<strong class="userinput"><code>181          fourxm-&gt;tracks[current_track].bits = AV_RL32(&amp;header[i + 44]);</code></strong>
[..]</pre><p>The <code class="literal">get_buffer()</code> function in line 124 copies input data from the processed media file into the heap buffer pointed to by <code class="literal">header</code> (see lines 101 and 121). If the media file contains a so-called <code class="literal">strk</code> chunk (see line 160) the <code class="literal">AV_RL32()</code> macro in line 166 reads an unsigned int from the header data and stores the value in the signed int variable <code class="literal">current_track</code> (see line 103). The conversion of a user-controlled unsigned int value from the media file to a signed int could cause a conversion bug! My interest piqued, I continued to search through the code, excited that I might be on to something.</p><p>The <code class="literal">if</code> statement in line 167 checks whether the user-controlled value of <code class="literal">current_track + 1</code> is greater than <code class="literal">fourxm-&gt;track_count</code>. The signed int variable <code class="literal">fourxm-&gt;track_count</code> is initialized with 0 (see line 106). Supplying a value &gt;= <code class="literal">0x80000000</code> for <code class="literal">current_track</code> causes a change in sign that results in <code class="literal">current_track</code> being interpreted as negative (to find out why, see Section A.3). If <code class="literal">current_track</code> is interpreted as negative, the <code class="literal">if</code> statement in line 167 will always return <code class="literal">false</code> (as the signed int variable <code class="literal">fourxm-&gt;track_count</code> has a value of zero), and the buffer allocation in line 171 will never be reached. Clearly, it was a bad idea to convert that user-controlled unsigned int to a signed int.</p><p>Since <code class="literal">fourxm-&gt;tracks</code> is initialized with <code class="literal">NULL</code> (see line 107) and line 171 is never reached, the write operations in lines 178–181 lead to four NULL pointer dereferences. Because NULL is dereferenced by the user-controlled value of <code class="literal">current_track</code>, it’s possible to write user-controlled data at a wide range of memory locations.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Perhaps you wouldn’t technically call this a NULL pointer “dereference,” since I’m not actually dereferencing NULL but a nonexistent structure that’s located at a user-controlled offset from NULL. In the end it depends on how you define the term <span class="emphasis"><em>NULL pointer dereference</em></span>.</p></div><p>The expected behavior of FFmpeg is shown in <a class="xref" href="ch04.html#expected_behavior_when_ffmpeg_operates_n" title="Figure 4-2. Expected behavior when FFmpeg operates normally">Figure 4-2</a> as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><code class="literal">fourxm-&gt;tracks</code> is initialized with <code class="literal">NULL</code> (see line 107).</p></li><li class="listitem"><p>If the processed media file contains a <code class="literal">strk</code> chunk, the value of <code class="literal">current_track</code> is extracted from the user-controlled data of the chunk (see line 166).</p></li><li class="listitem"><p>If the value of <code class="literal">current_track + 1</code> is greater than zero, a heap buffer is allocated.</p></li><li class="listitem"><p>The heap buffer pointed to by <code class="literal">fourxm-&gt;tracks</code> is allocated (see lines 171 and 172).</p></li><li class="listitem"><p>Data from the media file is copied into the heap buffer, while <code class="literal">current_track</code> is used as an array index into the buffer (see lines 178–181).</p></li><li class="listitem"><p>When this behavior occurs, there is no security problem.</p></li></ol></div><div class="figure"><a id="expected_behavior_when_ffmpeg_operates_n"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e3805"/><img src="httpatomoreillycomsourcenostarchimages939265.png.jpg" alt="Expected behavior when FFmpeg operates normally"/></div></div><p class="title">Figure 4-2. Expected behavior when FFmpeg operates normally</p></div><p><a class="xref" href="ch04.html#unexpected_behavior_of_ffmpeg_causing_me" title="Figure 4-3. Unexpected behavior of FFmpeg causing memory corruption">Figure 4-3</a> shows what happens when this bug affects FFmpeg:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><code class="literal">fourxm-&gt;tracks</code> is initialized with <code class="literal">NULL</code> (see line 107).</p></li><li class="listitem"><p>If the processed media file contains a <code class="literal">strk</code> chunk, the value of <code class="literal">current_track</code> is extracted from the user-controlled data of the chunk (see line 166).</p></li><li class="listitem"><p>If the value of <code class="literal">current_track + 1</code> is less than zero, the heap buffer isn’t allocated.</p></li><li class="listitem"><p><code class="literal">fourxm-&gt;tracks</code> still points to memory address <code class="literal">NULL</code>.</p></li><li class="listitem"><p>The resulting NULL pointer is then dereferenced by the user-controlled value of <code class="literal">current_track</code>, and four 32-bit values of user-controlled data are assigned to the dereferenced locations (see lines 178–181).</p></li><li class="listitem"><p>Four user-controlled memory locations can be overwritten with four user-controlled data bytes each.</p></li></ol></div><div class="figure"><a id="unexpected_behavior_of_ffmpeg_causing_me"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e3858"/><img src="httpatomoreillycomsourcenostarchimages939267.png.jpg" alt="Unexpected behavior of FFmpeg causing memory corruption"/></div></div><p class="title">Figure 4-3. Unexpected behavior of FFmpeg causing memory corruption</p></div><p>What a beautiful bug!</p></div></div></div></body></html>
