<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 2. Back to the ’90s</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="chapter" title="Chapter 2. Back to the ’90s"><div class="titlepage"><div><div><h1 class="title"><a id="back_to_the_a90s"/>Chapter 2. Back to the ’90s</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Sunday, October 12, 2008</em></span><a id="IDX-CHP-2-0001" class="indexterm"/></p><p><span class="emphasis"><em>Dear Diary</em></span>,</p></div><p>I had a look at the source code of VideoLAN’s popular VLC media player today. I like VLC because it supports all different kinds of media files and runs on all my favorite operating system platforms. But supporting all those different media file formats has downsides. VLC does a lot of parsing, and that often means a lot of bugs just waiting to be discovered.<a id="IDX-CHP-2-0002" class="indexterm"/><a id="IDX-CHP-2-0003" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>According to <span class="emphasis"><em>Parsing Techniques: A Practical Guide</em></span> by Dick Grune and Ceriel J.H. Jacobs,<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-1" class="footnoteref">6</a>]</sup> “Parsing is the process of structuring a linear representation in accordance with a given grammar.” A parser is software that breaks apart a raw string of bytes into individual words and statements. Depending on the data format, parsing can be a very complex and error-prone task.<a id="IDX-CHP-2-0004" class="indexterm"/></p></div><p>After I became familiar with the inner workings of VLC, finding the first vulnerability took me only about half a day. It was a classic stack buffer overflow (see Section A.1). This one occurred while parsing a media file format called TiVo, the proprietary format native to TiVo digital recording devices. Before finding this bug, I had never heard of this file format, but that didn’t stop me from exploiting it.<a id="IDX-CHP-2-0005" class="indexterm"/></p><div class="sect1" title="2.1 Vulnerability Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_discovery"/>2.1 Vulnerability Discovery</h1></div></div></div><p>Here is how I found the vulnerability:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: Generate a list of the demuxers of VLC.<a id="IDX-CHP-2-0006" class="indexterm"/></p></li><li class="listitem"><p>Step 2: Identify the input data.</p></li><li class="listitem"><p>Step 3: Trace the input data.</p></li></ul></div><p>I’ll explain this process in detail in the following sections.</p><div class="sect2" title="Step 1: Generate a List of the Demuxers of VLC"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_generate_a_list_of_the_demu"/>Step 1: Generate a List of the Demuxers of VLC</h2></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>I used VLC 0.9.4 on the Microsoft Windows Vista SP1 (32-bit) platform for all the following steps</em></span>.<a id="IDX-CHP-2-0007" class="indexterm"/></p></div><p>After downloading and unpacking the source code of VLC,<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-2" class="footnoteref">7</a>]</sup> I generated a list of the available demuxers of the media player.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In digital video, <span class="emphasis"><em>demuxing</em></span> or <span class="emphasis"><em>demultiplexing</em></span> refers to the process of separating audio and video as well as other data from a video stream or container in order to play the file. A demuxer is software that extracts the components of such a stream or container.</p></div><p>Generating a list of demuxers wasn’t too hard, as VLC separates most of them in different C files in the directory <span class="emphasis"><em>vlc-0.9.4\modules\demux\</em></span> (see <a class="xref" href="ch02.html#vlc_demuxer_list" title="Figure 2-1. VLC demuxer list">Figure 2-1</a>).</p><div class="figure"><a id="vlc_demuxer_list"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e717"/><img src="httpatomoreillycomsourcenostarchimages939229.png.jpg" alt="VLC demuxer list"/></div></div><p class="title">Figure 2-1. VLC demuxer list</p></div></div><div class="sect2" title="Step 2: Identify the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_identify_the_input_data"/>Step 2: Identify the Input Data</h2></div></div></div><p>Next, I tried to identify the input data processed by the demuxers. After reading some C code, I stumbled upon the following structure, which is declared in a header file included in every demuxer.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>vlc-0.9.4\include\vlc_demux.h</em></span></p></dd></dl></div><a id="I_programlisting2_d1e736"/><pre class="programlisting">[..]
<strong class="userinput"><code>41    struct demux_t</code></strong>
42    {
43       VLC_COMMON_MEMBERS
44
45       /* Module properties */
46       module_t    *p_module;
47
48       /* eg informative but needed (we can have access+demux) */
49       char        *psz_access;
50       char        *psz_demux;
51       char        *psz_path;
52
<strong class="userinput"><code>53       /* input stream */</code></strong>
<strong class="userinput"><code>54       stream_t    *s;     /* NULL in case of a access+demux in one */</code></strong>
[..]</pre><p>In line 54, the structure element <code class="literal">s</code> is declared and described as <code class="literal">input stream</code>. This was exactly what I was searching for: a reference to the input data that is processed by the demuxers.</p></div><div class="sect2" title="Step 3: Trace the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_trace_the_input_data"/>Step 3: Trace the Input Data</h2></div></div></div><p>After I discovered the <code class="literal">demux_t</code> structure and its input stream element, I searched the demuxer files for references to it. The input data was usually referenced by <code class="literal">p_demux-&gt;s</code>, as shown in lines 1623 and 1641 below. When I found such a reference, I traced the input data while looking for coding errors. Using this approach, I found the following vulnerability.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>vlc-0.9.4\modules\demux\Ty.c</em></span></p></dd><dt><span class="term"><span class="strong"><strong>Function</strong></span></span></dt><dd><p><code class="literal">parse_master()</code></p></dd></dl></div><a id="I_programlisting2_d1e783"/><pre class="programlisting">[..]
1623    static void parse_master(<strong class="userinput"><code>demux_t *p_demux</code></strong>)
1624    {
1625        demux_sys_t *p_sys = p_demux-&gt;p_sys;
<strong class="userinput"><code>1626        uint8_t mst_buf[32];</code></strong>
<strong class="userinput"><code>1627        int i, i_map_size;</code></strong>
1628        int64_t i_save_pos = stream_Tell(p_demux-&gt;s);
1629        int64_t i_pts_secs;
1630
1631        /* Note that the entries in the SEQ table in the stream may have
1632           different sizes depending on the bits per entry.  We store them
1633           all in the same size structure, so we have to parse them out one
1634           by one.  If we had a dynamic structure, we could simply read the
1635           entire table directly from the stream into memory in place. */
1636
1637        /* clear the SEQ table */
1638        free(p_sys-&gt;seq_table);
1639
1640        /* parse header info */
<strong class="userinput"><code>1641        stream_Read(p_demux-&gt;s, mst_buf, 32);</code></strong>
<strong class="userinput"><code>1642        i_map_size = U32_AT(&amp;mst_buf[20]);  /* size of bitmask, in bytes */</code></strong>
1643        p_sys-&gt;i_bits_per_seq_entry = i_map_size * 8;
1644        i = U32_AT(&amp;mst_buf[28]);   /* size of SEQ table, in bytes */
1645        p_sys-&gt;i_seq_table_size = i / (8 + i_map_size);
1646
1647        /* parse all the entries */
1648        p_sys-&gt;seq_table = malloc(p_sys-&gt;i_
seq_table_size * sizeof(ty_seq_table_t));
1649        for (i=0; i&lt;p_sys-&gt;i_seq_table_size; i++) {
<strong class="userinput"><code>1650             stream_Read(p_demux-&gt;s, mst_buf, 8 + i_map_size);</code></strong>
[..]</pre><p>The <code class="literal">stream_Read()</code> function in line 1641 reads 32 bytes of user-controlled data from a TiVo media file (referenced by <code class="literal">p_demux-&gt;s</code>) and stores them in the stack buffer <code class="literal">mst_buf</code>, declared in line 1626. The <code class="literal">U32_AT</code> macro in line 1642 then extracts a user-controlled value from <code class="literal">mst_buf</code> and stores it in the signed int variable <code class="literal">i_map_size</code>. In line 1650, the <code class="literal">stream_Read()</code> function stores user-controlled data from the media file in the stack buffer <code class="literal">mst_buf</code> again. But this time, <code class="literal">stream_Read()</code> uses the user-controlled value of <code class="literal">i_map_size</code> to calculate the size of the data that gets copied into <code class="literal">mst_buf</code>. This leads to a straight stack buffer overflow (see Section A.1) that can be easily exploited.</p><p>Here is the anatomy of the bug, as illustrated in <a class="xref" href="ch02s02.html#overview_of_the_vulnerability_from_input" title="Figure 2-2. Overview of the vulnerability from input to stack buffer overflow">Figure 2-2</a>:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>32 bytes of user-controlled TiVo media file data are copied into the stack buffer <code class="literal">mst_buf</code>. The destination buffer has a size of 32 bytes.</p></li><li class="listitem"><p>4 bytes of user-controlled data are extracted from the buffer and stored in <code class="literal">i_map_size</code>.</p></li><li class="listitem"><p>User-controlled TiVo media-file data is copied into <code class="literal">mst_buf</code> once again. This time, the size of the copied data is calculated using <code class="literal">i_map_size</code>. If <code class="literal">i_map_size</code> has a value greater than 24, a stack buffer overflow will occur (see Section A.1).</p></li></ol></div></div></div></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 2. Back to the ’90s</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="chapter" title="Chapter 2. Back to the ’90s"><div class="titlepage"><div><div><h1 class="title"><a id="back_to_the_a90s"/>Chapter 2. Back to the ’90s</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Sunday, October 12, 2008</em></span><a id="IDX-CHP-2-0001" class="indexterm"/></p><p><span class="emphasis"><em>Dear Diary</em></span>,</p></div><p>I had a look at the source code of VideoLAN’s popular VLC media player today. I like VLC because it supports all different kinds of media files and runs on all my favorite operating system platforms. But supporting all those different media file formats has downsides. VLC does a lot of parsing, and that often means a lot of bugs just waiting to be discovered.<a id="IDX-CHP-2-0002" class="indexterm"/><a id="IDX-CHP-2-0003" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>According to <span class="emphasis"><em>Parsing Techniques: A Practical Guide</em></span> by Dick Grune and Ceriel J.H. Jacobs,<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-1" class="footnoteref">6</a>]</sup> “Parsing is the process of structuring a linear representation in accordance with a given grammar.” A parser is software that breaks apart a raw string of bytes into individual words and statements. Depending on the data format, parsing can be a very complex and error-prone task.<a id="IDX-CHP-2-0004" class="indexterm"/></p></div><p>After I became familiar with the inner workings of VLC, finding the first vulnerability took me only about half a day. It was a classic stack buffer overflow (see Section A.1). This one occurred while parsing a media file format called TiVo, the proprietary format native to TiVo digital recording devices. Before finding this bug, I had never heard of this file format, but that didn’t stop me from exploiting it.<a id="IDX-CHP-2-0005" class="indexterm"/></p><div class="sect1" title="2.1 Vulnerability Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_discovery"/>2.1 Vulnerability Discovery</h1></div></div></div><p>Here is how I found the vulnerability:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: Generate a list of the demuxers of VLC.<a id="IDX-CHP-2-0006" class="indexterm"/></p></li><li class="listitem"><p>Step 2: Identify the input data.</p></li><li class="listitem"><p>Step 3: Trace the input data.</p></li></ul></div><p>I’ll explain this process in detail in the following sections.</p><div class="sect2" title="Step 1: Generate a List of the Demuxers of VLC"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_generate_a_list_of_the_demu"/>Step 1: Generate a List of the Demuxers of VLC</h2></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>I used VLC 0.9.4 on the Microsoft Windows Vista SP1 (32-bit) platform for all the following steps</em></span>.<a id="IDX-CHP-2-0007" class="indexterm"/></p></div><p>After downloading and unpacking the source code of VLC,<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-2" class="footnoteref">7</a>]</sup> I generated a list of the available demuxers of the media player.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In digital video, <span class="emphasis"><em>demuxing</em></span> or <span class="emphasis"><em>demultiplexing</em></span> refers to the process of separating audio and video as well as other data from a video stream or container in order to play the file. A demuxer is software that extracts the components of such a stream or container.</p></div><p>Generating a list of demuxers wasn’t too hard, as VLC separates most of them in different C files in the directory <span class="emphasis"><em>vlc-0.9.4\modules\demux\</em></span> (see <a class="xref" href="ch02.html#vlc_demuxer_list" title="Figure 2-1. VLC demuxer list">Figure 2-1</a>).</p><div class="figure"><a id="vlc_demuxer_list"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e717"/><img src="httpatomoreillycomsourcenostarchimages939229.png.jpg" alt="VLC demuxer list"/></div></div><p class="title">Figure 2-1. VLC demuxer list</p></div></div><div class="sect2" title="Step 2: Identify the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_identify_the_input_data"/>Step 2: Identify the Input Data</h2></div></div></div><p>Next, I tried to identify the input data processed by the demuxers. After reading some C code, I stumbled upon the following structure, which is declared in a header file included in every demuxer.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>vlc-0.9.4\include\vlc_demux.h</em></span></p></dd></dl></div><a id="I_programlisting2_d1e736"/><pre class="programlisting">[..]
<strong class="userinput"><code>41    struct demux_t</code></strong>
42    {
43       VLC_COMMON_MEMBERS
44
45       /* Module properties */
46       module_t    *p_module;
47
48       /* eg informative but needed (we can have access+demux) */
49       char        *psz_access;
50       char        *psz_demux;
51       char        *psz_path;
52
<strong class="userinput"><code>53       /* input stream */</code></strong>
<strong class="userinput"><code>54       stream_t    *s;     /* NULL in case of a access+demux in one */</code></strong>
[..]</pre><p>In line 54, the structure element <code class="literal">s</code> is declared and described as <code class="literal">input stream</code>. This was exactly what I was searching for: a reference to the input data that is processed by the demuxers.</p></div><div class="sect2" title="Step 3: Trace the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_trace_the_input_data"/>Step 3: Trace the Input Data</h2></div></div></div><p>After I discovered the <code class="literal">demux_t</code> structure and its input stream element, I searched the demuxer files for references to it. The input data was usually referenced by <code class="literal">p_demux-&gt;s</code>, as shown in lines 1623 and 1641 below. When I found such a reference, I traced the input data while looking for coding errors. Using this approach, I found the following vulnerability.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>vlc-0.9.4\modules\demux\Ty.c</em></span></p></dd><dt><span class="term"><span class="strong"><strong>Function</strong></span></span></dt><dd><p><code class="literal">parse_master()</code></p></dd></dl></div><a id="I_programlisting2_d1e783"/><pre class="programlisting">[..]
1623    static void parse_master(<strong class="userinput"><code>demux_t *p_demux</code></strong>)
1624    {
1625        demux_sys_t *p_sys = p_demux-&gt;p_sys;
<strong class="userinput"><code>1626        uint8_t mst_buf[32];</code></strong>
<strong class="userinput"><code>1627        int i, i_map_size;</code></strong>
1628        int64_t i_save_pos = stream_Tell(p_demux-&gt;s);
1629        int64_t i_pts_secs;
1630
1631        /* Note that the entries in the SEQ table in the stream may have
1632           different sizes depending on the bits per entry.  We store them
1633           all in the same size structure, so we have to parse them out one
1634           by one.  If we had a dynamic structure, we could simply read the
1635           entire table directly from the stream into memory in place. */
1636
1637        /* clear the SEQ table */
1638        free(p_sys-&gt;seq_table);
1639
1640        /* parse header info */
<strong class="userinput"><code>1641        stream_Read(p_demux-&gt;s, mst_buf, 32);</code></strong>
<strong class="userinput"><code>1642        i_map_size = U32_AT(&amp;mst_buf[20]);  /* size of bitmask, in bytes */</code></strong>
1643        p_sys-&gt;i_bits_per_seq_entry = i_map_size * 8;
1644        i = U32_AT(&amp;mst_buf[28]);   /* size of SEQ table, in bytes */
1645        p_sys-&gt;i_seq_table_size = i / (8 + i_map_size);
1646
1647        /* parse all the entries */
1648        p_sys-&gt;seq_table = malloc(p_sys-&gt;i_
seq_table_size * sizeof(ty_seq_table_t));
1649        for (i=0; i&lt;p_sys-&gt;i_seq_table_size; i++) {
<strong class="userinput"><code>1650             stream_Read(p_demux-&gt;s, mst_buf, 8 + i_map_size);</code></strong>
[..]</pre><p>The <code class="literal">stream_Read()</code> function in line 1641 reads 32 bytes of user-controlled data from a TiVo media file (referenced by <code class="literal">p_demux-&gt;s</code>) and stores them in the stack buffer <code class="literal">mst_buf</code>, declared in line 1626. The <code class="literal">U32_AT</code> macro in line 1642 then extracts a user-controlled value from <code class="literal">mst_buf</code> and stores it in the signed int variable <code class="literal">i_map_size</code>. In line 1650, the <code class="literal">stream_Read()</code> function stores user-controlled data from the media file in the stack buffer <code class="literal">mst_buf</code> again. But this time, <code class="literal">stream_Read()</code> uses the user-controlled value of <code class="literal">i_map_size</code> to calculate the size of the data that gets copied into <code class="literal">mst_buf</code>. This leads to a straight stack buffer overflow (see Section A.1) that can be easily exploited.</p><p>Here is the anatomy of the bug, as illustrated in <a class="xref" href="ch02s02.html#overview_of_the_vulnerability_from_input" title="Figure 2-2. Overview of the vulnerability from input to stack buffer overflow">Figure 2-2</a>:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>32 bytes of user-controlled TiVo media file data are copied into the stack buffer <code class="literal">mst_buf</code>. The destination buffer has a size of 32 bytes.</p></li><li class="listitem"><p>4 bytes of user-controlled data are extracted from the buffer and stored in <code class="literal">i_map_size</code>.</p></li><li class="listitem"><p>User-controlled TiVo media-file data is copied into <code class="literal">mst_buf</code> once again. This time, the size of the copied data is calculated using <code class="literal">i_map_size</code>. If <code class="literal">i_map_size</code> has a value greater than 24, a stack buffer overflow will occur (see Section A.1).</p></li></ol></div></div></div></div></body></html>
