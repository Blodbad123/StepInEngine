<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Appendix A. Hints for Hunting</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="appendix" title="Appendix A. Hints for Hunting"><div class="titlepage"><div><div><h1 class="title"><a id="hints_for_hunting"/>Appendix A. Hints for Hunting</h1></div></div></div><p>This appendix describes, in more depth than in the text, some vulnerability classes, exploitation techniques, and common issues that can lead to bugs.</p><div class="sect1" title="A.1 Stack Buffer Overflows"><div class="titlepage"><div><div><h1 class="title"><a id="a.1_stack_buffer_overflows"/>A.1 Stack Buffer Overflows</h1></div></div></div><p>Buffer overflows are memory corruption vulnerabilities that can be categorized by <span class="emphasis"><em>type</em></span> (also known as <span class="emphasis"><em>generation</em></span>). Today the most relevant ones are <span class="emphasis"><em>stack buffer overflows</em></span> and <span class="emphasis"><em>heap buffer overflows</em></span>. A buffer overflow happens if more data is copied into a buffer or array than the buffer or array can handle. It’s that simple. As the name implies, stack buffer overflows are happening in the stack area of a process memory. The stack is a special memory area of a process that holds both data and metadata associated with procedure invocation. If more data is stuffed in a buffer declared on the stack than that buffer can handle, adjacent stack memory may be overwritten. If the user can control the data and the amount of data, it is possible to manipulate the stack data or metadata to gain control of the execution flow of the process.<a id="IDX-APP-A-0030" class="indexterm"/><a id="IDX-APP-A-0031" class="indexterm"/><a id="IDX-APP-A-0032" class="indexterm"/><a id="IDX-APP-A-0033" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>The following descriptions of stack buffer overflows are related to the 32-bit Intel platform (IA-32)</em></span>.<a id="IDX-APP-A-0034" class="indexterm"/></p></div><p>Every function of a process that is executed is represented on the stack. The organization of this information is called a <span class="emphasis"><em>stack frame</em></span>. A stack frame includes the data and metadata of the function, as well as a <span class="emphasis"><em>return address</em></span> used to find the caller of the function. When a function returns to its caller, the return address is popped from the stack and into the instruction pointer (program counter) register. If you can overflow a stack buffer and then overwrite the return address with a value of your choosing, you get control over the instruction pointer when the function returns.<a id="IDX-APP-A-0035" class="indexterm"/><a id="IDX-APP-A-0036" class="indexterm"/><a id="IDX-APP-A-0037" class="indexterm"/><a id="IDX-APP-A-0038" class="indexterm"/><a id="IDX-APP-A-0039" class="indexterm"/><a id="IDX-APP-A-0040" class="indexterm"/></p><p>There are a lot of other possible ways to take advantage of a stack buffer overflow for example, by manipulating function pointers, function arguments, or other important data and metadata on the stack.</p><p>Let’s look at an example program:</p><div class="example"><a id="example_program_stackoverflow.c"/><p class="title">Example A-1. Example program <span class="emphasis"><em>stackoverflow.c</em></span></p><div class="example-contents"><pre class="programlisting">01    #include &lt;string.h&gt;
02
03    void
04    overflow (char *arg)
05    {
06        char  buf[12];
07
08        strcpy (buf, arg);
09    }
10
11    int
12    main (int argc, char *argv[])
13    {
14        if (argc &gt; 1)
15            overflow (argv[1]);
16
17        return 0;
18    }</pre></div></div><p>The example program in <a class="xref" href="apa.html#example_program_stackoverflow.c" title="Example A-1. Example program stackoverflow.c">Example A-1</a> contains a simple stack buffer overflow. The first command-line argument (line 15) is used as a parameter for the function called <code class="literal">overflow()</code>. In <code class="literal">overflow()</code>, the user-derived data is copied into a stack buffer with a fixed size of 12 bytes (see lines 6 and 8). If we supply more data than the buffer can hold (more than 12 bytes), the stack buffer will overflow, and the adjacent stack data will be overwritten with our input data.</p><p><a class="xref" href="apa.html#stack_frame_illustrating_a_buffer_overfl" title="Figure A-1. Stack frame illustrating a buffer overflow">Figure A-1</a> illustrates the stack layout right before and after the buffer overflow. The stack grows downward (toward lower memory addresses), and the <span class="emphasis"><em>return address (RET)</em></span> is followed by another piece of metadata called the <span class="emphasis"><em>saved frame pointer (SFP)</em></span>. Below that is the buffer that is declared in the <code class="literal">overflow()</code> function. In contrast to the stack, which grows downward, the data that is filled into a stack buffer grows toward higher memory addresses. If we supply a sufficient amount of data for the first command-line argument, then our data will overwrite the buffer, the SFP, the RET, and adjacent stack memory. If the function then returns, we control the value of RET, which gives us control over the instruction pointer (<code class="literal">EIP</code> register).<a id="IDX-APP-A-0041" class="indexterm"/></p><div class="figure"><a id="stack_frame_illustrating_a_buffer_overfl"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_d1e9857"/><img src="httpatomoreillycomsourcenostarchimages939337.png.jpg" alt="Stack frame illustrating a buffer overflow"/></div></div><p class="title">Figure A-1. Stack frame illustrating a buffer overflow</p></div><div class="sect2" title="Example: Stack Buffer Overflow Under Linux"><div class="titlepage"><div><div><h2 class="title"><a id="example_colon_stack_buffer_overflow_unde"/>Example: Stack Buffer Overflow Under Linux</h2></div></div></div><p>To test the program from <a class="xref" href="apa.html#example_program_stackoverflow.c" title="Example A-1. Example program stackoverflow.c">Example A-1</a> under Linux (Ubuntu 9.04), I compiled it without stack canary support (see Section C.1):<a id="IDX-APP-A-0042" class="indexterm"/><a id="IDX-APP-A-0043" class="indexterm"/></p><a id="I_programlisting_d1e9877"/><pre class="programlisting">linux$ <strong class="userinput"><code>gcc -fno-stack-protector -o stackoverflow stackoverflow.c</code></strong></pre><p>Then, I started the program in the debugger (see Section B.4 for more information about gdb) while supplying 20 bytes of user input as a command-line argument (12 bytes to fill the stack buffer plus 4 bytes for the SFP plus 4 bytes for the RET):</p><a id="I_programlisting_d1e9883"/><pre class="programlisting">linux$ <strong class="userinput"><code>gdb -q ./stackoverflow</code></strong>

(gdb) <strong class="userinput"><code>run $(perl -e 'print "A"x12 . "B"x4 . "C"x4')</code></strong>
Starting program: /home/tk/BHD/stackoverflow $(perl -e 'print "A"x12 . "B"x4 . "C"x4')

Program received signal SIGSEGV, Segmentation fault.
<strong class="userinput"><code>0x43434343 in ?? ()</code></strong>

(gdb) <strong class="userinput"><code>info registers</code></strong>
eax            0xbfab9fac     −1079271508
ecx            0xbfab9fab     −1079271509
edx            0x15           21
ebx            0xb8088ff4     −1207398412
esp            0xbfab9fc0     0xbfab9fc0
ebp            0x42424242     0x42424242
esi            0x8048430      134513712
edi            0x8048310      134513424
<strong class="userinput"><code>eip            0x43434343     0x43434343</code></strong>
eflags         0x10246   [ PF ZF IF RF ]
cs             0x73      115
ss             0x7b      123
ds             0x7b      123
es             0x7b      123
fs             0x0       0
gs             0x33      51</pre><p>I gained control over the instruction pointer (see the <code class="literal">EIP</code> register), as the return address was successfully overwritten with the four <code class="literal">C</code>s supplied from the user input (hexadecimal value of the four <code class="literal">C</code>s: <code class="literal">0x43434343</code>).</p></div><div class="sect2" title="Example: Stack Buffer Overflow Under Windows"><div class="titlepage"><div><div><h2 class="title"><a id="example_colon_stack_buffer_overflow"/>Example: Stack Buffer Overflow Under Windows</h2></div></div></div><p>I compiled the vulnerable program from <a class="xref" href="apa.html#example_program_stackoverflow.c" title="Example A-1. Example program stackoverflow.c">Example A-1</a> without security cookie (<code class="literal">/GS</code>) support under Windows Vista SP2 (see Section C.1):<a id="IDX-APP-A-0044" class="indexterm"/><a id="IDX-APP-A-0045" class="indexterm"/><a id="IDX-APP-A-0046" class="indexterm"/></p><a id="I_programlisting_d1e9934"/><pre class="programlisting">C:\Users\tk\BHD&gt;<strong class="userinput"><code>cl /nologo /GS- stackoverflow.c</code></strong>
stackoverflow.c</pre><p>Then, I started the program in the debugger (see Section B.2 for more information about WinDbg) while supplying the same input data as in the Linux example above.</p><p>As <a class="xref" href="apa.html#stack_buffer_overflow_under_windows_open" title="Figure A-2. Stack buffer overflow under Windows (WinDbg output)">Figure A-2</a> shows, I got the same result as under Linux: control over the instruction pointer (see the <code class="literal">EIP</code> register).</p><div class="figure"><a id="stack_buffer_overflow_under_windows_open"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_d1e9951"/><img src="httpatomoreillycomsourcenostarchimages939339.png.jpg" alt="Stack buffer overflow under Windows (WinDbg output)"/></div></div><p class="title">Figure A-2. Stack buffer overflow under Windows (WinDbg output)</p></div><p>This was only a short introduction to the world of buffer overflows. Numerous books and white papers are available on this topic. If you want to learn more, I recommend Jon Erickson’s <span class="emphasis"><em>Hacking: The Art of Exploitation</em></span>, 2nd edition (No Starch Press, 2008), or you can type <span class="emphasis"><em>buffer overflows</em></span> into Google and browse the enormous amount of material available online.</p></div></div></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Appendix A. Hints for Hunting</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="appendix" title="Appendix A. Hints for Hunting"><div class="titlepage"><div><div><h1 class="title"><a id="hints_for_hunting"/>Appendix A. Hints for Hunting</h1></div></div></div><p>This appendix describes, in more depth than in the text, some vulnerability classes, exploitation techniques, and common issues that can lead to bugs.</p><div class="sect1" title="A.1 Stack Buffer Overflows"><div class="titlepage"><div><div><h1 class="title"><a id="a.1_stack_buffer_overflows"/>A.1 Stack Buffer Overflows</h1></div></div></div><p>Buffer overflows are memory corruption vulnerabilities that can be categorized by <span class="emphasis"><em>type</em></span> (also known as <span class="emphasis"><em>generation</em></span>). Today the most relevant ones are <span class="emphasis"><em>stack buffer overflows</em></span> and <span class="emphasis"><em>heap buffer overflows</em></span>. A buffer overflow happens if more data is copied into a buffer or array than the buffer or array can handle. It’s that simple. As the name implies, stack buffer overflows are happening in the stack area of a process memory. The stack is a special memory area of a process that holds both data and metadata associated with procedure invocation. If more data is stuffed in a buffer declared on the stack than that buffer can handle, adjacent stack memory may be overwritten. If the user can control the data and the amount of data, it is possible to manipulate the stack data or metadata to gain control of the execution flow of the process.<a id="IDX-APP-A-0030" class="indexterm"/><a id="IDX-APP-A-0031" class="indexterm"/><a id="IDX-APP-A-0032" class="indexterm"/><a id="IDX-APP-A-0033" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>The following descriptions of stack buffer overflows are related to the 32-bit Intel platform (IA-32)</em></span>.<a id="IDX-APP-A-0034" class="indexterm"/></p></div><p>Every function of a process that is executed is represented on the stack. The organization of this information is called a <span class="emphasis"><em>stack frame</em></span>. A stack frame includes the data and metadata of the function, as well as a <span class="emphasis"><em>return address</em></span> used to find the caller of the function. When a function returns to its caller, the return address is popped from the stack and into the instruction pointer (program counter) register. If you can overflow a stack buffer and then overwrite the return address with a value of your choosing, you get control over the instruction pointer when the function returns.<a id="IDX-APP-A-0035" class="indexterm"/><a id="IDX-APP-A-0036" class="indexterm"/><a id="IDX-APP-A-0037" class="indexterm"/><a id="IDX-APP-A-0038" class="indexterm"/><a id="IDX-APP-A-0039" class="indexterm"/><a id="IDX-APP-A-0040" class="indexterm"/></p><p>There are a lot of other possible ways to take advantage of a stack buffer overflow for example, by manipulating function pointers, function arguments, or other important data and metadata on the stack.</p><p>Let’s look at an example program:</p><div class="example"><a id="example_program_stackoverflow.c"/><p class="title">Example A-1. Example program <span class="emphasis"><em>stackoverflow.c</em></span></p><div class="example-contents"><pre class="programlisting">01    #include &lt;string.h&gt;
02
03    void
04    overflow (char *arg)
05    {
06        char  buf[12];
07
08        strcpy (buf, arg);
09    }
10
11    int
12    main (int argc, char *argv[])
13    {
14        if (argc &gt; 1)
15            overflow (argv[1]);
16
17        return 0;
18    }</pre></div></div><p>The example program in <a class="xref" href="apa.html#example_program_stackoverflow.c" title="Example A-1. Example program stackoverflow.c">Example A-1</a> contains a simple stack buffer overflow. The first command-line argument (line 15) is used as a parameter for the function called <code class="literal">overflow()</code>. In <code class="literal">overflow()</code>, the user-derived data is copied into a stack buffer with a fixed size of 12 bytes (see lines 6 and 8). If we supply more data than the buffer can hold (more than 12 bytes), the stack buffer will overflow, and the adjacent stack data will be overwritten with our input data.</p><p><a class="xref" href="apa.html#stack_frame_illustrating_a_buffer_overfl" title="Figure A-1. Stack frame illustrating a buffer overflow">Figure A-1</a> illustrates the stack layout right before and after the buffer overflow. The stack grows downward (toward lower memory addresses), and the <span class="emphasis"><em>return address (RET)</em></span> is followed by another piece of metadata called the <span class="emphasis"><em>saved frame pointer (SFP)</em></span>. Below that is the buffer that is declared in the <code class="literal">overflow()</code> function. In contrast to the stack, which grows downward, the data that is filled into a stack buffer grows toward higher memory addresses. If we supply a sufficient amount of data for the first command-line argument, then our data will overwrite the buffer, the SFP, the RET, and adjacent stack memory. If the function then returns, we control the value of RET, which gives us control over the instruction pointer (<code class="literal">EIP</code> register).<a id="IDX-APP-A-0041" class="indexterm"/></p><div class="figure"><a id="stack_frame_illustrating_a_buffer_overfl"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_d1e9857"/><img src="httpatomoreillycomsourcenostarchimages939337.png.jpg" alt="Stack frame illustrating a buffer overflow"/></div></div><p class="title">Figure A-1. Stack frame illustrating a buffer overflow</p></div><div class="sect2" title="Example: Stack Buffer Overflow Under Linux"><div class="titlepage"><div><div><h2 class="title"><a id="example_colon_stack_buffer_overflow_unde"/>Example: Stack Buffer Overflow Under Linux</h2></div></div></div><p>To test the program from <a class="xref" href="apa.html#example_program_stackoverflow.c" title="Example A-1. Example program stackoverflow.c">Example A-1</a> under Linux (Ubuntu 9.04), I compiled it without stack canary support (see Section C.1):<a id="IDX-APP-A-0042" class="indexterm"/><a id="IDX-APP-A-0043" class="indexterm"/></p><a id="I_programlisting_d1e9877"/><pre class="programlisting">linux$ <strong class="userinput"><code>gcc -fno-stack-protector -o stackoverflow stackoverflow.c</code></strong></pre><p>Then, I started the program in the debugger (see Section B.4 for more information about gdb) while supplying 20 bytes of user input as a command-line argument (12 bytes to fill the stack buffer plus 4 bytes for the SFP plus 4 bytes for the RET):</p><a id="I_programlisting_d1e9883"/><pre class="programlisting">linux$ <strong class="userinput"><code>gdb -q ./stackoverflow</code></strong>

(gdb) <strong class="userinput"><code>run $(perl -e 'print "A"x12 . "B"x4 . "C"x4')</code></strong>
Starting program: /home/tk/BHD/stackoverflow $(perl -e 'print "A"x12 . "B"x4 . "C"x4')

Program received signal SIGSEGV, Segmentation fault.
<strong class="userinput"><code>0x43434343 in ?? ()</code></strong>

(gdb) <strong class="userinput"><code>info registers</code></strong>
eax            0xbfab9fac     −1079271508
ecx            0xbfab9fab     −1079271509
edx            0x15           21
ebx            0xb8088ff4     −1207398412
esp            0xbfab9fc0     0xbfab9fc0
ebp            0x42424242     0x42424242
esi            0x8048430      134513712
edi            0x8048310      134513424
<strong class="userinput"><code>eip            0x43434343     0x43434343</code></strong>
eflags         0x10246   [ PF ZF IF RF ]
cs             0x73      115
ss             0x7b      123
ds             0x7b      123
es             0x7b      123
fs             0x0       0
gs             0x33      51</pre><p>I gained control over the instruction pointer (see the <code class="literal">EIP</code> register), as the return address was successfully overwritten with the four <code class="literal">C</code>s supplied from the user input (hexadecimal value of the four <code class="literal">C</code>s: <code class="literal">0x43434343</code>).</p></div><div class="sect2" title="Example: Stack Buffer Overflow Under Windows"><div class="titlepage"><div><div><h2 class="title"><a id="example_colon_stack_buffer_overflow"/>Example: Stack Buffer Overflow Under Windows</h2></div></div></div><p>I compiled the vulnerable program from <a class="xref" href="apa.html#example_program_stackoverflow.c" title="Example A-1. Example program stackoverflow.c">Example A-1</a> without security cookie (<code class="literal">/GS</code>) support under Windows Vista SP2 (see Section C.1):<a id="IDX-APP-A-0044" class="indexterm"/><a id="IDX-APP-A-0045" class="indexterm"/><a id="IDX-APP-A-0046" class="indexterm"/></p><a id="I_programlisting_d1e9934"/><pre class="programlisting">C:\Users\tk\BHD&gt;<strong class="userinput"><code>cl /nologo /GS- stackoverflow.c</code></strong>
stackoverflow.c</pre><p>Then, I started the program in the debugger (see Section B.2 for more information about WinDbg) while supplying the same input data as in the Linux example above.</p><p>As <a class="xref" href="apa.html#stack_buffer_overflow_under_windows_open" title="Figure A-2. Stack buffer overflow under Windows (WinDbg output)">Figure A-2</a> shows, I got the same result as under Linux: control over the instruction pointer (see the <code class="literal">EIP</code> register).</p><div class="figure"><a id="stack_buffer_overflow_under_windows_open"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_d1e9951"/><img src="httpatomoreillycomsourcenostarchimages939339.png.jpg" alt="Stack buffer overflow under Windows (WinDbg output)"/></div></div><p class="title">Figure A-2. Stack buffer overflow under Windows (WinDbg output)</p></div><p>This was only a short introduction to the world of buffer overflows. Numerous books and white papers are available on this topic. If you want to learn more, I recommend Jon Erickson’s <span class="emphasis"><em>Hacking: The Art of Exploitation</em></span>, 2nd edition (No Starch Press, 2008), or you can type <span class="emphasis"><em>buffer overflows</em></span> into Google and browse the enormous amount of material available online.</p></div></div></div></body></html>
