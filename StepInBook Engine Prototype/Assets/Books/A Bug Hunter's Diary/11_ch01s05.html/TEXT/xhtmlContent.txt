<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>1.5 EIP = 41414141</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="1.5 EIP = 41414141"><div class="titlepage"><div><div><h1 class="title"><a id="eip_equals_41414141"/>1.5 EIP = 41414141</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Instruction pointer/Program counter:</em></span><a id="IDX-CHP-1-0036" class="indexterm"/><a id="IDX-CHP-1-0037" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>EIP—32-bit instruction pointer (IA-32)</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>RIP—64-bit instruction pointer (Intel 64)</em></span><a id="IDX-CHP-1-0038" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>R15 or PC—ARM architecture as used on Apple’s iPhone</em></span></p></li></ul></div></div><p>To illustrate the security implications of the bugs that I found, I will discuss the steps needed to gain control of the execution flow of the vulnerable program by controlling the instruction pointer (IP) of the CPU. The instruction pointer or program counter (PC) register contains the offset in the current code segment for the next instruction to be executed.<sup>[<a href="ch01s06.html#ftn.CHP-1-FN-5" class="footnoteref">5</a>]</sup> If you gain control of this register, you fully control the execution flow of the vulnerable process. To demonstrate instruction pointer control, I will modify the register to values like <code class="literal">0x41414141</code> (hexadecimal representation of ASCII “<code class="literal">AAAA</code>”), <code class="literal">0x41424344</code> (hexadecimal representation of ASCII “<code class="literal">ABCD</code>”), or something similar. So if you see <code class="literal">EIP = 41414141</code> in the following chapters, it means that I’ve gained control of the vulnerable process.<a id="IDX-CHP-1-0039" class="indexterm"/></p><p>Once you achieve control over the instruction pointer, there are many ways to turn it into a fully working, weaponized exploit. For more information on the process of exploit development, you can refer to Jon Erickson’s <span class="emphasis"><em>Hacking: The Art of Exploitation</em></span>, 2nd edition (No Starch Press, 2008), or you can type <span class="emphasis"><em>exploit writing</em></span> into Google and browse through the enormous amount of material available online.</p></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>1.5 EIP = 41414141</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="1.5 EIP = 41414141"><div class="titlepage"><div><div><h1 class="title"><a id="eip_equals_41414141"/>1.5 EIP = 41414141</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Instruction pointer/Program counter:</em></span><a id="IDX-CHP-1-0036" class="indexterm"/><a id="IDX-CHP-1-0037" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>EIP—32-bit instruction pointer (IA-32)</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>RIP—64-bit instruction pointer (Intel 64)</em></span><a id="IDX-CHP-1-0038" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>R15 or PC—ARM architecture as used on Apple’s iPhone</em></span></p></li></ul></div></div><p>To illustrate the security implications of the bugs that I found, I will discuss the steps needed to gain control of the execution flow of the vulnerable program by controlling the instruction pointer (IP) of the CPU. The instruction pointer or program counter (PC) register contains the offset in the current code segment for the next instruction to be executed.<sup>[<a href="ch01s06.html#ftn.CHP-1-FN-5" class="footnoteref">5</a>]</sup> If you gain control of this register, you fully control the execution flow of the vulnerable process. To demonstrate instruction pointer control, I will modify the register to values like <code class="literal">0x41414141</code> (hexadecimal representation of ASCII “<code class="literal">AAAA</code>”), <code class="literal">0x41424344</code> (hexadecimal representation of ASCII “<code class="literal">ABCD</code>”), or something similar. So if you see <code class="literal">EIP = 41414141</code> in the following chapters, it means that I’ve gained control of the vulnerable process.<a id="IDX-CHP-1-0039" class="indexterm"/></p><p>Once you achieve control over the instruction pointer, there are many ways to turn it into a fully working, weaponized exploit. For more information on the process of exploit development, you can refer to Jon Erickson’s <span class="emphasis"><em>Hacking: The Art of Exploitation</em></span>, 2nd edition (No Starch Press, 2008), or you can type <span class="emphasis"><em>exploit writing</em></span> into Google and browse through the enormous amount of material available online.</p></div></body></html>
