<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>3.3 Vulnerability Remediation</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="3.3 Vulnerability Remediation"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_remediation-id1"/>3.3 Vulnerability Remediation</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Thursday, June 12, 2008</em></span></p></div><p>After I informed Sun about the bug, it developed the following patch to address the vulnerability:<sup>[<a href="ch03s05.html#ftn.CHP-3-FN-13" class="footnoteref">35</a>]</sup></p><a id="I_programlisting3_d1e3313"/><pre class="programlisting">[..]
19165    if (*cp == IPIF_SEPARATOR_CHAR) {
19166        /*
19167         * Reject any non-decimal aliases for logical
19168         * interfaces. Aliases with leading zeroes
19169         * are also rejected as they introduce ambiguity
19170         * in the naming of the interfaces.
19171         * In order to confirm with existing semantics,
19172         * and to not break any programs/script relying
19173         * on that behaviour, if&lt;0&gt;:0 is considered to be
19174         * a valid interface.
19175         *
19176         * If alias has two or more digits and the first
19177         * is zero, fail.
19178         */
19179        if (&amp;cp[2] &lt; endp &amp;&amp; cp[1] == '0') {
<strong class="userinput"><code>19180            if (error != NULL)</code></strong>
<strong class="userinput"><code>19181                *error = EINVAL;</code></strong>
19182            return (NULL);
19183        }
[..]</pre><p>To fix the bug, Sun introduced the new error definition in lines 19180 and 19181 of <code class="literal">ipif_lookup_on_name()</code>. That successfully prevents the NULL pointer dereference from happening. Although this measure rectifies the vulnerability described in this chapter, it doesn’t solve the basic problem. The <code class="literal">ipif_lookup_on_name()</code> function, as well as other kernel functions, still report error conditions to their caller functions in two different ways, so chances are good that a similar bug will occur again if the API isn’t used with great care. Sun should have changed the API to prevent future bugs, but it didn’t.</p></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>3.3 Vulnerability Remediation</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="3.3 Vulnerability Remediation"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_remediation-id1"/>3.3 Vulnerability Remediation</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Thursday, June 12, 2008</em></span></p></div><p>After I informed Sun about the bug, it developed the following patch to address the vulnerability:<sup>[<a href="ch03s05.html#ftn.CHP-3-FN-13" class="footnoteref">35</a>]</sup></p><a id="I_programlisting3_d1e3313"/><pre class="programlisting">[..]
19165    if (*cp == IPIF_SEPARATOR_CHAR) {
19166        /*
19167         * Reject any non-decimal aliases for logical
19168         * interfaces. Aliases with leading zeroes
19169         * are also rejected as they introduce ambiguity
19170         * in the naming of the interfaces.
19171         * In order to confirm with existing semantics,
19172         * and to not break any programs/script relying
19173         * on that behaviour, if&lt;0&gt;:0 is considered to be
19174         * a valid interface.
19175         *
19176         * If alias has two or more digits and the first
19177         * is zero, fail.
19178         */
19179        if (&amp;cp[2] &lt; endp &amp;&amp; cp[1] == '0') {
<strong class="userinput"><code>19180            if (error != NULL)</code></strong>
<strong class="userinput"><code>19181                *error = EINVAL;</code></strong>
19182            return (NULL);
19183        }
[..]</pre><p>To fix the bug, Sun introduced the new error definition in lines 19180 and 19181 of <code class="literal">ipif_lookup_on_name()</code>. That successfully prevents the NULL pointer dereference from happening. Although this measure rectifies the vulnerability described in this chapter, it doesn’t solve the basic problem. The <code class="literal">ipif_lookup_on_name()</code> function, as well as other kernel functions, still report error conditions to their caller functions in two different ways, so chances are good that a similar bug will occur again if the API isn’t used with great care. Sun should have changed the API to prevent future bugs, but it didn’t.</p></div></body></html>
