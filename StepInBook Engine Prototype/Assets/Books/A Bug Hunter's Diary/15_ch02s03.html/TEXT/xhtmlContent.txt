<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>2.3 Vulnerability Remediation</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="2.3 Vulnerability Remediation"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_remediation"/>2.3 Vulnerability Remediation</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Saturday, October 18, 2008</em></span></p></div><p>Now that I’ve discovered a security vulnerability, I could disclose it in several ways. I could contact the software developer and “responsibly” tell him what I’ve found and help him to create a patch. This process is referred to as <span class="emphasis"><em>responsible disclosure</em></span>. Since this term implies that other means of disclosure are irresponsible, which isn’t necessarily true, it is slowly being replaced by <span class="emphasis"><em>coordinated disclosure</em></span>.<a id="IDX-CHP-2-0020" class="indexterm"/><a id="IDX-CHP-2-0021" class="indexterm"/></p><p>On the other hand, I could sell my findings to a <span class="emphasis"><em>vulnerability broker</em></span> and let him tell the software developer. Today, the two primary players in the commercial vulnerability market are Verisign’s iDefense Labs, with its Vulnerability Contribution Program (VCP), and Tipping Point’s Zero Day Initiative (ZDI). Both VCP and ZDI follow coordinated-disclosure practices and work with the affected vendor.<a id="IDX-CHP-2-0022" class="indexterm"/></p><p>Another option is <span class="emphasis"><em>full disclosure</em></span>. If I chose full disclosure, I would release the vulnerability information to the public without notifying the vendor. There are other disclosure options, but the motivation behind them usually doesn’t involve fixing the bug (for example, selling the findings in underground markets).<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-6" class="footnoteref">11</a>]</sup><a id="IDX-CHP-2-0023" class="indexterm"/></p><p>In the case of the VLC vulnerability described in this chapter, I chose coordinated disclosure. In other words, I notified the VLC maintainers, provided them with the necessary information, and coordinated with them on the timing of public disclosure.</p><p>After I informed the VLC maintainers about the bug, they developed the following patch to address the vulnerability:<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-7" class="footnoteref">12</a>]</sup></p><a id="I_programlisting2_d1e1254"/><pre class="programlisting">--- a/modules/demux/ty.c
+++ b/modules/demux/ty.c
@@ −1639,12 +1639,14 @@ static void parse_master(demux_t *p_demux)
     /* parse all the entries */
     p_sys-&gt;seq_table = malloc(p_sys-&gt;i_seq_table_size * sizeof(ty_seq_table_t));
     for (i=0; i&lt;p_sys-&gt;i_seq_table_size; i++) {
<strong class="userinput"><code>-        stream_Read(p_demux-&gt;s, mst_buf, 8 + i_map_size);</code></strong>
<strong class="userinput"><code>+        stream_Read(p_demux-&gt;s, mst_buf, 8);</code></strong>
         p_sys-&gt;seq_table[i].l_timestamp = U64_AT(&amp;mst_buf[0]);
         if (i_map_size &gt; 8) {
             msg_Err(p_demux, "Unsupported SEQ bitmap size in master chunk");
<strong class="userinput"><code>+            stream_Read(p_demux-&gt;s, NULL, i_map_size);</code></strong>
             memset(p_sys-&gt;seq_table[i].chunk_bitmask, i_map_size, 0);
         } else {
<strong class="userinput"><code>+            stream_Read(p_demux-&gt;s, mst_buf + 8, i_map_size);</code></strong>
             memcpy(p_sys-&gt;seq_table[i].chunk_bitmask, &amp;mst_buf[8], i_map_size);
         }
     }</pre><p>The changes are quite straightforward. The formerly vulnerable call to <code class="literal">stream_Read()</code> now uses a fixed size value, and the user-controlled value of <code class="literal">i_map_size</code> is used only as a size value for <code class="literal">stream_Read()</code> if it is less than or equal to 8. An easy fix for an obvious bug.<a id="IDX-CHP-2-0024" class="indexterm"/><a id="IDX-CHP-2-0025" class="indexterm"/><a id="IDX-CHP-2-0026" class="indexterm"/><a id="IDX-CHP-2-0027" class="indexterm"/><a id="IDX-CHP-2-0028" class="indexterm"/></p><p>But wait—is the vulnerability really gone? The variable <code class="literal">i_map_size</code> is still of the type signed int. If a value greater than or equal to <code class="literal">0x80000000</code> is supplied for <code class="literal">i_map_size</code>, it’s interpreted as negative, and the overflow will still occur in the <code class="literal">stream_Read()</code> and <code class="literal">memcpy()</code> functions of the <code class="literal">else</code> branch of the patch (see Section A.3 for a description of unsigned int and signed int ranges). I also reported this problem to the VLC maintainers, resulting in another patch:<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-8" class="footnoteref">13</a>]</sup></p><a id="I_programlisting2_d1e1317"/><pre class="programlisting">[..]
@@ −1616,7 +1618,7 @@ static void parse_master(demux_t *p_demux)

 {
     demux_sys_t *p_sys = p_demux-&gt;p_sys;
     uint8_t mst_buf[32];
<strong class="userinput"><code>-    int i, i_map_size;</code></strong>
<strong class="userinput"><code>+    uint32_t i, i_map_size;</code></strong>
     int64_t i_save_pos = stream_Tell(p_demux-&gt;s);
     int64_t i_pts_secs;
[..]</pre><p>Now that <code class="literal">i_map_size</code> is of the type unsigned int, this bug is fixed. Perhaps you’ve already noticed that the <code class="literal">parse_master()</code> function contains another buffer overflow vulnerability. I also reported that bug to the VLC maintainers. If you can’t spot it, then take a closer look at the second patch provided by the VLC maintainers, which fixed this bug as well.</p><p>One thing that surprised me was the fact that none of the lauded exploit mitigation techniques of Windows Vista were able to stop me from taking control of <code class="literal">EIP</code> and executing arbitrary code from the stack using the <code class="literal">jmp reg</code> technique. The security cookie or /GS feature should have prevented the manipulation of the return address. Furthermore, ASLR or NX/DEP should have prevented arbitrary code execution. (See Section C.1 for a detailed description of all of these mitigation techniques.)<a id="IDX-CHP-2-0029" class="indexterm"/><a id="IDX-CHP-2-0030" class="indexterm"/><a id="IDX-CHP-2-0031" class="indexterm"/></p><p>To solve this mystery, I downloaded Process Explorer<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-9" class="footnoteref">14</a>]</sup> and configured it to show the processes’ DEP and ASLR status.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>To configure Process Explorer to show the processes’ DEP and ASLR status, I added the following columns to the view: <span class="strong"><strong>View</strong></span> ▸ <span class="strong"><strong>Select Columns</strong></span> ▸ <span class="strong"><strong>DEP Status</strong></span> and <span class="strong"><strong>View</strong></span> ▸ <span class="strong"><strong>Select Columns</strong></span> ▸ <span class="strong"><strong>ASLR Enabled</strong></span>. Additionally, I set the lower pane to view DLLs for a process and added the “ASLR Enabled” column.</p></div><p>The output of Process Explorer, illustrated in <a class="xref" href="ch02s03.html#vlc_in_process_explorer" title="Figure 2-8. VLC in Process Explorer">Figure 2-8</a>, shows that VLC and its modules use neither DEP nor ASLR (this is denoted by an empty value in the DEP and ASLR columns). I investigated further to determine why the VLC process does not use these mitigation techniques.</p><div class="figure"><a id="vlc_in_process_explorer"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1384"/><img src="httpatomoreillycomsourcenostarchimages939243.png.jpg" alt="VLC in Process Explorer"/></div></div><p class="title">Figure 2-8. VLC in Process Explorer</p></div><p>DEP can be controlled by system policy through special APIs and compile-time options (see Microsoft’s Security Research and Defense blog<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-10" class="footnoteref">15</a>]</sup> for more information on DEP). The default system-wide DEP policy for client operating systems such as Windows Vista is called OptIn. In this mode of operation, DEP is enabled only for processes that explicitly opt in to DEP. Because I used a default installation of Windows Vista 32-bit, the system-wide DEP policy should be set to OptIn. To verify this, I used the <code class="literal">bcdedit.exe</code> console application from an elevated command prompt:</p><a id="I_programlisting2_d1e1396"/><pre class="programlisting">C:\Windows\system32&gt;<strong class="userinput"><code>bcdedit /enum | findstr nx</code></strong>
nx                      OptIn</pre><p>The output of the command shows that the system was indeed configured to use the OptIn operation mode of DEP, which explains why VLC doesn’t use this mitigation technique: The process simply doesn’t opt in to DEP.</p><p>There are different ways to opt a process in to DEP. For example, you could use the appropriate linker switch (/NXCOMPAT) at compile time, or you could use the <code class="literal">SetProcessDEPPolicy</code> API to allow an application to opt in to DEP programmatically.<a id="IDX-CHP-2-0032" class="indexterm"/><a id="IDX-CHP-2-0033" class="indexterm"/></p><p>To get an overview of the security-relevant compile-time options used by VLC, I scanned the executable files of the media player with LookingGlass (see <a class="xref" href="ch02s03.html#lookingglass_scan_result_of_vlc" title="Figure 2-9. LookingGlass scan result of VLC">Figure 2-9</a>).<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-11" class="footnoteref">16</a>]</sup><a id="IDX-CHP-2-0034" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In 2009, Microsoft released a tool called BinScope Binary Analyzer, which analyzes binaries for a wide variety of security protections with a very straightforward and easy-to-use interface.<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-12" class="footnoteref">17</a>]</sup></p></div><p>LookingGlass showed that the linker switch for neither ASLR nor DEP was used to compile VLC.<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-13" class="footnoteref">18</a>]</sup> The Windows releases of VLC media player are built using the Cygwin<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-14" class="footnoteref">19</a>]</sup> environment, a set of utilities designed to provide the look and feel of Linux within the Windows operating system. Since the linker switches that I mentioned are supported only by Microsoft’s Visual C++ 2005 SP1 and later (and thus are not supported by Cygwin), it isn’t a big surprise that they aren’t supported by VLC.</p><p><span class="emphasis"><em>Exploit mitigation techniques of Microsoft’s Visual C++ 2005 SP1 and later</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>/GS for stack cookies/canaries</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>/DYNAMICBASE for ASLR</em></span>.</p></li><li class="listitem"><p><span class="emphasis"><em>/NXCOMPAT for DEP/NX</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>/SAFESEH for exception handler protection</em></span></p></li></ul></div><div class="figure"><a id="lookingglass_scan_result_of_vlc"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1458"/><img src="httpatomoreillycomsourcenostarchimages939245.png.jpg" alt="LookingGlass scan result of VLC"/></div></div><p class="title">Figure 2-9. LookingGlass scan result of VLC</p></div><p>See the following excerpt from the VLC build instructions:<a id="IDX-CHP-2-0035" class="indexterm"/></p><a id="I_programlisting2_d1e1468"/><pre class="programlisting">[..]
Building VLC from the source code
=================================
[..]
- natively on Windows, using cygwin (www.cygwin.com) with or
 without the POSIX emulation layer. This is the preferred way to compile
 vlc if you want to do it on Windows.
[..]
UNSUPPORTED METHODS
-------------------
[..]
- natively on Windows, using Microsoft Visual Studio. This will not work.
[..]</pre><p>At the time of this writing, VLC didn’t make use of any of the exploit mitigation techniques provided by Windows Vista or later releases. As a result, every bug in VLC under Windows is as easily exploited today as 20 years ago, when none of these security features were widely deployed or supported.</p></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>2.3 Vulnerability Remediation</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="2.3 Vulnerability Remediation"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_remediation"/>2.3 Vulnerability Remediation</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Saturday, October 18, 2008</em></span></p></div><p>Now that I’ve discovered a security vulnerability, I could disclose it in several ways. I could contact the software developer and “responsibly” tell him what I’ve found and help him to create a patch. This process is referred to as <span class="emphasis"><em>responsible disclosure</em></span>. Since this term implies that other means of disclosure are irresponsible, which isn’t necessarily true, it is slowly being replaced by <span class="emphasis"><em>coordinated disclosure</em></span>.<a id="IDX-CHP-2-0020" class="indexterm"/><a id="IDX-CHP-2-0021" class="indexterm"/></p><p>On the other hand, I could sell my findings to a <span class="emphasis"><em>vulnerability broker</em></span> and let him tell the software developer. Today, the two primary players in the commercial vulnerability market are Verisign’s iDefense Labs, with its Vulnerability Contribution Program (VCP), and Tipping Point’s Zero Day Initiative (ZDI). Both VCP and ZDI follow coordinated-disclosure practices and work with the affected vendor.<a id="IDX-CHP-2-0022" class="indexterm"/></p><p>Another option is <span class="emphasis"><em>full disclosure</em></span>. If I chose full disclosure, I would release the vulnerability information to the public without notifying the vendor. There are other disclosure options, but the motivation behind them usually doesn’t involve fixing the bug (for example, selling the findings in underground markets).<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-6" class="footnoteref">11</a>]</sup><a id="IDX-CHP-2-0023" class="indexterm"/></p><p>In the case of the VLC vulnerability described in this chapter, I chose coordinated disclosure. In other words, I notified the VLC maintainers, provided them with the necessary information, and coordinated with them on the timing of public disclosure.</p><p>After I informed the VLC maintainers about the bug, they developed the following patch to address the vulnerability:<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-7" class="footnoteref">12</a>]</sup></p><a id="I_programlisting2_d1e1254"/><pre class="programlisting">--- a/modules/demux/ty.c
+++ b/modules/demux/ty.c
@@ −1639,12 +1639,14 @@ static void parse_master(demux_t *p_demux)
     /* parse all the entries */
     p_sys-&gt;seq_table = malloc(p_sys-&gt;i_seq_table_size * sizeof(ty_seq_table_t));
     for (i=0; i&lt;p_sys-&gt;i_seq_table_size; i++) {
<strong class="userinput"><code>-        stream_Read(p_demux-&gt;s, mst_buf, 8 + i_map_size);</code></strong>
<strong class="userinput"><code>+        stream_Read(p_demux-&gt;s, mst_buf, 8);</code></strong>
         p_sys-&gt;seq_table[i].l_timestamp = U64_AT(&amp;mst_buf[0]);
         if (i_map_size &gt; 8) {
             msg_Err(p_demux, "Unsupported SEQ bitmap size in master chunk");
<strong class="userinput"><code>+            stream_Read(p_demux-&gt;s, NULL, i_map_size);</code></strong>
             memset(p_sys-&gt;seq_table[i].chunk_bitmask, i_map_size, 0);
         } else {
<strong class="userinput"><code>+            stream_Read(p_demux-&gt;s, mst_buf + 8, i_map_size);</code></strong>
             memcpy(p_sys-&gt;seq_table[i].chunk_bitmask, &amp;mst_buf[8], i_map_size);
         }
     }</pre><p>The changes are quite straightforward. The formerly vulnerable call to <code class="literal">stream_Read()</code> now uses a fixed size value, and the user-controlled value of <code class="literal">i_map_size</code> is used only as a size value for <code class="literal">stream_Read()</code> if it is less than or equal to 8. An easy fix for an obvious bug.<a id="IDX-CHP-2-0024" class="indexterm"/><a id="IDX-CHP-2-0025" class="indexterm"/><a id="IDX-CHP-2-0026" class="indexterm"/><a id="IDX-CHP-2-0027" class="indexterm"/><a id="IDX-CHP-2-0028" class="indexterm"/></p><p>But wait—is the vulnerability really gone? The variable <code class="literal">i_map_size</code> is still of the type signed int. If a value greater than or equal to <code class="literal">0x80000000</code> is supplied for <code class="literal">i_map_size</code>, it’s interpreted as negative, and the overflow will still occur in the <code class="literal">stream_Read()</code> and <code class="literal">memcpy()</code> functions of the <code class="literal">else</code> branch of the patch (see Section A.3 for a description of unsigned int and signed int ranges). I also reported this problem to the VLC maintainers, resulting in another patch:<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-8" class="footnoteref">13</a>]</sup></p><a id="I_programlisting2_d1e1317"/><pre class="programlisting">[..]
@@ −1616,7 +1618,7 @@ static void parse_master(demux_t *p_demux)

 {
     demux_sys_t *p_sys = p_demux-&gt;p_sys;
     uint8_t mst_buf[32];
<strong class="userinput"><code>-    int i, i_map_size;</code></strong>
<strong class="userinput"><code>+    uint32_t i, i_map_size;</code></strong>
     int64_t i_save_pos = stream_Tell(p_demux-&gt;s);
     int64_t i_pts_secs;
[..]</pre><p>Now that <code class="literal">i_map_size</code> is of the type unsigned int, this bug is fixed. Perhaps you’ve already noticed that the <code class="literal">parse_master()</code> function contains another buffer overflow vulnerability. I also reported that bug to the VLC maintainers. If you can’t spot it, then take a closer look at the second patch provided by the VLC maintainers, which fixed this bug as well.</p><p>One thing that surprised me was the fact that none of the lauded exploit mitigation techniques of Windows Vista were able to stop me from taking control of <code class="literal">EIP</code> and executing arbitrary code from the stack using the <code class="literal">jmp reg</code> technique. The security cookie or /GS feature should have prevented the manipulation of the return address. Furthermore, ASLR or NX/DEP should have prevented arbitrary code execution. (See Section C.1 for a detailed description of all of these mitigation techniques.)<a id="IDX-CHP-2-0029" class="indexterm"/><a id="IDX-CHP-2-0030" class="indexterm"/><a id="IDX-CHP-2-0031" class="indexterm"/></p><p>To solve this mystery, I downloaded Process Explorer<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-9" class="footnoteref">14</a>]</sup> and configured it to show the processes’ DEP and ASLR status.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>To configure Process Explorer to show the processes’ DEP and ASLR status, I added the following columns to the view: <span class="strong"><strong>View</strong></span> ▸ <span class="strong"><strong>Select Columns</strong></span> ▸ <span class="strong"><strong>DEP Status</strong></span> and <span class="strong"><strong>View</strong></span> ▸ <span class="strong"><strong>Select Columns</strong></span> ▸ <span class="strong"><strong>ASLR Enabled</strong></span>. Additionally, I set the lower pane to view DLLs for a process and added the “ASLR Enabled” column.</p></div><p>The output of Process Explorer, illustrated in <a class="xref" href="ch02s03.html#vlc_in_process_explorer" title="Figure 2-8. VLC in Process Explorer">Figure 2-8</a>, shows that VLC and its modules use neither DEP nor ASLR (this is denoted by an empty value in the DEP and ASLR columns). I investigated further to determine why the VLC process does not use these mitigation techniques.</p><div class="figure"><a id="vlc_in_process_explorer"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1384"/><img src="httpatomoreillycomsourcenostarchimages939243.png.jpg" alt="VLC in Process Explorer"/></div></div><p class="title">Figure 2-8. VLC in Process Explorer</p></div><p>DEP can be controlled by system policy through special APIs and compile-time options (see Microsoft’s Security Research and Defense blog<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-10" class="footnoteref">15</a>]</sup> for more information on DEP). The default system-wide DEP policy for client operating systems such as Windows Vista is called OptIn. In this mode of operation, DEP is enabled only for processes that explicitly opt in to DEP. Because I used a default installation of Windows Vista 32-bit, the system-wide DEP policy should be set to OptIn. To verify this, I used the <code class="literal">bcdedit.exe</code> console application from an elevated command prompt:</p><a id="I_programlisting2_d1e1396"/><pre class="programlisting">C:\Windows\system32&gt;<strong class="userinput"><code>bcdedit /enum | findstr nx</code></strong>
nx                      OptIn</pre><p>The output of the command shows that the system was indeed configured to use the OptIn operation mode of DEP, which explains why VLC doesn’t use this mitigation technique: The process simply doesn’t opt in to DEP.</p><p>There are different ways to opt a process in to DEP. For example, you could use the appropriate linker switch (/NXCOMPAT) at compile time, or you could use the <code class="literal">SetProcessDEPPolicy</code> API to allow an application to opt in to DEP programmatically.<a id="IDX-CHP-2-0032" class="indexterm"/><a id="IDX-CHP-2-0033" class="indexterm"/></p><p>To get an overview of the security-relevant compile-time options used by VLC, I scanned the executable files of the media player with LookingGlass (see <a class="xref" href="ch02s03.html#lookingglass_scan_result_of_vlc" title="Figure 2-9. LookingGlass scan result of VLC">Figure 2-9</a>).<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-11" class="footnoteref">16</a>]</sup><a id="IDX-CHP-2-0034" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In 2009, Microsoft released a tool called BinScope Binary Analyzer, which analyzes binaries for a wide variety of security protections with a very straightforward and easy-to-use interface.<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-12" class="footnoteref">17</a>]</sup></p></div><p>LookingGlass showed that the linker switch for neither ASLR nor DEP was used to compile VLC.<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-13" class="footnoteref">18</a>]</sup> The Windows releases of VLC media player are built using the Cygwin<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-14" class="footnoteref">19</a>]</sup> environment, a set of utilities designed to provide the look and feel of Linux within the Windows operating system. Since the linker switches that I mentioned are supported only by Microsoft’s Visual C++ 2005 SP1 and later (and thus are not supported by Cygwin), it isn’t a big surprise that they aren’t supported by VLC.</p><p><span class="emphasis"><em>Exploit mitigation techniques of Microsoft’s Visual C++ 2005 SP1 and later</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>/GS for stack cookies/canaries</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>/DYNAMICBASE for ASLR</em></span>.</p></li><li class="listitem"><p><span class="emphasis"><em>/NXCOMPAT for DEP/NX</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>/SAFESEH for exception handler protection</em></span></p></li></ul></div><div class="figure"><a id="lookingglass_scan_result_of_vlc"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1458"/><img src="httpatomoreillycomsourcenostarchimages939245.png.jpg" alt="LookingGlass scan result of VLC"/></div></div><p class="title">Figure 2-9. LookingGlass scan result of VLC</p></div><p>See the following excerpt from the VLC build instructions:<a id="IDX-CHP-2-0035" class="indexterm"/></p><a id="I_programlisting2_d1e1468"/><pre class="programlisting">[..]
Building VLC from the source code
=================================
[..]
- natively on Windows, using cygwin (www.cygwin.com) with or
 without the POSIX emulation layer. This is the preferred way to compile
 vlc if you want to do it on Windows.
[..]
UNSUPPORTED METHODS
-------------------
[..]
- natively on Windows, using Microsoft Visual Studio. This will not work.
[..]</pre><p>At the time of this writing, VLC didn’t make use of any of the exploit mitigation techniques provided by Windows Vista or later releases. As a result, every bug in VLC under Windows is as easily exploited today as 20 years ago, when none of these security features were widely deployed or supported.</p></div></body></html>
